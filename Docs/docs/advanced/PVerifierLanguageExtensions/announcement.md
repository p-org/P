# Announcing the New Verification Backend for P

We are excited to announce the release of a new verification backend for the P programming language! This backend allows you to prove that your systems behave correctly under all possible scenarios. The backend is based on Mora et al. ([OOPSLA '23](https://dl.acm.org/doi/10.1145/3622876)) and uses UCLID5 (Polgreen et al., [CAV '22](https://dl.acm.org/doi/10.1007/978-3-031-13185-1_27)).

Before this new verification backend, P helped users catch design-level bugs early in the development process through explicit-state model checking (Brooker and Desai, [Queue '25](https://dl.acm.org/doi/10.1145/3712057)). Given a formal model, specification, and a test driver describing a system configuration, the model checking backend systematically explores the given model in search of an execution that violates the given specification for the given system configuration. See the [Two-Phase Commit example tutorial](twopahsecommitverification.md) for an example model, specification, and three test drivers corresponding to three different system configurations (e.g., a configuration with three participants, one coordinator, and one client). P was used in this way to help AWS migrate [S3 (Simple Storage Service) from eventual to strong read-after-write consistency](https://aws.amazon.com/about-aws/whats-new/2020/12/amazon-s3-now-delivers-strong-read-after-write-consistency-automatically-for-all-applications/).

The new verification backend allows users to **prove** that their system design is correct for all executions over all possible system configurations. Instead of using explicit-state model checking, the new backend supports proofs by induction. Users still provide a formal model and specification. But, instead of giving a test driver, users must provide assumptions about what is possible in the system and an inductive invariant that implies that the given model satisfies the given specification under the given assumptions. The main job of the backend is to check that that given invariant is indeed inductive (all possible events in the system preserve it) and that the given invariant does indeed imply the given specification. UCLID5 accomplishes this job by way of a satisfiability modulo theories (SMT) solver, like Z3 (de Moura and Bjørner, [TACAS '08](https://link.springer.com/chapter/10.1007/978-3-540-78800-3_24)).

Formal verification is important to AWS’s software correctness program (Brooker and Desai, [Queue '25](https://dl.acm.org/doi/10.1145/3712057)). Existing tools, like [Kani](https://model-checking.github.io/kani-verifier-blog/2023/08/31/using-kani-to-validate-security-boundaries-in-aws-firecracker.html), Dafny (Leino, [LPAR '10](https://dl.acm.org/doi/10.5555/1939141.1939161)), and Lean (de Moura and Ullrich, [CADE '21](https://lean-lang.org/papers/lean4.pdf)), offer users powerful abstractions and automation for verifying programs. Each tool has had big industrial success stories in their respective domains. The new verification backend in P gives users the benefits of correctness proofs for the domain of distributed systems design, all while preserving the existing benefits of systematic testing.

## Getting Started

To start using the new verification backend, you must install P along with the verification dependencies (UCLID5 and an SMT solver like Z3). Detailed installation instructions are available [here](https://github.com/p-org/P/blob/master/Docs/docs/advanced/install-verification-backend.md).

## Tutorial: Two-Phase Commit Verification

To help you get acquainted with the new verification features, we have prepared a comprehensive tutorial that walks you through the formal verification of a simplified two-phase commit (2PC) protocol. This tutorial covers the key concepts and steps of using the verification backend. You can find the tutorial [here](twophasecommitverification.md).

We hope you find these new features useful and look forward to your feedback. Happy verifying!
