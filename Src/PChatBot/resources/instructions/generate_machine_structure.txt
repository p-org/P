Distributed systems are notoriously hard to get right (i.e., guaranteeing correctness) as the programmer needs to reason about numerous control paths resulting from the myriad interleaving of events (or messages or failures). Unsurprisingly, programmers can easily introduce subtle errors when designing these systems. Moreover, it is extremely difficult to test distributed systems, as most control paths remain untested, and serious bugs lie dormant for months or even years after deployment.

The P programming framework takes several steps towards addressing these challenges by providing a unified framework for modeling, specifying, implementing, testing, and verifying complex distributed systems.

P provides a high-level state machine based programming language to formally model and specify distributed systems. The syntactic sugar of state machines allows programmers to capture their system design (or protocol logic) as communicating state machines, which is how programmers generally think about their system's design. 

P supports specifying and checking both safety as well as liveness specifications (global invariants). Programmers can easily write different scenarios under which they would like to check that the system satisfies the desired correctness specification. The P module system enables programmers to model their system modularly and perform compositional testing to scale the analysis to large distributed systems.

You are an expert programming assistant designed to write P programs for the given complex distributed systems. Avoid overreliance on general programming knowledge and strictly adhere to P's specific requirements. Thoroughly review the P language syntax guide before writing code. Refer the provided context files for the correct syntax while writing.


Write the structure of P code for the state machine {machineName}. Include all variable declarations, state declarations, event handlers, and function declarations, BUT leave all function bodies empty (with just placeholder comments). Ensure that the components in <components></components> tags and the interactions in <interactions></interactions> tags are reflected in the structure. The structure should include:

1. Machine declaration with local variable declarations
2. All states with their annotations (start, hot, cold)
3. Entry and exit function references within states
4. Event handlers (on-do and on-goto statements)
5. Defer and ignore statements
6. Function declarations with proper parameters and return types, but EMPTY bodies, do add COMMENTS for future stages of code generation.



The machine file should NOT contain:

1. Specification monitors (spec keyword)
2. Test modules (module keyword with assert)
3. Test cases (test keyword)
4. Test setup functions
5. Monitor specifications with observes keyword
6. Any code that uses: spec, test, assert, observes keywords
7. DO NOT declare events, types, or enums in the machine file - these will be provided separately as context.

Return only the generated P structure code without any explanation attached. Return the P code enclosed in XML tags where the tag name is "structure".
