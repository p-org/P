// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using Microsoft.Coyote.Tasks;
using SystemTasks = System.Threading.Tasks;

namespace Microsoft.Coyote.SystematicTesting
{
    /// <summary>
    /// Contains information about an asynchronous task operation
    /// that can be controlled during testing.
    /// </summary>
    [DebuggerStepThrough]
    internal sealed class TaskOperation : AsyncOperation
    {
        /// <summary>
        /// A cache from async controlled task state machine types generated by
        /// the compiler to the corresponding asynchronous methods.
        /// </summary>
        internal static readonly Dictionary<Type, MethodBase> AsyncTaskMethodCache =
            new Dictionary<Type, MethodBase>();

        /// <summary>
        /// The scheduler executing this operation.
        /// </summary>
        private readonly OperationScheduler Scheduler;

        /// <summary>
        /// The unique id of the operation.
        /// </summary>
        public override ulong Id { get; }

        /// <summary>
        /// The unique name of the operation.
        /// </summary>
        public override string Name { get; }

        /// <summary>
        /// Set of tasks that this operation is waiting to join. All tasks
        /// in the set must complete before this operation can resume.
        /// </summary>
        private readonly HashSet<SystemTasks.Task> JoinDependencies;

        /// <summary>
        /// The root asynchronous method that is executed by this operation.
        /// </summary>
        private MethodBase RootAsyncTaskMethod;

        /// <summary>
        /// The asynchronous method that is current executed by this operation.
        /// </summary>
        private MethodBase CurrAsyncTaskMethod;

        /// <summary>
        /// Initializes a new instance of the <see cref="TaskOperation"/> class.
        /// </summary>
        internal TaskOperation(ulong operationId, OperationScheduler scheduler)
            : base()
        {
            this.Scheduler = scheduler;
            this.Id = operationId;
            this.Name = $"Task({operationId})";
            this.JoinDependencies = new HashSet<SystemTasks.Task>();
        }

        internal void OnGetAwaiter()
        {
            this.IsAwaiterControlled = true;
        }

        /// <summary>
        /// Invoked when the operation is waiting to join the specified task.
        /// </summary>
        internal void OnWaitTask(SystemTasks.Task task)
        {
            IO.Debug.WriteLine("<ScheduleDebug> Operation '{0}' is waiting for task '{1}'.", this.Id, task.Id);
            this.JoinDependencies.Add(task);
            this.Status = AsyncOperationStatus.BlockedOnWaitAll;
            this.Scheduler.ScheduleNextEnabledOperation();
            this.IsAwaiterControlled = false;
        }

        /// <summary>
        /// Invoked when the operation is waiting to join the specified tasks.
        /// </summary>
        internal void OnWaitTasks(IEnumerable<Task> tasks, bool waitAll)
        {
            foreach (var task in tasks)
            {
                if (!task.IsCompleted)
                {
                    IO.Debug.WriteLine("<ScheduleDebug> Operation '{0}' is waiting for task '{1}'.", this.Id, task.Id);
                    this.JoinDependencies.Add(task.UncontrolledTask);
                }
            }

            if (this.JoinDependencies.Count > 0)
            {
                this.Status = waitAll ? AsyncOperationStatus.BlockedOnWaitAll : AsyncOperationStatus.BlockedOnWaitAny;
                this.Scheduler.ScheduleNextEnabledOperation();
            }

            this.IsAwaiterControlled = false;
        }

        /// <summary>
        /// Tries to enable the operation, if it was not already enabled.
        /// </summary>
        internal override void TryEnable()
        {
            if (this.Status == AsyncOperationStatus.BlockedOnWaitAll)
            {
                IO.Debug.WriteLine("<ScheduleDebug> Try enable operation '{0}'.", this.Id);
                if (!this.JoinDependencies.All(task => task.IsCompleted))
                {
                    IO.Debug.WriteLine("<ScheduleDebug> Operation '{0}' is waiting for all join tasks to complete.", this.Id);
                    return;
                }

                this.JoinDependencies.Clear();
                this.Status = AsyncOperationStatus.Enabled;
            }
            else if (this.Status == AsyncOperationStatus.BlockedOnWaitAny)
            {
                IO.Debug.WriteLine("<ScheduleDebug> Try enable operation '{0}'.", this.Id);
                if (!this.JoinDependencies.Any(task => task.IsCompleted))
                {
                    IO.Debug.WriteLine("<ScheduleDebug> Operation '{0}' is waiting for any join task to complete.", this.Id);
                    return;
                }

                this.JoinDependencies.Clear();
                this.Status = AsyncOperationStatus.Enabled;
            }
        }

        /// <summary>
        /// Sets the root asynchronous controlled task state machine
        /// of this operation, if it is not already set.
        /// </summary>
        internal void SetRootAsyncTaskStateMachine(Type stateMachineType)
        {
            if (this.RootAsyncTaskMethod is null)
            {
                // The call stack is empty, so traverse the stack trace to find the first
                // user defined method to be executed by this operation and set it as root.
                StackTrace st = new StackTrace(false);
                for (int i = st.FrameCount - 1; i > 0; i--)
                {
                    StackFrame sf = st.GetFrame(i);
                    if (TryGetUserDefinedAsyncMethodFromStackFrame(sf, stateMachineType, out MethodBase method))
                    {
                        this.RootAsyncTaskMethod = method;
                        break;
                    }
                }

                if (this.RootAsyncTaskMethod is null)
                {
                    throw new RuntimeException($"Operation '{this.Id}' is unable to find and set a root asynchronous method.");
                }
            }
        }

        /// <summary>
        /// Sets the asynchronous controlled task state machine with the specified type
        /// as the currently executed by this operation.
        /// </summary>
        internal void SetExecutingAsyncTaskStateMachineType(Type stateMachineType) =>
            this.CurrAsyncTaskMethod = GetAsyncTaskMethodComponents(stateMachineType);

        /// <summary>
        /// Checks if the operation is currently executing the root asynchronous method.
        /// </summary>
        internal bool IsExecutingInRootAsyncMethod() =>
            this.RootAsyncTaskMethod == this.CurrAsyncTaskMethod;

        /// <summary>
        /// Returns a tuple containing the name and declaring type of the asynchronous controlled
        /// task method with the specified type.
        /// </summary>
        private static MethodBase GetAsyncTaskMethodComponents(Type stateMachineType)
        {
            if (!AsyncTaskMethodCache.TryGetValue(stateMachineType, out MethodBase method))
            {
                // Traverse the stack trace to identify and return the currently executing
                // asynchronous controlled task method, and cache it for quick access later
                // in the execution or future test iterations.
                StackTrace st = new StackTrace(false);
                for (int i = 0; i < st.FrameCount; i++)
                {
                    StackFrame sf = st.GetFrame(i);
                    if (TryGetUserDefinedAsyncMethodFromStackFrame(sf, stateMachineType, out method))
                    {
                        AsyncTaskMethodCache.Add(stateMachineType, method);
                        break;
                    }
                }
            }

            return method;
        }

        /// <summary>
        /// Tries to get the user defined asynchronous method from the specified stack frame and
        /// asynchronous state machine type, if there is one, else returns false.
        /// </summary>
        private static bool TryGetUserDefinedAsyncMethodFromStackFrame(StackFrame stackFrame, Type stateMachineType, out MethodBase method)
        {
            // TODO: explore optimizations for this logic.
            MethodBase sfMethod = stackFrame.GetMethod();

            string sfMethodModuleName = sfMethod.Module.Name;
            if (sfMethodModuleName == "mscorlib.dll" ||
                sfMethodModuleName == "System.Private.CoreLib.dll" ||
                sfMethodModuleName == "Microsoft.Coyote.dll")
            {
                method = default;
                return false;
            }

            if (sfMethod.Name == "MoveNext")
            {
                // Skip the compiler generated state machine method.
                var attributes = sfMethod.DeclaringType.CustomAttributes;
                if (sfMethod.DeclaringType == stateMachineType ||
                    attributes.Any(attr => attr.AttributeType == typeof(CompilerGeneratedAttribute)))
                {
                    method = default;
                    return false;
                }
            }

            method = sfMethod;
            return true;
        }
    }
}
