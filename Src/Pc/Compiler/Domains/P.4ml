domain P extends PStaticTyping, PStructuralTyping
{

}

domain PData
{        
    /*************************************************************/
    /****************          Type Language          ************/
    /*************************************************************/    
       
    //// The BaseType REAL is the type of real machines.
    BaseType        ::= new ({ NULL, BOOL, INT, EVENT, REAL, FOREIGN, ANY }).
    TupType         ::= new (hd: any TypeExpr, tl: any TupType + { NIL }).
    NmdTupType      ::= new (hd: any NmdTupTypeField, tl: any NmdTupType + { NIL }).
    SeqType         ::= new (x: any TypeExpr).
    MapType         ::= new (k: any TypeExpr, v: any TypeExpr).
    NmdTupTypeField ::= new (name: any String, type: any TypeExpr). 
	InterfaceType	::= new (name: any String).
    TypeExpr        ::= BaseType + TupType + NmdTupType + SeqType + MapType + InterfaceType.
        
    /*************************************************************/
    /****************          Action Language        ************/
    /*************************************************************/    
                               
    //// Expressions
    Name       ::= new (name: String).
    New        ::= new (name: String, arg: any Expr + { NIL }).
    FunApp     ::= new (name: String, args: any Exprs + { NIL }).
    NulApp     ::= new (op: Integer + Boolean + { THIS, TRIGGER, PAYLOAD, NONDET, FAIRNONDET, NULL, HALT }).
    UnApp      ::= new (op: { NOT, NEG, KEYS, VALUES, SIZEOF }, arg1: any Expr).
    BinApp     ::= new (op: { ADD, SUB, MUL, INTDIV, AND, OR, EQ, NEQ, LT, LE, GT, GE, IDX, IN }, arg1: any Expr, arg2: any Expr).
    Field      ::= new (arg: any Expr, name: String + Natural).
    Default    ::= new (type: any TypeExpr). 
    Cast       ::= new (arg: any Expr, type: any TypeExpr). 
    Tuple      ::= new (body: any Exprs).
    NamedTuple ::= new (body: any NamedExprs).
    Exprs      ::= new (head: any Expr, tail: any Exprs + { NIL }).              
    NamedExprs ::= new (field: String, exp: any Expr, tail: any NamedExprs + { NIL }).
    Expr       ::= Name + New + FunApp + NulApp + UnApp + BinApp + Field + Default + Cast + Tuple + NamedTuple.
    ExprsExt   ::= Expr + Exprs + NamedExprs.

    //// Statements
    NewStmt  ::= new (name: String, arg: any Expr + { NIL }).
    Raise    ::= new (ev: any Expr, arg: any Expr + { NIL }).
    Send     ::= new (dest: any Expr, ev: any Expr, arg: any Expr + { NIL }).
    Monitor  ::= new (ev: any Expr, arg: any Expr + { NIL }).
    FunStmt  ::= new (name: String, args: any Exprs + { NIL }, aout: any Name + { NIL }, label: Natural).
    NulStmt  ::= new (op: { SKIP, POP }).
    UnStmt   ::= new (op: { ASSERT }, arg1: any Expr).
    BinStmt  ::= new (op: { REMOVE, ASSIGN, INSERT }, arg1: any Expr, arg2: any Expr).
    Return   ::= new (expr: any Expr + { NIL }).
    While    ::= new (cond: any Expr, body: any Stmt).
    Ite      ::= new (cond: any Expr, true: any Stmt, false: any Stmt).
    Seq      ::= new (s1: any Stmt, s2: any Stmt).
	Cases	 ::= new (trig: String + { NULL, HALT }, action: any AnonFunDecl, cases: any Cases + { NIL }).
	Receive  ::= new (cases: any Cases, label: Natural).

    Stmt ::= NewStmt + Raise + Send + Monitor + FunStmt + NulStmt + UnStmt + BinStmt + Return + While + Ite + Seq + Receive. 

	/*************************************************************/
    /****************  Module Declarations    *************/
    /*************************************************************/
	InterfaceEventDecl ::= new (interface: any InterfaceType, ev: String).

	MachineReceivesDecl ::= new (mach: any MachineDecl, ev: String).
	MachineImpsInterfaceDecl ::= new (mach: any MachineDecl, inter: any InterfaceType).

	ModuleDecl ::= new (name : any String).
	ModuleSendsDecl ::= new (mod: any ModuleDecl, ev: String).
	ModulePrivateDecl ::= new (mod: any ModuleDecl, ev: String).
	ModuleCreatesDecl ::= new (mod : any ModuleDecl, inter: any InterfaceType).
	
	ImplementationModules ::= new (mL: any ModuleList).
	SpecificationModules ::= new (sL: any ModuleList).
	RefinesTestDecl ::= fun (name: String -> imp: any ModuleList, spec: any ModuleList).
	MonitorsTestDecl ::= fun (name: String -> imp: any ModuleList, monitors: any MonitorList).
	NoFailureTestDecl ::= fun (name: String -> imp: any ModuleList).

	ModuleList ::= new (mod: any Module, tail: any ModuleList + {NIL}).
	Hide ::= new (ei: any EventsOrInterfaces, modL: any ModuleList).
	PrivateMonitor ::= new (mon: String, mod: any ModuleDecl).
	MonitorList ::= new (mon: any MonitorKind, tail: any MonitorList + {NIL}).
	EventList ::= new (ev: String, tail: any EventList + {NIL}).
	InterfaceList ::= new (inter: any InterfaceType, tail: any InterfaceList + {NIL}).
	
	//combining value types (used in PToZing)
	Module ::= ModuleDecl + Hide.
	EventsOrInterfaces ::= EventList + InterfaceList.
	MonitorKind ::= String + PrivateMonitor. //String represents the global monitor name

    /*************************************************************/
    /****************  State Machine Declarations    *************/
    /*************************************************************/

    EventDecl      ::= fun (name: String -> card: any QueueConstraint, type: any TypeExpr + { NIL }).    
    MachineDecl    ::= fun (name: String, mod: any ModuleDecl + {NIL} -> kind: { REAL, MODEL, MONITOR }, card: any QueueConstraint, start: any QualifiedName, isMain: Boolean).

	ObservesDecl   ::= new (monitor: MachineDecl, ev: String).

    VarDecl        ::= fun (name: String, owner: MachineDecl -> type: any TypeExpr).
    
    FunDecl        ::= fun (name: String, owner: MachineDecl + { NIL } -> kind: { REAL, MODEL }, params: any NmdTupType + { NIL },  return: any TypeExpr + { NIL }, locals: any NmdTupType + { NIL }, body: any Stmt).
    AnonFunDecl    ::= new (owner: MachineDecl + { NIL }, locals: any NmdTupType + { NIL }, body: any Stmt, envVars: any NmdTupType + { NIL }).
    
    StateDecl      ::= fun (name: any QualifiedName, owner: MachineDecl -> entryAction: any AnonFunDecl + String, exitFun: any AnonFunDecl + String, temperature: { HOT, WARM, COLD }).
    TransDecl      ::= fun (src: StateDecl, trig: String + { NULL, HALT } -> dst: any QualifiedName, action: any { PUSH } + AnonFunDecl + String).
    DoDecl         ::= fun (src: StateDecl, trig: String + { NULL, HALT } -> action: any { DEFER, IGNORE } + AnonFunDecl + String).

    PDecl          ::= EventDecl + MachineDecl + VarDecl + AnonFunDecl + FunDecl + StateDecl + TransDecl + DoDecl + ObservesDecl + InterfaceEventDecl + MachineImpsInterfaceDecl + MachineReceivesDecl + ModuleDecl + ModuleSendsDecl + ModulePrivateDecl + ModuleCreatesDecl + ImplementationModules + SpecificationModules + RefinesTestDecl + MonitorsTestDecl + NoFailureTestDecl.            

    AssumeMaxInstances ::= new (bound: Natural).
    AssertMaxInstances ::= new (bound: Natural).
    QualifiedName      ::= new (name: String, qualifier: any QualifiedName + { NIL }).
    QueueConstraint    ::= AssumeMaxInstances + AssertMaxInstances + { NIL }.
    EventLabel         ::= String + { NULL, HALT }.

    /*************************************************************/
    /****************          Annotations           *************/
    /*************************************************************/

    Annotation  ::= new (ant: Annotatable, key: String, value: any AnnotValue).
    Annotatable ::= EventDecl + MachineDecl + VarDecl + FunDecl + StateDecl + TransDecl + DoDecl + { NIL }.
    AnnotValue  ::= Integer + String + Boolean + { NULL }.


	FunAvailable ::= (f: FunDecl, m: MachineDecl + { NIL }).
    FunAvailable(f, m) :- f is FunDecl, m is MachineDecl, f.owner = NIL;
	                      f is FunDecl, f.owner = m.

   	RealOwner ::= (f: FunDecl).
	RealOwner(f) :- f is FunDecl, f.owner = NIL; 
	                f is FunDecl, f.owner.kind = REAL.
	
	//all machines in implementation modules list
	AllImpModules ::= sub (imodL: ImplementationModules, mod: ModuleDecl).
	ImpMachine ::= (mach: MachineDecl).
	ImpMachine(m) :- AllImpModules(modl, mod), m is MachineDecl(_, mod, _, _, _, _).
}

domain PStructuralTyping extends PData
{
    /*************************************************************/
	conforms no OneDeclError(_).
	conforms no TwoDeclError(_, _).
	conforms no DeclFunError(_, _).
    /*************************************************************/

	////// Three kinds of declaration errors (and missingDecl).
    OneDeclError ::= (PDecl).
    TwoDeclError ::= (PDecl, PDecl).
    DeclFunError ::= (PDecl, String).

    [ rule_Classes = '"error, msg: Global function has the same name"']
    TwoDeclError(f1, f2) :- f1 != f2, f1 is FunDecl, f2 is FunDecl, f1.name = f2.name, f1.owner = NIL, f2.owner != NIL.

	[ rule_Classes = '"error, msg: Multiple Transitions over the same event"']
	TwoDeclError(t1, t2) :- t1 != t2, t1 is TransDecl, t2 is TransDecl, t1.src = t2.src, t1.trig = t2.trig.
	[ rule_Classes = '"error, msg: Multiple actions over the same event"']
	TwoDeclError(a1, a2) :- a1 != a2, a1 is DoDecl(state, owner, _), a2 is DoDecl(state, owner, _), a1.src = a2.src, a1.trig = a2.trig.
	
	//// there should be a start state in each state machine.
	[ rule_Classes = '"error, msg: no start state in machine"']
	OneDeclError(m) :- m is MachineDecl, no StateDecl(s, m , _, _, _), m.start = s.
	
	//Valid TransDecl
	[ rule_Classes = '"error, msg: transition on an undefined event"']
	OneDeclError(trns) :- trns is TransDecl, no EventDecl(trns.trig, _, _), trns.trig != NULL, trns.trig != HALT.
	[rule_Classes = '"error, msg: transition to an undefined state"']
	OneDeclError(trns) :- trns is TransDecl, no StateDecl(trns.dst, trns.src.owner, _, _, _).
	
	[rule_Classes = '"error, msg: transition function not defined"'] // disallowing static functions for now
	OneDeclError(trns) :- trns is TransDecl(_, _, _, act), act : String, 
	                      no FunDecl(act, trns.src.owner, _, _, _, _, _), no FunDecl(act, NIL, _, _, _, _, _).
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	OneDeclError(trns) :- trns is TransDecl(_, _, _, act), act : String, FunDecl(act, trns.src.owner, _, p, _, _, _), p != NIL;
	                      trns is TransDecl(_, _, _, act), act : String, FunDecl(act, NIL, _, p, _, _, _), p != NIL.
	
	//Valid DoDecl
	[ rule_Classes = '"error, msg: action on an undefined event"']
	OneDeclError(doD) :- doD is DoDecl, no EventDecl(doD.trig, _, _), doD.trig != HALT, doD.trig != NULL.
	
	[rule_Classes = '"error, msg: function not defined"'] // disallowing static functions for now
	OneDeclError(trns) :- trns is DoDecl(_, _, act), act : String, 
	                      no FunDecl(act, trns.src.owner, _, _, _, _, _), no FunDecl(act, NIL, _, _, _, _, _).
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	OneDeclError(trns) :- trns is DoDecl(_, _, act), act : String , FunDecl(act, trns.src.owner, _, p, _, _, _), p != NIL;
	                      trns is DoDecl(_, _, act), act : String , FunDecl(act, NIL, _, p, _, _, _), p != NIL.
	
	//Entry Exit Functions
	[rule_Classes = '"error, msg: undefined function for entry"'] // disallowing static functions for now
	DeclFunError(s, eF) :- s is StateDecl(_, _, eF, _, _), eF : String, 
	                       no FunDecl(eF, s.owner, _, _, _, _, _), no FunDecl(eF, NIL, _, _, _, _, _). 

	[rule_Classes = '"error, msg: undefined function for exit"'] // disallowing static functions for now
	DeclFunError(s, eF) :- s is StateDecl(_, _, _, eF, _), eF : String, 
	                       no FunDecl(eF, s.owner, _, _, _, _, _), no FunDecl(eF, NIL, _, _, _, _, _).
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, eF, _, _), eF : String , FunDecl(eF, s.owner, _, p, _, _, _), p != NIL;
	                       s is StateDecl(_, _, eF, _, _), eF : String , FunDecl(eF, NIL, _, p, _, _, _), p != NIL.
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, _, eF, _), eF : String , FunDecl(eF, s.owner, _, p, _, _, _), p != NIL;
	                       s is StateDecl(_, _, _, eF, _), eF : String , FunDecl(eF, NIL, _, p, _, _, _), p != NIL.
	
	//cannot have null in Monitors
	[rule_Classes = '"error, msg: null transitions not allowed in monitors"']
	OneDeclError(t) :- t is TransDecl(s, NULL, _, _), s.owner.kind = MONITOR.
	[rule_Classes = '"error, msg: push transitions not allowed in monitors"']
	OneDeclError(t) :- t is TransDecl(s, _, _, PUSH), s.owner.kind = MONITOR.

	//no defer in monitors
	[rule_Classes = '"error, msg: defer not allowed in monitor"']
	OneDeclError(d) :- d is DoDecl(s, _, DEFER), s.owner.kind = MONITOR.	

	//event in monitors is declared
	[rule_Classes = '"error, msg: event in monitors set is not declared"']
	OneDeclError(obs) :- obs is ObservesDecl, obs.monitor.kind = MONITOR, no EventDecl(obs.ev, _, _).	

	//event in interface type 
	[rule_Classes = '"error, msg: unknown event in interface declaration"']
	OneDeclError(inter) :- inter is InterfaceEventDecl(_, e), no EventDecl(e, _, _).

	//interface type in variable decl.
	[rule_Classes = '"error, msg: unknown type in variable declaration"']
	OneDeclError(varD) :- varD is VarDecl(_, _, tp), tp : InterfaceType, no InterfaceEventDecl(tp, _).

	//interface type in machine declaration
	[rule_Classes = '"error, msg: interface type in implements is not declared"']
	OneDeclError(machInterface) :- machInterface is MachineImpsInterfaceDecl(_, i), no InterfaceEventDecl(i, _).

	//event in receives of a machine
	[rule_Classes = '"error, msg: event in receives is not declared"']
	OneDeclError(receivesE) :- receivesE is MachineReceivesDecl(_, ev), no EventDecl(ev, _, _).

	//event in sends of a module
	[rule_Classes = '"error, msg: event in sends is not declared"']
	OneDeclError(sendsE) :- sendsE is ModuleSendsDecl(_, ev), no EventDecl(ev, _, _).

	//event in private of a module
	[rule_Classes = '"error, msg: event in private is not declared"']
	OneDeclError(private) :- private is ModulePrivateDecl(_, ev), no EventDecl(ev, _, _).

	//interface type in creates declaration
	[rule_Classes = '"error, msg: interface type in creates is not declared"']
	OneDeclError(creates) :- creates is ModuleCreatesDecl(_, i), no InterfaceEventDecl(i, _).
	
	CompDecls ::= ImplementationModules + SpecificationModules + RefinesTestDecl + MonitorsTestDecl + NoFailureTestDecl.
	VariousList ::= ModuleList + EventList + MonitorList + InterfaceList.

	//module is declared
	SubVL ::= sub (c: CompDecls, mem: VariousList).
	[rule_Classes = '"error, msg: module in the list is not declared"']
	OneDeclError(c) :- SubVL(c, ml), ml = ModuleList(ModuleDecl(m), _), no ModuleDecl(m).
	
	//event in hide is declared
	[rule_Classes = '"error, msg: event used in hide operation is not declared"']
	OneDeclError(c) :- SubVL(c, ml), ml = EventList(ev, _), no EventDecl(ev, _, _).

	//interface in hide is declared
	[rule_Classes = '"error, msg: event used in hide operation is not declared"']
	OneDeclError(c) :- SubVL(c, ml), ml = InterfaceList(i, _), no InterfaceEventDecl(i, _).
	
	//monitor is declared
	[rule_Classes = '"error, msg: monitor is undeclared"']
	OneDeclError(c) :- SubVL(c, ml), ml = MonitorList(s, _), s : String, no MachineDecl(s, _, MONITOR, _, _, _);
					   SubVL(c, ml), ml = MonitorList(m, _), m = PrivateMonitor(s, _), no MachineDecl(s, _, MONITOR, _, _, _).
	
	//module in private monitor is declared
	[rule_Classes = '"error, msg: undeclared module in private monitor declaration"']
	OneDeclError(c) :- SubVL(c, ml), ml = MonitorList(m, _), m = PrivateMonitor(_, ModuleDecl(s)), no ModuleDecl(s).

	//only one liveness monitor is allowed per test case
	[ rule_Classes = '"error, msg: multiple liveness monitors declared in the test-case"']
	OneDeclError(c) :- SubVL(c, ml1), SubVL(c, ml2), ml1 = MonitorList(s1, _), ml2 = MonitorList(s2, _), s1 != s2, 
					   mach1 = MachineDecl(s1, _, MONITOR, _, _, _),  mach2 = MachineDecl(s2, _, MONITOR, _, _, _), StateDecl(_, mach1, _, _, k1), k1 != WARM, StateDecl(_, mach2, _, _, k2), k2 != WARM.
}

domain PStaticTyping extends PData
/*
[
    compiler_ProductivityCheck = "TypeOf[1]"
]
*/
{
    /*************************************************************/
	conforms no TypeOf(_, _, ERROR). 
	conforms no DupNmdSubE(_, _, _, _).
	conforms no PurityError(_, _).
	conforms no MonitorError(_, _).
	conforms no LValueError(_, _).
	conforms no BadLabelError(_).
	conforms no DomOfMapUnSafe(_).
	conforms no ModuleLevelTypingError(_).
	conforms no IllegalMainMachine(_).
	conforms no IllegalComposition(_).
	conforms no IllegalHideOperation(_).
	conforms no IllegalMonitorTestCase(_).
	conforms no IllegalRefinesTestCase(_).

    /*************************************************************/

	/****************************************************************/
    //// The declarations that may contain expressions or statements that should be typed.
    TypingContext ::= FunDecl + AnonFunDecl.
    
    //// The set of typeable expressions and statements.
    Typeable ::= Expr + Stmt + Exprs + NamedExprs + Cases.
    
    //// The type judgement. NIL is a placeholder for untyped constructs.
    TypeOf ::= (cntxt: TypingContext, expr: Typeable, type: TypeExpr + { ERROR, NIL }).

    //// All typing contexts anywhere in the input program.
	SubCntxt ::= sub (cntxt: TypingContext).
    
    //// All typeable subexpressions / substatements and the declarations in which they appear.
    //SubSE ::= sub (cntxt: TypingContext, typeable: Typeable).

	//// Comment out the following rules and uncomment the rule above to get the original behavior
	SubSE ::= (cntxt: TypingContext, typeable: Typeable).
	SubSE(cntxt, typeable) :- SubCntxt(cntxt), cntxt = AnonFunDecl(_, _, typeable, _).
	SubSE(cntxt, typeable) :- SubCntxt(cntxt), cntxt = FunDecl(_, _, _, _,  _, _, typeable).
	SubSE(c, e), SubSE(c, s) :- SubSE(c, While(e, s)).
	SubSE(c, e), SubSE(c, s1), SubSE(c, s2) :- SubSE(c, Ite(e, s1, s2)).
	SubSE(c, s1), SubSE(c, s2) :- SubSE(c, Seq(s1, s2)).
	SubSE(c, cases) :- SubSE(c, Receive(cases, _)).
	SubSE(c, cases) :- SubSE(c, Cases(_, _, cases)), cases: Cases.
	SubSE(c, e) :- SubSE(c, Return(e)), e: Expr.
	SubSE(c, e1), SubSE(c, e2) :- SubSE(c, BinStmt(_, e1, e2)).
	SubSE(c, e) :- SubSE(c, UnStmt(_, e)).
	SubSE(c, es) :- SubSE(c, FunStmt(_, es, _, _)), es: Exprs.
	SubSE(c, e) :- SubSE(c, FunStmt(_, _, e, _)), e: Name.
	SubSE(c, e) :- SubSE(c, Monitor(e, _)).
	SubSE(c, e) :- SubSE(c, Monitor(_, e)), e: Expr.
	SubSE(c, e1), SubSE(c, e2) :- SubSE(c, Send(e1, e2, _)).
	SubSE(c, e) :- SubSE(c, Send(_, _, e)), e: Expr.
	SubSE(c, e) :- SubSE(c, Raise(e, _)).
	SubSE(c, e) :- SubSE(c, Raise(_, e)), e: Expr.
	SubSE(c, e) :- SubSE(c, NewStmt(_, e)), e: Expr.
	SubSE(c, e) :- SubSE(c, New(_, e)), e: Expr.
	SubSE(c, es) :- SubSE(c, FunApp(_, es)), es: Exprs.
	SubSE(c, e) :- SubSE(c, UnApp(_, e)).
	SubSE(c, e1), SubSE(c, e2) :- SubSE(c, BinApp(_, e1, e2)).
	SubSE(c, e) :- SubSE(c, Field(e, _)).
	SubSE(c, e) :- SubSE(c, Cast(e, _)).
	SubSE(c, es) :- SubSE(c, Tuple(es)).
	SubSE(c, es) :- SubSE(c, NamedTuple(es)).
	SubSE(c, e) :- SubSE(c, Exprs(e, _)).
	SubSE(c, es) :- SubSE(c, Exprs(_, es)), es: Exprs.
    SubSE(c, e) :- SubSE(c, NamedExprs(_, e, _)).
	SubSE(c, es) :- SubSE(c, NamedExprs(_, _, es)), es: NamedExprs.

	//// True if in this context
	IsEventCnst ::= (cntxt: TypingContext, expr: Typeable, paytype: TypeExpr).

	/**************************************************************/
	/*			  Per module level typing error					*/
	/**************************************************************/
	Permissions ::= ModuleCreatesDecl + ModulePrivateDecl + ModuleSendsDecl + MachineImpsInterfaceDecl + MachineReceivesDecl.
	ModuleLevelTypingError ::= (p: Permissions).

	
	//sends and privates of the same module are disjoint
	[rule_Classes = '"error, msg: sends and private of the module are not disjoint"']
	ModuleLevelTypingError(s) :- s is ModuleSendsDecl(m, ev), ModulePrivateDecl(m, ev).

	//implemented interfaces in the same module are disjoint
	[rule_Classes = '"error, msg: implemented interface is not disjoint from other implemented interfaces in the module"']
	ModuleLevelTypingError(mi) :- mi is MachineImpsInterfaceDecl(id1, i1), MachineImpsInterfaceDecl(id2, i2), id1 != id2, id1.mod = id2.mod, InterfaceEventDecl(i1, ev), InterfaceEventDecl(i2, ev).
	
	//public events in receives of the same module are disjoint
	[rule_Classes = '"error, msg: public events in all the receives of a module must be disjoint"']
	ModuleLevelTypingError(mr) :- mr is MachineReceivesDecl(id1, ev), MachineReceivesDecl(id2, ev), id1 != id2, id1.mod = id2.mod, no ModulePrivateDecl(id1.mod, ev).

	//implemented interface of a machine contains only public events 
	[rule_Classes = '"error, msg: machine cannot implement an interface with private events"']
	ModuleLevelTypingError(mi) :- mi is MachineImpsInterfaceDecl(id, inter), InterfaceEventDecl(inter, ev), ModulePrivateDecl(id.mod, ev).

	//implemented interface = public events in the receives 
	[rule_Classes = '"error, msg: implemented interface must be same as the public events in receives of that machine"']
	ModuleLevelTypingError(mi) :- mi is MachineImpsInterfaceDecl(id, inter), count({ev | InterfaceEventDecl(inter, ev), no MachineReceivesDecl(id, ev)}) > 0;
								  mi is MachineImpsInterfaceDecl(id, inter), count({ev | no InterfaceEventDecl(inter, ev), MachineReceivesDecl(id, ev), no ModulePrivateDecl(id.mod, ev)}) > 0.

	//interfaces in creates are disjoint
	[rule_Classes = '"error, msg: interfaces in creates list are not disjoint"']
	ModuleLevelTypingError(c) :- c is ModuleCreatesDecl(m, i1), ModuleCreatesDecl(m, i2), InterfaceEventDecl(i1, ev), InterfaceEventDecl(i2, ev), i1 != i2.

	//a create interface is either disjoint or equal to the public events in receives
	//relation between creates interfaces and 
	NotDisjointOrEqual ::= (m: ModuleDecl, i:InterfaceType, mr: MachineReceivesDecl).
	NotDisjointOrEqual(m, i, mr) :- ModuleCreatesDecl(m, i), mach is MachineDecl(_, m, _, _, _, _), mr is MachineReceivesDecl(mach, _),
									count({ev1 | InterfaceEventDecl(i, ev1), no MachineReceivesDecl(mach, ev1), no ModulePrivateDecl(m, ev1), InterfaceEventDecl(i, ev2), MachineReceivesDecl(mach, ev2), no ModulePrivateDecl(m, ev2)}) > 0;
									ModuleCreatesDecl(m, i), mach is MachineDecl(_, m, _, _, _, _), mr is MachineReceivesDecl(mach, _),
									count({ev1 | no InterfaceEventDecl(i, ev1), MachineReceivesDecl(mach, ev1), no ModulePrivateDecl(m, ev1), InterfaceEventDecl(i, ev2), MachineReceivesDecl(mach, ev2), no ModulePrivateDecl(m, ev2)}) > 0.


	[rule_Classes = '"error, msg: interface type in creates is not equal to or disjoint from the public events in receives of the module"']
	ModuleLevelTypingError(c) :- mach is MachineDecl(_, m, _, _, _, _), mr is MachineReceivesDecl(mach, _), 
								  c is ModuleCreatesDecl(m, i), NotDisjointOrEqual(m, i, mr). 

	//no private event in the creates interfaces
	[rule_Classes = '"error, msg: interface in creates cannot have private events"']
	ModuleLevelTypingError(c) :- ModulePrivateDecl(m, ev), c is ModuleCreatesDecl(m, i), InterfaceEventDecl(i, ev).
	

	/***************************************************************/
	/***********    All the subterm operations ********************/
	/***************************************************************/
	//get modules in ModuleList 
	SubModule ::= sub (modL: ModuleList, mod: ModuleDecl).
	//get all the hidden modules
	SubHide ::= sub (mdl: ModuleList, h: Hide).
	//get all modulelists
	SubModList ::= sub(mod: ModuleList, mod': ModuleList).
	//get all events in EventList
	SubEvents ::= sub(evl: EventList, ev : String).
	//get all interfaces in InterfaceList
	SubInterface ::= sub (il: InterfaceList, i: InterfaceType).

	/**************** Illegal Main Machines ************************/
	IllegalMainMachine ::= (ml: ModuleList).
	[rule_Classes = '"error, msg: no Main Machine in the ModuleList"']
	IllegalMainMachine(ml) :- NoFailureTestDecl(_, ml), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), SubModule(ml, mod)}) = 0;
							  MonitorsTestDecl(_, ml, _), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), SubModule(ml, mod)}) = 0;
							  RefinesTestDecl(_, ml, _), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), SubModule(ml, mod)}) = 0;
							  RefinesTestDecl(_, _, ml), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), SubModule(ml, mod)}) = 0.

	[rule_Classes = '"error, msg: more than one Main Machine in the ModuleList"']
	IllegalMainMachine(ml) :- NoFailureTestDecl(_, ml), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), SubModule(ml, mod)}) > 1;
							  MonitorsTestDecl(_, ml, _), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), SubModule(ml, mod)}) > 1;
							  RefinesTestDecl(_, ml, _), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), SubModule(ml, mod)}) > 1;
							  RefinesTestDecl(_, _, ml), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), SubModule(ml, mod)}) > 1.

	/**************************************************************/
	/******* Get all high level module compositions ****************/
	/**************************************************************/
	//get all the high level modules list 
	//ImplementationModules + SpecificationModules + RefinesTestDecl + MonitorsTestDecl + NoFailureTestDecl.
	ComposedModules ::= (m: ModuleList).
	ComposedModules(mL) :- NoFailureTestDecl(_, mL);
						   MonitorsTestDecl(_, mL, _);
						   RefinesTestDecl(_, mL, _); RefinesTestDecl(_, _, mL);
						   SpecificationModules(mL);
						   ImplementationModules(mL).

	/*************************************************************/
	/*				Map from interface to machine				 */
	/*************************************************************/
	InterfaceToMachineMap ::= (ml: ModuleList, ie: InterfaceType, mach: MachineDecl).
	ImpInterfaceToMachineMap ::= (ie: InterfaceType, mach: MachineDecl).

	//compute the interface map
	InterfaceToMachineMap(ml, i, mach) :-  ComposedModules(ml), SubModule(ml, m1), SubModule(ml, m2), CreatesForModule(m1, i), ReceivesForModule(m2, rd), InterfaceEventDecl(i, rd.ev), mach = rd.mach.

	//map for implementation modules
	ImpInterfaceToMachineMap(i, mc) :- ImplementationModules(ml), InterfaceToMachineMap(ml, i, mc).

	/************************************************************/
	/*			Compute the hidden events per module			*/
	/************************************************************/
	HiddenEvents ::= (mdl: ModuleList, md: ModuleDecl, evl : EventList + {NIL}).
	HiddenEvents(ml, mod, evl) :- ComposedModules(ml), SubHide(ml, h), h = Hide(evl, hml), evl : EventList, SubModule(hml, mod);
							      ComposedModules(ml), SubHide(ml, h), h = Hide(inl, hml), inl : InterfaceList, SubModule(hml, mod), evl = toList(#EventList, NIL, {ev | SubInterface(inl, i), InterfaceEventDecl(i, ev)}).
	
	//compute events hidden in an hide operation
	HiddenEventsInOp ::= (h: Hide, ev: String).
	HiddenEventsInOp (h, ev) :- ComposedModules(ml), SubHide(ml, h), h = Hide(evl, hml), evl : EventList, SubEvents(evl, ev);
								ComposedModules(ml), SubHide(ml, h), h = Hide(inl, hml), inl : InterfaceList, SubModule(hml, mod), evl = toList(#EventList, NIL, {ev | SubInterface(inl, i), InterfaceEventDecl(i, ev)}), SubEvents(evl, ev).

	/***************************************************************/
	/*	Generate sends, private and creates for ModuleList		   */
	/***************************************************************/
	
	AllModList ::= (modL: ModuleList).
	SendsForModuleList ::= (ml: ModuleList, ev: String).
	PrivateForModuleList ::= (ml: ModuleList, ev: String).
	CreatesForModuleList ::= (ml: ModuleList, inter: InterfaceType).
	ReceivesForModuleList ::= (ml: ModuleList, rd: MachineReceivesDecl).
	ImplementsForModuleList ::= (ml: ModuleList, id: MachineImpsInterfaceDecl).

	//all the following modulelists must be legally composed.
	AllModList(ml) :- ComposedModules(cml), SubModList(cml, ml).

	//get the sends list after removing hidden events and interfaces
	SendsForModuleList(ml, ev) :-  AllModList(ml), ml = ModuleList(m1, _), SendsForModule(m1, ev);
								   AllModList(ml), ml = ModuleList(_, m2), SendsForModuleList(m2, ev), m2 != NIL.

	//get the receives list for the ModuleList, its a simple union of all the receives
	ReceivesForModuleList(ml, rd) :- AllModList(ml), SubModule(ml, mod), rd is MachineReceivesDecl(mach, _), mach.mod = mod.

	//get the private list for the moduleList adding the hidden events and interfaces
	PrivateForModuleList(ml, ev) :- AllModList(ml), ml = ModuleList(m, _), PrivateForModule(m, ev);						
									AllModList(ml), ml = ModuleList(_, m2), PrivateForModuleList(m2, ev), m2 != NIL.
	
	//get the implements list for the ModuleList, its a simple union of all the implements
	ImplementsForModuleList(ml, id) :- AllModList(ml), SubModule(ml, mod), id is MachineImpsInterfaceDecl(mach, _), mach.mod = mod.

	//get the creates list for the ModuleList, remove interfaces that have private events in them
	CreatesForModuleList(ml, i) :- AllModList(ml), ml = ModuleList(m, _), CreatesForModule(m, i);						
								   AllModList(ml), ml = ModuleList(_, m2), CreatesForModuleList(m2, i), m2 != NIL.
	
	//Generate interface for the all modules
	GenInterfaceForHideMod ::= (h : Hide).
	GenInterfaceForHideMod(hm) :- ComposedModules(cml), SubHide(cml, hm).

	SendsForModule ::= (mod: Module, ev: String).
	PrivateForModule ::= (mod: Module, ev: String).
	CreatesForModule ::= (mod: Module, inter: InterfaceType).
	ReceivesForModule ::= (mod: Module, rd: MachineReceivesDecl).
	ImplementsForModule ::= (mod: Module, id: MachineImpsInterfaceDecl).

	//get the sends list for the hide module
	SendsForModule(hm, ev) :- GenInterfaceForHideMod(hm), SendsForModuleList(hm.modL, ev);
							  ModuleSendsDecl(hm, ev).

	//get the receives list for the hide module
	ReceivesForModule(hm, rd) :- GenInterfaceForHideMod(hm), ReceivesForModuleList(hm.modL, rd);
								 rd is MachineReceivesDecl(mach, _), mach is MachineDecl(_, hm, _, _, _, _), hm is ModuleDecl.

	//get the private list for the hide module
	PrivateForModule(hm, ev) :-  GenInterfaceForHideMod(hm), PrivateForModuleList(hm.modL, ev);
							     GenInterfaceForHideMod(hm), hm = Hide(eL, _), eL : EventList, SubEvents(eL, ev);
								 GenInterfaceForHideMod(hm), hm = Hide(iL, _), iL : InterfaceList, SubInterface(iL, i), InterfaceEventDecl(i, ev);
								 ModulePrivateDecl(hm, ev).

	//get the implements list for the hide module
	ImplementsForModule(hm, id) :- GenInterfaceForHideMod(hm), ImplementsForModuleList(hm.modL, id);
								   id is MachineImpsInterfaceDecl(mach, _), mach is MachineDecl(_, hm, _, _, _, _), hm is ModuleDecl.

	//get the creates list for the hide module
	CreatesForModule(hm, i) :-  GenInterfaceForHideMod(hm), hm = Hide(eL, modL), eL : EventList, CreatesForModuleList(modL, i);
								GenInterfaceForHideMod(hm), hm = Hide(iL, modL), iL : InterfaceList, SubInterface(iL, i), CreatesForModuleList(modL, i), count({ev | InterfaceEventDecl(i, ev), PrivateForModule(hm, ev)}) = 0;
								ModuleCreatesDecl(hm, i).
	/**************************************************************/
	/*                      Legal Composition                   */
	/*************************************************************/
	//generate legal compositions just so that you can generate better error messages
	//currently the error messages are generated transitively all the way to the root modulelist.

	/**************************************************************/
	/*                      Illegal Composition                   */
	/*************************************************************/
	//Get all modulelist compositions
	ComposeModWithModList ::= (ml: ModuleList, m1: Module, m2:ModuleList).
	ComposeModWithModList(ml, m1, m2) :- AllModList(ml), ml = ModuleList(m1, m2), m2 : ModuleList. // add m2 is a legal compositions
	
	IllegalComposition ::= (modL: ModuleList).

	//sends and privates in the modulelist are disjoint
	[rule_Classes = '"error, msg: sends and private are not disjoint after composition"']
	IllegalComposition(ml) :- ComposeModWithModList(ml, m1, m2), SendsForModule(m1, ev), PrivateForModuleList(m2, ev), no PrivateForModule(m1, ev);
							  ComposeModWithModList(ml, m1, m2), SendsForModuleList(m2, ev), PrivateForModule(m1, ev), no PrivateForModuleList(m2, ev).

	//implemented interfaces must be disjoint
	[rule_Classes = '"error, msg: implemented interfaces are not disjoint after composition"']
	IllegalComposition(ml) :- ComposeModWithModList(ml, m1, m2), ImplementsForModule(m1, mid1), ImplementsForModuleList(m2, mid2), InterfaceEventDecl(mid1.inter, ev), InterfaceEventDecl(mid2.inter, ev).


	//public events in the receives must be disjoint
	[rule_Classes = '"error, msg: public events in receives are not disjoint after composition"']
	IllegalComposition(ml) :- ComposeModWithModList(ml, m1, m2), ReceivesForModule(m1, rd1), ReceivesForModuleList(m2, rd2), rd1.ev = rd2.ev, ml = ModuleList(m1, m2), no PrivateForModuleList(ml, ev), rd1.ev = ev.

	
	//implemented interfaces of a machine contains no private event
	[rule_Classes = '"error, msg: implemented interface has private events after composition"']
	IllegalComposition(ml) :- ComposeModWithModList(ml, m1, m2), ImplementsForModule(m1, mid), PrivateForModuleList(m2, ev), InterfaceEventDecl(mid.inter, ev);
							  ComposeModWithModList(ml, m1, m2), ImplementsForModuleList(m2, mid), PrivateForModule(m1, ev), InterfaceEventDecl(mid.inter, ev).

	//implemented interface = public events in the receives 
	[rule_Classes = '"error, msg: implemented interface is not same as the public events in receives after composition"']
	IllegalComposition(ml) :- ComposeModWithModList(ml, m1, m2), ImplementsForModuleList(ml, mid), 
							  count({ev | InterfaceEventDecl(mid.inter, ev), no ReceivesForModuleList(ml, rd), rd.ev = ev, rd.mach = mid.mach}) > 0;
							  ComposeModWithModList(ml, m1, m2), ImplementsForModuleList(ml, mid), 
							  count({ev | no InterfaceEventDecl(mid.inter, ev), ReceivesForModuleList(id, rd), no PrivateForModuleList(ml, ev), rd.mach = mid.mach, rd.ev = ev}) > 0.

	//interfaces in creates are disjoint
	[rule_Classes = '"error, msg: interfaces in creates list are not disjoint after composition"']
	IllegalComposition(ml) :- ComposeModWithModList(ml, m1, m2), CreatesForModule(m1, i1), CreatesForModuleList(m2, i2), InterfaceEventDecl(i1, ev), InterfaceEventDecl(i2, ev).

	//a create interface is either disjoint or equal to the public events in receives
	[rule_Classes = '"error, msg: interface type in creates is not equal to or disjoint from the public events in receives after composition"']
	IllegalComposition(ml) :- 
	ComposeModWithModList(ml, m1, m2), CreatesForModuleList(ml, i), 
	count({ev1 | InterfaceEventDecl(i, ev1), no ReceivesForModuleList(ml, ed1), no PrivateForModuleList(ml, ev1), rd1.ev = ev1, InterfaceEventDecl(i, ev2), ReceivesForModuleList(ml, rd2), no PrivateForModuleList(ml, ev2),rd2.ev = ev2, rd1.mach = rd2.mach}) > 0;
	ComposeModWithModList(ml, m1, m2), CreatesForModuleList(ml, i), 
	count({ev1 | no InterfaceEventDecl(i, ev1), ReceivesForModuleList(ml, rd1), rd1.ev = ev1, no PrivateForModuleList(ml, ev1), InterfaceEventDecl(i, ev2), ReceivesForModuleList(ml, rd2), rd2.ev = ev2, no PrivateForModuleList(ml, ev2), rd1.mach = rd2.mach}) > 0.

	//no private event in the creates interfaces
	[rule_Classes = '"error, msg: interface in creates has private event after composition"']
	IllegalComposition(ml) :- ComposeModWithModList(ml, m1, m2), PrivateForModuleList(ml, ev), CreatesForModuleList(ml, i), InterfaceEventDecl(i, ev).
	
	//no duplicates in the sends list
	[rule_Classes = '"error, msg: multiple modules have the same event in the sends list after composition"']
	IllegalComposition(ml) :- ComposeModWithModList(ml, m1, m2), SendsForModule(m1, ev), SendsForModuleList(m2, ev), no PrivateForModuleList(ml, ev).

	/*************************************************************/
	/*					Illegal Hide Operation					*/
	/*************************************************************/
	IllegalHideOperation::= (hideOp: Hide).
	
	/*
	Hide E in P is legal only if :
	1) E is not a private event of P. 
	2) E is not present in any of the creates interfaces of P.
	3) E is in the receives list of one of the implemented machines of P.
	*/

	[rule_Classes = '"error, msg: hide operation cannot be performed on private event"']
	IllegalHideOperation(h) :- ComposedModules(ml), SubHide(ml, h), h = Hide(evl, hml), SubEvents(evl, ev), PrivateForModuleList(hml, ev).

	[rule_Classes = '"error, msg: hide operation cannot be performed on an event present in the creates interface"']
	IllegalHideOperation(h) :- ComposedModules(ml), SubHide(ml, h), h = Hide(evl, hml), SubEvents(evl, ev), CreatesForModuleList(hml, i), InterfaceEventDecl(i, ev).
	
	[rule_Classes = '"error, msg: hide operation can be performed on an event present in receives of an implemented machine"']
	IllegalHideOperation(h) :- ComposedModules(ml), SubHide(ml, h), h = Hide(evl, hml), SubEvents(evl, ev), no ReceivesForModuleList(hml, rd), rd is MachineReceivesDecl(_, ev).

	/*
	Hide I in P is legal only if:
	1) I has no private events of P.
	2) I is equals to implements of one of the machines in P. Implements is the set of public events in the receives set of the machine.
	*/
	[rule_Classes = '"error, msg: hide operation cannot be performed on an interface with private event"']
	IllegalHideOperation(h) :- ComposedModules(ml), SubHide(ml, h), h = Hide(inl, hml), SubInterface(inl, i), PrivateForModuleList(hml, ev), InterfaceEventDecl(i, ev).

	[rule_Classes = '"error, msg: hide operation can be performed on an interface that contains all public events of one of the receives"']
	IllegalHideOperation(h) :- ComposedModules(ml), SubHide(ml, h), h = Hide(inl, hml), SubInterface(inl, i), 
							   no ReceivesForModuleList(hml, rd), rd is MachineReceivesDecl, count({ev | InterfaceEventDecl(i, ev), MachineReceivesDecl(rd.mach, ev)}) > 0;
							   ComposedModules(ml), SubHide(ml, h), h = Hide(inl, hml), SubInterface(inl, i), 
							   ReceivesForModuleList(hml, rd), count({ev1 | InterfaceEventDecl(i, ev1), MachineReceivesDecl(rd.mach, ev1), InterfaceEventDecl(i, ev2), no MachineReceivesDecl(rd.mach, ev2)}) > 0;
							   ComposedModules(ml), SubHide(ml, h), h = Hide(inl, hml), SubInterface(inl, i), 
							   ReceivesForModuleList(hml, rd), count({ev1 | InterfaceEventDecl(i, ev1), MachineReceivesDecl(rd.mach, ev1), no InterfaceEventDecl(i, ev2), MachineReceivesDecl(rd.mach, ev2)}) > 0.


	/**************************************************************/
	/*			Type checking rules for refinement checking		 */
	/*************************************************************/
	IllegalRefinesTestCase ::= (ml: ModuleList).

	//TODO: Add type checking rules for the refinement checking relations
	/**************************************************************/
	/*			Type checking rules for monitor testing			 */
	/*************************************************************/
	
	IllegalMonitorTestCase ::= (mon: MonitorList + PrivateMonitor).
	//get all private monitors
	SubPrivateMonitors ::= sub(monL: MonitorList, pm: PrivateMonitor).
	//get all global monitor
	SubMonitors ::= sub(monL: MonitorList, ml: MonitorList).

	//Global monitors can only observe public events
	[rule_Classes = '"error, msg: global monitor can only observe public events"']
	IllegalMonitorTestCase(monl) :- tc is MonitorsTestDecl, SubMonitors(tc.monitors, monl), monl = MonitorList(s, _), s : String, m is MachineDecl(s, _, MONITOR, _, _, _), ObservesDecl(m, ev), PrivateForModuleList(tc.imp, ev).

	//Private monitors can only observe private events of only one module
	[rule_Classes = '"error, msg: private monitor can only observe private event of one module"']
	IllegalMonitorTestCase(monl) :- tc is MonitorsTestDecl, SubPrivateMonitors(tc.monitors, monl), monl = PrivateMonitor(s, mod), s : String, m is MachineDecl(s, _, MONITOR, _, _, _), ObservesDecl(m, ev), no ModulePrivateDecl(mod, ev), PrivateForModuleList(tc.imp, ev).

	/**************************************************************/
	/*						Sound Composition		 			 */
	/*************************************************************/
	SoundCompositionWarning ::= (ml: ModuleList).

	//generate a warning that implementations is not closed.
	[rule_Classes = '"warning, msg: implementation list is not closed with respect to creates interfaces"']
	SoundCompositionWarning(ml) :- ImplementationModules(ml), CreatesForModuleList(ml, i), no ReceivesForModuleList(ml, rd), rd is MachineReceivesDecl, InterfaceEventDecl(i, ev), rd.ev = ev.

	//TODO add other warnings for other modulelists


    /*************************************************************/
    /*                      Types of Expressions                 */
    /*************************************************************/
    
    //// (1) The types of nullary expressions
    TypeOf(c, e, BaseType(NULL))  :- SubSE(c, e), e = NulApp(NULL).
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = NulApp(TRIGGER).
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = NulApp(HALT).
	
	TypeOf(c, e, t) :- SubSE(c, e), e = NulApp(PAYLOAD), PayloadType(c, t).
	
	//Recent change: THIS is not allowed in static functions
	// Type of THIS is the interface type implemented by the machine.
	// If no interface type is implemented then the type of THIS is machine.
    TypeOf(c, e, i)  :- SubSE(c, e), e = NulApp(THIS), i = InterfaceType(c.owner.name), c.owner != NIL.
	TypeOf(c, e, BaseType(REAL))  :- SubSE(c, e), e = NulApp(THIS), no MachineImpsInterfaceDecl(c.owner, _), c.owner != NIL.

    [ rule_Classes = '"error, msg: (this) is not allowed inside static functions"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = NulApp(THIS), c.owner = NIL.

	TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(NONDET).

    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(FAIRNONDET).
	    
    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = NulApp(v), v : Integer.
    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(v), v : Boolean.          
    
    //// (2) The types of unary expressions
    TypeOf(c, e, t)               :- SubSE(c, e), e = Default(t). 
	    
    TypeOf(c, e, t1)              :- TypeOfArg1(c, e, t1), e : Tuple.     

    TypeOf(c, e, t1)              :- TypeOfArg1(c, e, t1), e : NamedTuple.

	// Names can hide other names in the following order: local variable hides machine variable hides event
	TypeOf(c, e, t)	              :- SubSE(c, e), e = Name(n), TypeOfLocalVar(c, n, t).
    TypeOf(c, e, t)               :- SubSE(c, e), e = Name(n), VarDecl(n, c.owner, t), no TypeOfLocalVar(c, n, _). 
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = Name(n), EventDecl(n, _, _), no VarDecl(n, c.owner, _), no TypeOfLocalVar(c, n, _). 

    IsEventCnst(c, e, BaseType(NULL)) :- SubSE(c, e), e = Name(n), EventDecl(n, _, NIL), no VarDecl(n, c.owner, _), no TypeOfLocalVar(c, n, _). 
    IsEventCnst(c, e, pt)             :- SubSE(c, e), e = Name(n), EventDecl(n, _, pt), pt : TypeExpr, no VarDecl(n, c.owner, _), no TypeOfLocalVar(c, n, _). 

	[ rule_Classes = '"error, msg: Undefined symbol"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = Name(n), no EventDecl(n, _, _), no VarDecl(n, c.owner, _), no TypeOfLocalVar(c, n, _). 
    
    TypeOf(c, e, BaseType(BOOL))  :- TypeOfArg1(c, e, t1), e = UnApp(NOT, _), t1 = BaseType(BOOL). 
	[ rule_Classes = '"error, msg: Operator expected a boolean value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(NOT, _), t1 != BaseType(BOOL). 
    
    TypeOf(c, e, BaseType(INT))   :- TypeOfArg1(c, e, t1), e = UnApp(NEG, _), t1 = BaseType(INT). 
	[ rule_Classes = '"error, msg: Operator expected an integer value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(NEG, _), t1 != BaseType(INT). 
    
    TypeOf(c, e, SeqType(dom))    :- TypeOfArg1(c, e, t1), e = UnApp(KEYS, _), t1 = MapType(dom, _). 
	[ rule_Classes = '"error, msg: Operator expected a map value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(KEYS, _), toSymbol(t1) != #MapType. 

    TypeOf(c, e, SeqType(cod))    :- TypeOfArg1(c, e, t1), e = UnApp(VALUES, _), t1 = MapType(_, cod). 
	[ rule_Classes = '"error, msg: Operator expected a map value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(VALUES, _), toSymbol(t1) != #MapType. 

    TypeOf(c, e, BaseType(INT))   :- TypeOfArg1(c, e, t1), e = UnApp(SIZEOF, _), t1 : MapType. 
    TypeOf(c, e, BaseType(INT))   :- TypeOfArg1(c, e, t1), e = UnApp(SIZEOF, _), t1 : SeqType. 
	[ rule_Classes = '"error, msg: Operator expected a map or sequence value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(SIZEOF, _), toSymbol(t1) != #MapType, toSymbol(t1) != #SeqType. 
    
    //// (3) The types of binary expressions
    TypeOf(c, e, t2)               :- TypeOfArg1(c, e, t1), e = Cast(_, t2), TypeRel(t1, t2, k), k != EMPTY.
	[ rule_Classes = '"error, msg: Cast can never succeed"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = Cast(_, t2), TypeRel(t1, t2, k), k = EMPTY.

    TypeOf(c, e, t)   :- SubSE(c, e), e = New(n, _), ModuleCreatesDecl(c.owner.mod, t), t = InterfaceType(n).

	[ rule_Classes = '"error, msg: Monitors cannot be created with "new""']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = New(n, _), MachineDecl(n, _, MONITOR, _, _, _).

	[ rule_Classes = '"error, msg: created interface is not in the creates list of the module"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = New(n, _), no ModuleCreatesDecl(c.owner.mod, InterfaceType(n)).
	
    TypeOf(c, e, t2)               :- TypeOfArg2(c, e, _, t2), e : Field, t2 != ERROR.
	[ rule_Classes = '"error, msg: Bad field name"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, _, t2), e : Field, t2 = ERROR.
	[ rule_Classes = '"error, msg: Operator expected a (named) tuple value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Field, toSymbol(t1) != #TupType, toSymbol(t1) != #NmdTupType.
    
    PureIntOp ::= { ADD, SUB, MUL, INTDIV }.
    TypeOf(c, e, bint)             :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PureIntOp, t1 = bint, t2 = bint, bint = BaseType(INT).
	[ rule_Classes = '"error, msg: Operator expected first argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinApp(op, _, _), op : PureIntOp, t1 != BaseType(INT).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e2), op : PureIntOp, TypeOf(c, e2, t2), t2 != BaseType(INT).     
    
    PureIntRel ::= { LT, LE, GT, GE }.
    TypeOf(c, e, BaseType(BOOL))   :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, e', e''), op : PureIntRel, t1 = bint, t2 = bint, bint = BaseType(INT).
	[ rule_Classes = '"error, msg: Operator expected first argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinApp(op, _, _), op : PureIntRel, t1 != BaseType(INT).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e2), TypeOf(c, e2, t2), op : PureIntRel, t2 != BaseType(INT).    
    
    PureBoolOp ::= { AND, OR }.
    TypeOf(c, e, BaseType(BOOL))   :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PureBoolOp, t1 = bbool, t2 = bbool, bbool = BaseType(BOOL).
	[ rule_Classes = '"error, msg: Operator expected first argument to be a boolean value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinApp(op, _, _), op : PureBoolOp, t1 != BaseType(BOOL).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e2), TypeOf(c, e2, t2), op : PureBoolOp, t2 != BaseType(BOOL).    
    
    PolyRel ::= { EQ, NEQ }.
    TypeOf(c, e, BaseType(BOOL))   :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PolyRel, TypeRel(t1, t2, k), k != EMPTY.
	[ rule_Classes = '"error, msg: Values cannot be compared because their types are incompatible"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PolyRel, TypeRel(t1, t2, k), k = EMPTY.
	[ rule_Classes = '"error, msg: Values of type machine or interface cannot be compared"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PolyRel, TypeRel(t1, BaseType(REAL), SUB), t1 != BaseType(NULL);
									  TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PolyRel, TypeRel(t2, BaseType(REAL), SUB), t2 != BaseType(NULL).
    
    TypeOf(c, e, inner)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 = SeqType(inner), t2 = BaseType(INT).
    TypeOf(c, e, cod)              :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 = MapType(dom, cod), TypeRel(t2, dom, SUB).
	[ rule_Classes = '"error, msg: Indexer must be applied to a sequence or map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinApp(IDX, _, _), toSymbol(t1) != #SeqType, toSymbol(t1) != #MapType.
	[ rule_Classes = '"error, msg: Index must be an integer"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 : SeqType, t2 != BaseType(INT).
	[ rule_Classes = '"error, msg: Index may not be in the domain of the map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 = MapType(dom, _), TypeRel(t2, dom, k), t2 != dom, k != SUB.
    
    TypeOf(c, e, BaseType(BOOL))   :- TypeOfArg2(c, e, t1, t2), e = BinApp(IN, _, _), t2 = SeqType(inner), TypeRel(t1, inner, k), k != EMPTY.
    TypeOf(c, e, BaseType(BOOL))   :- TypeOfArg2(c, e, t1, t2), e = BinApp(IN, _, _), t2 = MapType(dom, _), TypeRel(t1, dom, k), k != EMPTY.        
	[ rule_Classes = '"error, msg: Value can never be in the sequence"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(IN, _, _), t2 = SeqType(inner), TypeRel(t1, inner, EMPTY).
	[ rule_Classes = '"error, msg: Value can never be in the map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(IN, _, _),  t2 = MapType(dom, _), TypeRel(t1, dom, EMPTY).        
	[ rule_Classes = '"error, msg: "in" expects a map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IN, _, e2),  TypeOf(c, e2, t2), toSymbol(t2) != #MapType.
    
	///// (4) Exprs produces a tuple type
	TypeOf(c, e, t) :- TypeOfArg1(c, e, t1), e = Exprs(_, NIL), t = TupType(t1, NIL).
	TypeOf(c, e, t) :- TypeOfArg2(c, e, t1, t2), e : Exprs, t2 : TupType, t = TupType(t1, t2).
		
	//// (5) NamedExprs produces a named tuple type.
	TypeOf(c, e, t) :- TypeOfArg1(c, e, t1), e = NamedExprs(n, _, NIL), t = NmdTupType(NmdTupTypeField(n, t1), NIL).
	TypeOf(c, e, t) :- TypeOfArg2(c, e, t1, t2), e = NamedExprs(n, _, _), t2 : NmdTupType, t = NmdTupType(NmdTupTypeField(n, t1), t2).
	
	//// (6) FunApps must refer to a defined function that has a non-NIL return type and args must be sub-types of function signature. 
	TypeOf(c, e, t) :- SubSE(c, e), e = FunApp(n, NIL), decl = FunDecl(n, _, _, NIL, t, _, _), t != NIL, FunAvailable(decl, c.owner).
	TypeOf(c, e, t) :- TypeOfArg1(c, e, t1), e = FunApp(n, _), FuncSigTupleType(decl, inpt), decl.name = n, decl.return = t, FunAvailable(decl, c.owner), TypeRel(t1, inpt, SUB), t != NIL.

	[ rule_Classes = '"error, msg: function not defined"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, _), no FunDecl(n, c.owner, _, _, _, _, _), no FunDecl(n, NIL, _, _, _, _, _).
	[ rule_Classes = '"error, msg: function does not return a value"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, _), FunDecl(n, c.owner, _, _, NIL, _, _);
	                       SubSE(c, e), e = FunApp(n, _), FunDecl(n, NIL, _, _, NIL, _, _).
	[ rule_Classes = '"error, msg: function requires arguments"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, NIL), FunDecl(n, c.owner, _, params, _, _, _), params != NIL;
	                       SubSE(c, e), e = FunApp(n, NIL), FunDecl(n, NIL, _, params, _, _, _), params != NIL.
	[ rule_Classes = '"error, msg: function arguments have incorrect types"']
	TypeOf(c, e, ERROR) :- TypeOfArg1(c, e, t1), e = FunApp(n, _), FuncSigTupleType(decl, inpt), decl.name = n, FunAvailable(decl, c.owner), TypeRel(t1, inpt, k), t1 != inpt, k != SUB.
	
    /*************************************************************/
    /*                      Types of Statements                  */
    /*************************************************************/

	//// (1) Nullary statements
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NulStmt(SKIP).
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NulStmt(POP).

	//// (2) Return statement
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(NIL), c = FunDecl(_, _, _, _, NIL, _, _). 
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(NIL), c : AnonFunDecl.
    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e : Return, c = FunDecl(_, _, _, _, t, _, _), TypeRel(t1, t, SUB).
	[ rule_Classes = '"error, msg: function must return a value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(NIL), c = FunDecl(_, _, _, _, t, _, _), t != NIL. 
	[ rule_Classes = '"error, msg: return value has incorrect type"' ]
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Return, c = FunDecl(_, _, _, _, t, _, _), TypeRel(t1, t, k), t1 != t, k != SUB.
	[ rule_Classes = '"error, msg: anonymous function cannot return a value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(e1), c : AnonFunDecl, e1 != NIL. 

	//// (3) Non-mutating statements
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Seq(_, _).
    
    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e = UnStmt(ASSERT, _), t1 = BaseType(BOOL).
	[ rule_Classes = '"error, msg: "assert" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = UnStmt(ASSERT, _), t1 != BaseType(BOOL).
    
    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e : Ite, t1 = BaseType(BOOL).
	[ rule_Classes                                   = '"error, msg: "if (...)" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Ite, t1 != BaseType(BOOL).
    
    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e : While, t1 = BaseType(BOOL).
	[ rule_Classes = '"error, msg: "while (...)" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : While, t1 != BaseType(BOOL).
               
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NewStmt(n, _), ModuleCreatesDecl(c.owner.mod, t), t = InterfaceType(n).
	
	[ rule_Classes = '"error, msg: interface is not in the creates set of the module"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = NewStmt(n, _), no ModuleCreatesDecl(c.owner.mod, InterfaceType(n)).

	[ rule_Classes = '"error, msg: monitor cannot be created dynamically using new"']
	TypeOf(c, e, ERROR)              :- SubSE(c, e), e = NewStmt(n, _), MachineDecl(n, _, MONITOR, _, _, _).


	//// Rules for raise.
    TypeOf(c, e, NIL)              :- CommStmtPLType(c, e, plt), e = Raise(_, NIL),              ///// < raise has NIL payload,
	                                  TypeRel(BaseType(NULL), plt, SUB).                          ///// < event type contains null.

    TypeOf(c, e, NIL)              :- CommStmtPLType(c, e, plt), e = Raise(_, p), p != NIL,      ///// < raise has non-NIL payload,             
	                                  TypeOf(c, p, pt), TypeRel(pt, plt, SUB).                    ///// < and pt is a subtype of evt.

	//// Error rules for raise.
	[ rule_Classes = '"error, msg: argument 1 of "raise" expects an event value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Raise, t1 != BaseType(EVENT).
	
    [ rule_Classes = '"error, msg: invalid payload type in raise (cannot send null value)"']
    TypeOf(c, e, ERROR)            :- CommStmtPLType(c, e, plt), e = Raise(_, NIL), null = BaseType(NULL),  ///// < raise has NIL payload,
									  TypeRel(null, plt, k), k != SUB, null != plt.                         ///// < and null not in event type.

    [ rule_Classes = '"error, msg: invalid payload type in raise"']
    TypeOf(c, e, ERROR)            :- CommStmtPLType(c, e, plt), e = Raise(_, p), p != NIL,       ///// < p has non-NIL payload,             
									  TypeOf(c, p, pt), TypeRel(pt, plt, k), k != SUB, pt != plt. ///// < and pt is not a subtype of plt.

	//// Rules for send.
    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e = Send(_, _, NIL),                           ///// < send has NIL payload,
	                                  TypeRel(t1, BaseType(REAL), SUB), t1 != BaseType(NULL),              ///// < arg1 is a interface or machine type,
	                                  CommStmtPLType(c, e, plt), TypeRel(BaseType(NULL), plt, SUB).        ///// < arg2 event type contains null.

    TypeOf(c, e, NIL)              :- TypeOfArg3(c, e, t1, t2, t3), e : Send,                             ///// < send has non-NIL payload,             
	                                  TypeRel(t1, BaseType(REAL), SUB), t1 != BaseType(NULL),             ///// < arg1 is a interface type,
	                                  CommStmtPLType(c, e, plt), TypeRel(t3, evt, SUB).                   ///// < and t3 is a subtype of plt.

	//// Error rules for send.
	[ rule_Classes = '"error, msg: argument 1 of "send" expects an interface value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Send, toSymbol(t1) != #InterfaceType, t1 != BaseType(REAL).
	
	[ rule_Classes = '"error, msg: argument 2 of "send" expects an event value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(_, e2, _), TypeOf(c, e2, t2), t2 != BaseType(EVENT).

	//// Error rules for send with constant event expression. 	
    [ rule_Classes = '"error, msg: invalid payload type in send (cannot send null value)"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(_, _, NIL), null = BaseType(NULL),   ///// < send has NIL payload,
	                                  CommStmtPLType(c, e, plt),                                  ///// < constant event expression
									  TypeRel(null, plt, k), k != SUB, null != plt.               ///// < and null not in event type.

    [ rule_Classes = '"error, msg: invalid payload type in send"']
    TypeOf(c, e, ERROR)            :- TypeOfArg3(c, e, t1, t2, t3), e : Send,                     ///// < p has non-NIL payload,             
	                                  CommStmtPLType(c, e, plt),                                  ///// < constant event expression
									  TypeRel(t3, plt, k), k != SUB, t3 != plt.                   ///// < and pt is not a subtype of plt.
	

	//// Rules for monitor.
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Monitor(_, NIL),                           ///// < monitor has NIL payload,
	                                  CommStmtPLType(c, e, plt), TypeRel(BaseType(NULL), plt, SUB).  ///// < event type contains null.

    TypeOf(c, e, NIL)              :- TypeOfArg2(c, e, t1, t2), e = Monitor(_, _),                          ///// < monitor has non-NIL payload,
	                                  CommStmtPLType(c, e, plt), TypeRel(t2, plt, SUB).                        ///// < and pt is a subtype of plt.

	//// Error rules for monitor.

	[ rule_Classes = '"error, msg: argument 1 of "monitor" expects an event value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Monitor, t1 != BaseType(EVENT).

	//// Error rules for monitor. 	
    [ rule_Classes = '"error, msg: invalid payload type in monitor (cannot send null value)"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Monitor(_, NIL), null = BaseType(NULL), ///// < monitor has NIL payload,
	                                  CommStmtPLType(c, e, plt),                                  ///// < constant event expression
									  TypeRel(null, plt, k), k != SUB, null != plt.               ///// < and null not in event type.

    [ rule_Classes = '"error, msg: invalid payload type in monitor"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e : Monitor,    ///// < p has non-NIL payload,             
	                                  CommStmtPLType(c, e, plt),                ///// < constant event expression
									  TypeRel(t2, plt, k), k != SUB, t2 != plt. ///// < and pt is not a subtype of evt.

	[ rule_Classes = '"error, msg: monitor can be invoked only on a private event"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Monitor(ev, _), ev = Name(n),
									  no ModulePrivateDecl(c.owner.mod, n).            
	                                  

	//// (4) Mutating statements		
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(ASSIGN, _, _), TypeRel(t2, t1, SUB).
	[ rule_Classes = '"error, msg: invalid assignment. right hand side is not a subtype of left hand side"']
	TypeOf(c, e , ERROR)		   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(ASSIGN, _, _), TypeRel(t2, t1, k), k!= SUB, t1 != t2.
		
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _), t1 : SeqType, t2 = BaseType(INT).
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _), t1 = MapType(dom, cod), TypeRel(t2, dom, SUB).	
	[ rule_Classes = '"error, msg: remove must be applied to a sequence or map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinStmt(REMOVE, _, _), toSymbol(t1) != #SeqType, toSymbol(t1) != #MapType.
    [ rule_Classes = '"error, msg: index must be an integer"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _), t1 : SeqType, t2 != BaseType(INT).
	[ rule_Classes = '"error, msg: Index may not be in the domain of the map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _), t1 = MapType(dom, _), TypeRel(t2, dom, k), t2 != dom, k != SUB.
		
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _), t1 = SeqType(inner), t2 = TupType(BaseType(INT), TupType(value, NIL)), TypeRel(value, inner, SUB).
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(value, cod, SUB), TypeRel(key, dom, SUB).	
	[ rule_Classes = '"error, msg: insert must be applied to a sequence or a map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinStmt(INSERT, _, _), toSymbol(t1) != #SeqType, toSymbol(t1) != #MapType.
	[ rule_Classes = '"error, msg: for insert right syntax is seq += (index value) or map += (key value)"']
	TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, _, arg2), TypeOf(c, arg2, t2), toSymbol(t2) != #TupType; 
	                                  SubSE(c, e), e = BinStmt(INSERT, _, arg2), TypeOf(c, arg2, t2), t2 : TupType, lstLength(#TupType, t2) != 2.
    [ rule_Classes = '"error, msg: key must be an integer"']
    TypeOf(c, e, ERROR)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)), idx != BaseType(INT).	
    [ rule_Classes = '"error, msg: value must be a subtype of sequence type"']
    TypeOf(c, e, ERROR)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)), TypeRel(value, inner, k), k != SUB, value != inner.	
	[ rule_Classes = '"error, msg: key not in the domain of the map"']
    TypeOf(c, e, ERROR)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(key, dom, k), k != SUB, key != dom.	
	[ rule_Classes = '"error, msg: value not in the codomain of the map"']
    TypeOf(c, e, ERROR)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(value, cod, k), k != SUB, value != cod.
	
	//// (5) Function statements
	TypeOf(c, e, NIL)   :- SubSE(c, e), e = FunStmt(n, NIL, _, _), decl = FunDecl(n, _, _, NIL, _, _, _), FunAvailable(decl, c.owner).
	TypeOf(c, e, NIL)   :- TypeOfArg2(c, e, t1, t2), e = FunStmt(n, _, _, _), FuncSigTupleType(decl, inpt), decl = FunDecl(n, _, _, _, _, _, _), FunAvailable(decl, c.owner), TypeRel(t1, inpt, SUB), TypeRel(decl.return, t2, SUB).
	[ rule_Classes = '"error, msg: function not defined"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, _, _, _), no FunDecl(n, c.owner, _, _, _, _, _), no FunDecl(n, NIL, _, _, _, _, _).	
	[ rule_Classes = '"error, msg: function requires arguments"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, NIL, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.params != NIL.
	[ rule_Classes = '"error, msg: function arguments have incorrect types"']
	TypeOf(c, e, ERROR) :- TypeOfArg1(c, e, t1), e = FunStmt(n, _, _, _), FuncSigTupleType(decl, inpt), decl.name = n, FunAvailable(decl, c.owner), TypeRel(t1, inpt, k), t1 != inpt, k != SUB.
	[ rule_Classes = '"error, msg: function does not return a value"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, _, x, _), x: Name, FunAvailable(decl, c.owner), decl.name = n, decl.return = NIL.
	[ rule_Classes = '"error, msg: invalid assignment. right hand side is not a subtype of left hand side"']
	TypeOf(c, e, ERROR) :- TypeOfArg2(c, e, t1, t2), e = FunStmt(n, _, x, _), x: Name, FunAvailable(decl, c.owner), decl.name = n, TypeRel(decl.return, t2, k), k!= SUB, decl.return != t2.

	//// (6) Receive statement
	ReceiveCases ::= (c: TypingContext, receive: Receive, cases: Cases).
	ReceiveCases(c, receive, cases) :- SubSE(c, receive), receive = Receive(cases, _).
	ReceiveCases(c, receive, cases) :- ReceiveCases(c, receive, Cases(_, _, cases)), cases : Cases.

	[ rule_Classes = '"error, msg: two cases with the same event not allowed"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e: Receive, ReceiveCases(c, e, case1), ReceiveCases(c, e, case2), case1 != case2, case1.trig = case2.trig.
	// This error is covered by one of the cases
	TypeOf(c, e, ERROR) :- SubSE(c, e), e: Receive, ReceiveCases(c, e, cases), TypeOf(c, cases, ERROR).

	ValidCaseEvent ::= (trig: String + { NULL, HALT }).
	ValidCaseEvent(trig) :- trig = NULL.
	ValidCaseEvent(trig) :- trig = HALT.
	ValidCaseEvent(trig) :- trig: String, EventDecl(trig, _, _).

	[ rule_Classes = '"error, msg: event not defined"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = Cases(trig, _, _), trig: String, no EventDecl(trig, _, _).
	
	TypeOf(c, e, NIL) :- SubSE(c, e), e = Cases(trig, _, _), ValidCaseEvent(trig).

    /*************************************************************/
    /*                     Types of arguments                    */
    /*************************************************************/

	//// The type of the first sub-expression in a Typeable with at least one sub-expression.
    TypeOfArg1 ::= (cntxt: TypingContext, expr: Typeable, type1: TypeExpr + { ERROR, NIL }).

	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = New(_, e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = FunApp(_, e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = UnApp(_, e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Cast(e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Tuple(e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = NamedTuple(e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = NewStmt(_, e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = FunStmt(_, e1, _, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = UnStmt(_, e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Return(e1), TypeOf(c, e1, t1).

	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Field(e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = While(e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = BinStmt(_, e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = BinApp(_, e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Exprs(e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = NamedExprs(_, e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Raise(e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Monitor(e1, _), TypeOf(c, e1, t1).

	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Send(e1, _, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Ite(e1, _, _), TypeOf(c, e1, t1).

	//// The type of the first two sub-expression in a Typeable with at least two sub-expression.
    TypeOfArg2::= (cntxt: TypingContext, expr: Typeable, type1: TypeExpr + { ERROR, NIL }, type2: TypeExpr + { ERROR, NIL }).

	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Field(_, n), TypeOfField(t1, n, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = FunStmt(_, _, e2, _), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = BinStmt(_, _, e2), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = BinApp(_, _, e2), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Exprs(_, e2), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = NamedExprs(_, _, e2), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Raise(_, e2), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Monitor(_, e2), TypeOf(c, e2, t2).

	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Send(_, e2, _), TypeOf(c, e2, t2).

	//// The type of the first three sub-expression in a Typeable with at least three sub-expression.
    TypeOfArg3::= (cntxt: TypingContext, expr: Typeable, type1: TypeExpr + { ERROR, NIL }, type2: TypeExpr + { ERROR, NIL }, type3: TypeExpr + { ERROR, NIL }).

	TypeOfArg3(c, e, t1, t2, t3) :- TypeOfArg2(c, e, t1, t2), e = Send(_, _, e3), TypeOf(c, e3, t3).

	//// Determines the payload type of the event mentioned in a communication statement.
	//// If the event expression is not an constant, then this payload type is ANY.
	CommStmtPLType ::= (cntxt: TypingContext, comm: Raise + Send + Monitor, type: TypeExpr + { ERROR }).

	CommStmtPLType(c, e, ERROR)         :- SubSE(c, e), e = Raise(ev, _), TypeOf(c, ev, evt), evt != BaseType(EVENT), no IsEventCnst(c, ev, _).
	CommStmtPLType(c, e, BaseType(ANY)) :- SubSE(c, e), e = Raise(ev, _), TypeOf(c, ev, evt), evt = BaseType(EVENT), no IsEventCnst(c, ev, _).
	CommStmtPLType(c, e, plt)           :- SubSE(c, e), e = Raise(ev, _), IsEventCnst(c, ev, plt).

	CommStmtPLType(c, e, ERROR)         :- SubSE(c, e), e = Send(_, ev, _), TypeOf(c, ev, evt), evt != BaseType(EVENT), no IsEventCnst(c, ev, _).
	CommStmtPLType(c, e, BaseType(ANY)) :- SubSE(c, e), e = Send(_, ev, _), TypeOf(c, ev, evt), evt = BaseType(EVENT), no IsEventCnst(c, ev, _).
	CommStmtPLType(c, e, plt)           :- SubSE(c, e), e = Send(_, ev, _), IsEventCnst(c, ev, plt).

	CommStmtPLType(c, e, ERROR)         :- SubSE(c, e), e = Monitor(ev, _), TypeOf(c, ev, evt), evt != BaseType(EVENT), no IsEventCnst(c, ev, _).
	CommStmtPLType(c, e, BaseType(ANY)) :- SubSE(c, e), e = Monitor(ev, _), TypeOf(c, ev, evt), evt = BaseType(EVENT), no IsEventCnst(c, ev, _).
	CommStmtPLType(c, e, plt)           :- SubSE(c, e), e = Monitor(ev, _), IsEventCnst(c, ev, plt).

    /*************************************************************/
    /*                      Field helpers                        */
    /*************************************************************/

	TOrNTType      ::= TupType + NmdTupType.
	FieldLabel     ::= String + Natural.
    TypeOfField    ::= (tupTyp: TOrNTType, lookup: FieldLabel, fieldType: TypeExpr + { ERROR }).    
    TypeOfFieldAux ::= (tupTyp: TOrNTType, lookup: FieldLabel, fieldType: TypeExpr + { ERROR }, pos: Natural, tail: TOrNTType + { NIL }).

    TypeOfFieldAux(ttup, n, ERROR, 0, ttup)  :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', ttup), ttup : TOrNTType.    
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), n = pos, pos' = pos + 1, aux = TupType(t, tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), n = pos, pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(_, t), tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(n, t), tl).

    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, t, pos, aux), n != pos, pos' = pos + 1, aux = TupType(_, tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, t, pos, aux), n != pos, n != fn, pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(fn, _), tl).

    TypeOfField(ttup, n, ft)                 :- TypeOfFieldAux(ttup, n, ft, _, NIL).    
	TypeOfField(ttup, n, ERROR)              :- TypeOfFieldAux(ttup, n, ERROR, 0, ttup), n : String, ttup : TupType.

	/*************************************************************/
    /*                  Local Variable Types                     */
    /*************************************************************/
	MaxNumLocals ::= (ctxt: TypingContext + Stmt + Cases, n: Natural).
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: NewStmt.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Raise.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Send.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Monitor.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: FunStmt.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: NulStmt.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: UnStmt.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: BinStmt.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Return.
	MaxNumLocals(e, n) :- SubSE(c, e), c is TypingContext, e = While(_, e'), MaxNumLocals(e', n).
	MaxNumLocals(e, n) :- SubSE(c, e), c is TypingContext, e = Ite(_, e1, e2), 
						  MaxNumLocals(e1, n1), MaxNumLocals(e2, n2), n = max(n1, n2).
    MaxNumLocals(e, n) :- SubSE(c, e), c is TypingContext, e = Seq(e1, e2), 
	                      MaxNumLocals(e1, n1), MaxNumLocals(e2, n2), n = max(n1, n2).
	MaxNumLocals(e, n) :- SubSE(c, receive), c is TypingContext, receive: Receive, 
						  ReceiveCases(c, receive, e), e = Cases(_, a, NIL), MaxNumLocals(a, n).
	MaxNumLocals(e, n) :- SubSE(c, receive), c is TypingContext, receive: Receive, 
						  ReceiveCases(c, receive, e), e = Cases(_, a, e'), e': Cases, 
						  MaxNumLocals(a, n1), MaxNumLocals(e', n2), n =  max(n1, n2).
	MaxNumLocals(e, n) :- SubSE(c, e), c is TypingContext, e = Receive(cases, _), MaxNumLocals(cases, n). 
	MaxNumLocals(a, n) :- a is AnonFunDecl, MaxNumLocals(a.body, n1), n2 = lstLength(#NmdTupType, a.locals), n = n1 + n2.
	MaxNumLocals(a, n) :- a is FunDecl, MaxNumLocals(a.body, n1), n2 = lstLength(#NmdTupType, a.locals), n3 = lstLength(#NmdTupType, a.params), n = n1 + n2 + n3.

    LocalVarsAux ::= (cntxt: FunDecl + AnonFunDecl, vars: NmdTupType + { NIL }, tl: NmdTupType + { NIL }).
	LocalVarsAux(cntxt, params, rlocals) :- cntxt is FunDecl(_, _, _, params, _, locals, _), rlocals = lstReverse(#NmdTupType, locals).
	LocalVarsAux(cntxt, envVars, rlocals) :- cntxt is AnonFunDecl(_, locals, _, envVars), rlocals = lstReverse(#NmdTupType, locals).
	LocalVarsAux(cntxt, locals, tl) :- LocalVarsAux(cntxt, locals', tl'), tl' = NmdTupType(NmdTupTypeField(name, type), tl),
									   locals = NmdTupType(NmdTupTypeField(name, type), locals').

	LocalVars ::= (cntxt: FunDecl + AnonFunDecl, vars: NmdTupType + { NIL }).
	LocalVars(cntxt, rlocals) :- LocalVarsAux(cntxt, locals, NIL), rlocals = lstReverse(#NmdTupType, locals).

	TypeOfLocalVar    ::= (cntxt: FunDecl + AnonFunDecl, name: String, type: TypeExpr + { ERROR }).
    TypeOfLocalVarAux ::= (cntxt: FunDecl + AnonFunDecl, name: String, type: TypeExpr, aux: NmdTupType + { NIL }).

    TypeOfLocalVarAux(cntxt, name, type, tl) :- LocalVars(cntxt, locals), locals = NmdTupType(NmdTupTypeField(name, type), tl).
    TypeOfLocalVarAux(cntxt, name, type, tl) :- TypeOfLocalVarAux(cntxt, _, _, aux), aux = NmdTupType(NmdTupTypeField(name, type), tl).
    
    TypeOfLocalVar(cntxt, name, type)  :- TypeOfLocalVarAux(cntxt, name, type, aux), no { aux' | TypeOfLocalVarAux(cntxt, name, _, aux'), aux != aux' }.      
	[ rule_Classes = '"error, msg: Variable with same name has been declared before"']
    TypeOfLocalVar(cntxt, name, ERROR) :- TypeOfLocalVarAux(cntxt, name, _, aux), TypeOfLocalVarAux(cntxt, name, _, aux'), aux != aux'.
    /*************************************************************/
    /*                  Formal Parameter Types                   */
    /*************************************************************/
    TypeOfFormalParam    ::= (cntxt: FunDecl, name: String, type: TypeExpr + { ERROR }).
    TypeOfFormalParamAux ::= (cntxt: FunDecl, name: String, type: TypeExpr, aux: NmdTupType + { NIL }).

    TypeOfFormalParamAux(cntxt, name, type, tl) :- cntxt is FunDecl(_, _, _, params, _, _, _), params = NmdTupType(NmdTupTypeField(name, type), tl).  
    TypeOfFormalParamAux(cntxt, name, type, tl) :- TypeOfFormalParamAux(cntxt, _, _, aux), aux = NmdTupType(NmdTupTypeField(name, type), tl).
    
    TypeOfFormalParam(cntxt, name, type)  :- TypeOfFormalParamAux(cntxt, name, type, aux), no { aux' | TypeOfFormalParamAux(cntxt, name, _, aux'), aux != aux' }.      
	//// This error is generated as part of DupNmdSubE
    TypeOfFormalParam(cntxt, name, ERROR) :- TypeOfFormalParamAux(cntxt, name, _, aux), TypeOfFormalParamAux(cntxt, name, _, aux'), aux != aux'.

	//// The input type of a function, ignoring names.
	FuncSigTupleType    ::= (cntxt: FunDecl, type: TupType + { NIL }).
	FuncSigTupleTypeAux ::= (cntxt: FunDecl, type: TupType + { NIL }, aux: NmdTupType + { NIL }).

	FuncSigTupleTypeAux(cntxt, params, NIL) :- cntxt is FunDecl(_, _, _, params, _, _, _), params = NIL.
	FuncSigTupleTypeAux(cntxt, type, tl)    :- cntxt is FunDecl(_, _, _, params, _, _, _), params = NmdTupType(NmdTupTypeField(_, t), tl), type = TupType(t, NIL).
	FuncSigTupleTypeAux(cntxt, type, tl)    :- FuncSigTupleTypeAux(cntxt, t', aux), aux = NmdTupType(NmdTupTypeField(_, t), tl), type = TupType(t, t').
	FuncSigTupleType(cntxt, type)           :- FuncSigTupleTypeAux(cntxt, t, NIL), type = lstReverse(#TupType, t).

    /*************************************************************/
    /* Check that named tuple (types) don't reuse the same name  */
    /*************************************************************/
	NmdList       ::= NmdTupType + NamedExprs.
	NmdListOrNone ::= NmdTupType + NamedExprs + { NIL }.

	NmdSubE     ::= sub (NmdList).
	MaxNmdSubE  ::=     (NmdList).
	NmdSubNames ::=     (list: NmdList, name: String, aux: NmdListOrNone). 
	DupNmdSubE  ::=     (list: NmdList, name: String, aux1: NmdListOrNone, aux2: NmdListOrNone).

	MaxNmdSubE(e) :- NmdSubE(e), no NmdSubE(NmdTupType(_, e)), no NmdSubE(NamedExprs(_, _, e)).
	NmdSubNames(list, name, tl) :- MaxNmdSubE(list), list = NmdTupType(NmdTupTypeField(name, _), tl). 
	NmdSubNames(list, name, tl) :- MaxNmdSubE(list), list = NamedExprs(name, _, tl). 
	NmdSubNames(list, name, tl) :- NmdSubNames(list, _, aux), aux = NmdTupType(NmdTupTypeField(name, _), tl). 
	NmdSubNames(list, name, tl) :- NmdSubNames(list, _, aux), aux = NamedExprs(name, _, tl). 

    [ rule_Classes = '"error, msg: same name appears more than once in name tuple or named tuple type"']
	DupNmdSubE(list, name, tl, tl') :- NmdSubNames(list, name, tl), NmdSubNames(list, name, tl'), tl != tl'.

    /*************************************************************/
    /*                          L-values                         */
    /*************************************************************/
	LValueError    ::= (cntxt: TypingContext, stmt: BinStmt + FunStmt).
	ModStmtSubExpr ::= sub (cntxt: TypingContext, stmt: BinStmt + FunStmt, expr: Expr).
	IsLValue       ::=     (cntxt: TypingContext, expr: Expr, writesGlobal: Boolean). 
	IsLValue(c, e, FALSE)  :- ModStmtSubExpr(c, _, e), e = Name(n), TypeOfLocalVar(c, n, _).		
    IsLValue(c, e, TRUE)   :- ModStmtSubExpr(c, _, e), e = Name(n), VarDecl(n, c.owner, t), no TypeOfLocalVar(c, n, _). 
    IsLValue(c, e, wg)     :- ModStmtSubExpr(c, _, e), e = Field(e', _), IsLValue(c, e', wg). 
    IsLValue(c, e, wg)     :- ModStmtSubExpr(c, _, e), e = BinApp(IDX, e', _), IsLValue(c, e', wg). 

    [ rule_Classes = '"error, msg: invalid LHS; must have the form LHS ::= var | LHS[expr] | LHS.name"']
	LValueError(c, e) :- SubSE(c, e), e = BinStmt(_, e', _), no IsLValue(c, e', _);
						 SubSE(c, e), e = FunStmt(_, _, x, _), x: Name, no IsLValue(c, x, _).

    /*************************************************************/
    /*                      Control Impurity                     */
    /*************************************************************/
    PurityError ::= (cntxt: TypingContext + StateDecl + TransDecl, expr: Typeable + String + AnonFunDecl).

	ControlImpure ::= (TypingContext).
	ControlImpure(c) :- SubSE(c, e), e : Raise.
	ControlImpure(c) :- SubSE(c, e), e : Receive.
	ControlImpure(c) :- SubSE(c, e), e = NulStmt(POP).
	ControlImpure(c) :- SubSE(c, e), e = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), ControlImpure(called).
    ControlImpure(c) :- SubSE(c, e), e = FunStmt(n, _, _, _), called.name = n, FunAvailable(called, c.owner), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, n) :- 
	       c is StateDecl(_, owner, _, n, _), called.name = n, FunAvailable(called, owner), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, called) :- 
	       c is StateDecl(_, owner, _, called, _), called = AnonFunDecl(_, _, _, _), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, n) :- 
	       c is TransDecl(src, _, _, n), called.name = n, FunAvailable(called, src.owner), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, called) :- 
	       c is TransDecl(src, _, _, called), called = AnonFunDecl(_, _, _, _), ControlImpure(called).


    /*************************************************************/
    /*                      Monitor Checking                     */
    /*************************************************************/
	MonitorError ::= (cntxt: StateDecl + TransDecl + DoDecl, expr: String + AnonFunDecl).
	MonitorImpure ::= (TypingContext).
	MonitorImpure(c) :- SubSE(c, e), e = NulApp(NONDET).
	MonitorImpure(c) :- SubSE(c, e), e = NulApp(FAIRNONDET).
	MonitorImpure(c) :- SubSE(c, e), e = NulApp(THIS).
	MonitorImpure(c) :- SubSE(c, e), e : New.
	MonitorImpure(c) :- SubSE(c, e), e : Send.
	MonitorImpure(c) :- SubSE(c, e), e : NewStmt.
	MonitorImpure(c) :- SubSE(c, e), e : Monitor.
	MonitorImpure(c) :- SubSE(c, e), e : Receive.
	MonitorImpure(c) :- SubSE(c, e), e = NulStmt(POP).
    MonitorImpure(c) :- SubSE(c, e), e = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), MonitorImpure(called).
    MonitorImpure(c) :- SubSE(c, e), e = FunStmt(n, _, _, _), called.name = n, FunAvailable(called, c.owner), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
    MonitorError(c, n) :- 
	       c is StateDecl(_, owner, n, _, _), owner.kind = MONITOR, called.name = n, FunAvailable(called, owner), MonitorImpure(called);
		   c is StateDecl(_, owner, _, n, _), owner.kind = MONITOR, called.name = n, FunAvailable(called, owner), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
    MonitorError(c, called) :- 
	       c is StateDecl(_, owner, called, _, _), owner.kind = MONITOR, called = AnonFunDecl(_, _, _, _), MonitorImpure(called);
		   c is StateDecl(_, owner, _, called, _), owner.kind = MONITOR, called = AnonFunDecl(_, _, _, _), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
    MonitorError(c, n) :- 
	       c is TransDecl(src, _, _, n), src.owner.kind = MONITOR, called.name = n, FunAvailable(called, src.owner), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
    MonitorError(c, called) :- 
	       c is TransDecl(src, _, _, called), src.owner.kind = MONITOR, called = AnonFunDecl(_, _, _, _), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
	MonitorError(c, n) :-	
		   c is DoDecl(src, _, n), src.owner.kind = MONITOR, called.name = n, FunAvailable(called, src.owner), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
	MonitorError(c, called) :- 
		   c is DoDecl(src, _, called), src.owner.kind = MONITOR, called = AnonFunDecl(_, _, _, _), MonitorImpure(called).

    /*************************************************************/
    /*                         Receive Labels                       */
    /*************************************************************/
    BadLabelError ::= (TypingContext).
	Continuation ::= Receive + FunStmt.

	//// Every receive statement must have a label that is unique within a context.
	//// This constraint simplifies P compilers.
	
	//// A term path describes how to reach a term.
	//// 0 means this term is reached by following the 1st child stmt of the parent term.
	//// 1 means this term is reached by following the 2nd child stmt of the parent term.
	TermPath    ::= (child: { 0, 1 }, prev: TermPath + { NIL }).
	ReachedContinuation ::= (cntxt: TypingContext, stmt: Stmt, path: TermPath + { NIL }).
	ReachedContinuation(c, c.body, NIL) :- SubCntxt(c).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = While(_, s'),  p' = TermPath(0, p).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = Ite(_, s', _), p' = TermPath(0, p).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = Ite(_, _, s'), p' = TermPath(1, p).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = Seq(s', _),    p' = TermPath(0, p).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = Seq(_, s'),    p' = TermPath(1, p).

    [ rule_Classes = '"error, msg: function contains bad labeling of Receive"']
	BadLabelError(c) :-
	    ReachedContinuation(c, s, p), ReachedContinuation(c, s', p'), s : Continuation, s' : Continuation, s.label = s'.label, p != p'.
	
    /*************************************************************/
    /*                            Impurity                       */
    /*************************************************************/
	Impure ::= (FunDecl).

	Impure(c) :- SubSE(c, e), c : FunDecl, e = BinStmt(_, e', e''), IsLValue(c, e', TRUE).
	Impure(c) :- SubSE(c, e), c : FunDecl, e = NewStmt(_, _).
	Impure(c) :- SubSE(c, e), c : FunDecl, e = New(_, _).
	Impure(c) :- SubSE(c, e), c : FunDecl, e = Send(_, _, _). 
	Impure(c) :- c: FunDecl, ControlImpure(c).
	Impure(c) :- SubSE(c, e), e = FunApp(n, _), c : FunDecl, called.name = n, FunAvailable(called, c.owner), Impure(called).
	Impure(c) :- SubSE(c, e), e = FunStmt(n, _, _, _), c : FunDecl, called.name = n, FunAvailable(called, c.owner), Impure(called).
	Impure(c) :- SubSE(c, e), e = FunStmt(n, _, aout, _), c : FunDecl, aout : Name, IsLValue(c, aout, TRUE).

    [ rule_Classes = '"error, msg: this function must be pure. Data impure functions can only be called like "foo(...);" or "x = foo(...);" "']
    PurityError(c, e') :- 
       SubSE(c, e), e = New(_, e'),        e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = UnApp(_, e'),         e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinApp(_, e', _),     e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinApp(_, _, e'),     e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Field(e', _),         e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Cast(e', _),          e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Exprs(e', _),         e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);              
       SubSE(c, e), e = NamedExprs(_, e', _), e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = NewStmt(_, e'),    e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Raise(e', _),         e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Raise(_, e'),         e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);        
       SubSE(c, e), e = Send(e', _, _),       e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Send(_, e', _),       e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Send(_, _, e'),       e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Monitor(e', _),       e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Monitor(_, e'),       e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = UnStmt(_, e'),        e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Return (e'),          e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = While(e', _),         e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Ite(e', _, _),        e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinStmt(_, e', _),    e' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinStmt(_, e', e''),  e'' = FunApp(n, _), called.name = n, FunAvailable(called, c.owner), Impure(called), toSymbol(e') != #Name.

    [ rule_Classes = '"error, msg: new M(...) can only be called like "new M(...);" or "x = new M(...);" "']
    PurityError(c, e') :- 
       SubSE(c, e), e = New(_, e'),        e' : New;
       SubSE(c, e), e = UnApp(_, e'),         e' : New;
       SubSE(c, e), e = BinApp(_, e', _),     e' : New;
       SubSE(c, e), e = BinApp(_, _, e'),     e' : New;    
       SubSE(c, e), e = Field(e', _),         e' : New;
       SubSE(c, e), e = Cast(e', _),          e' : New;    
       SubSE(c, e), e = Exprs(e', _),         e' : New;              
       SubSE(c, e), e = NamedExprs(_, e', _), e' : New;
       SubSE(c, e), e = NewStmt(_, e'),    e' : New;
       SubSE(c, e), e = Raise(e', _),         e' : New;
       SubSE(c, e), e = Raise(_, e'),         e' : New;        
       SubSE(c, e), e = Send(e', _, _),       e' : New;
       SubSE(c, e), e = Send(_, e', _),       e' : New;
       SubSE(c, e), e = Send(_, _, e'),       e' : New;    
       SubSE(c, e), e = Monitor(e', _),       e' : New;
       SubSE(c, e), e = Monitor(_, e'),       e' : New;    
       SubSE(c, e), e = UnStmt(_, e'),        e' : New;
       SubSE(c, e), e = Return (e'),          e' : New;
       SubSE(c, e), e = While(e', _),         e' : New;
       SubSE(c, e), e = Ite(e', _, _),        e' : New;
       SubSE(c, e), e = BinStmt(_, e', _),    e' : New;
       SubSE(c, e), e = BinStmt(_, e', e''),  e'' : New, toSymbol(e') != #Name.
						 	                                          
    /*************************************************************/
    /*                      Type Comparability                   */
    /*************************************************************/
    //// These are the pairs of types whose relationships must be computed.
    CompTypeRel ::= (TypeExpr + { NIL, ERROR }, TypeExpr + { NIL, ERROR }).
    CompTypeRel(ta', tb')                    :- CompTypeRel(ta, tb), ta = SeqType(ta'), tb = SeqType(tb').
    CompTypeRel(da, db), CompTypeRel(ca, cb) :- CompTypeRel(ta, tb), ta = MapType(da, ca), tb = MapType(db, cb).
    CompTypeRel(la, lb), CompTypeRel(ra, rb) :- CompTypeRel(ta, tb), ta = TupType(la, ra), tb = TupType(lb, rb).
    CompTypeRel(la, lb), CompTypeRel(ra, rb) :- CompTypeRel(ta, tb), ta = NmdTupType(lfa, ra), tb = NmdTupType(lfb, rb), la = lfa.type, lb = lfb.type.
    
	CompTypeRel(t1, t2)       :- TypeOfArg1(c, e, t1), e = Cast(_, t2).
	CompTypeRel(t1, t2)       :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PolyRel.
	CompTypeRel(t2, dom)      :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 = MapType(dom, cod).
	CompTypeRel(t1, inner)    :- TypeOfArg2(c, e, t1, t2), e = BinApp(IN, _, _), t2 = SeqType(inner).
	CompTypeRel(t1, dom)      :- TypeOfArg2(c, e, t1, t2), e = BinApp(IN, _, _), t2 = MapType(dom, _).      
	CompTypeRel(t1, inpt)     :- TypeOfArg1(c, e, t1), e = FunApp(n, _), FuncSigTupleType(decl, inpt), decl.name = n, FunAvailable(decl, c.owner).
	CompTypeRel(t1, t)        :- TypeOfArg1(c, e, t1), e : Return, c = FunDecl(_, _, _, _, t, _, _).
	CompTypeRel(null, plt)    :- CommStmtPLType(c, e, plt), e = Raise(_, NIL), null = BaseType(NULL).
	CompTypeRel(pt, plt)      :- CommStmtPLType(c, e, plt), e = Raise(_, p), p != NIL, TypeOf(c, p, pt).
	CompTypeRel(null, plt)    :- SubSE(c, e), e = Send(_, _, NIL), null = BaseType(NULL), CommStmtPLType(c, e, plt).
	CompTypeRel(t3, plt)      :- TypeOfArg3(c, e, t1, t2, t3), e : Send, CommStmtPLType(c, e, plt).
	CompTypeRel(null, plt)    :- SubSE(c, e), e = Monitor(_, NIL), null = BaseType(NULL), CommStmtPLType(c, e, plt).
	CompTypeRel(t2, plt)      :- TypeOfArg2(c, e, t1, t2), e : Monitor, CommStmtPLType(c, e, plt).
	CompTypeRel(t2, plt)      :- TypeOfArg2(c, e, t1, t2), e = Monitor(_, _), CommStmtPLType(c, e, plt).
	CompTypeRel(t2, t1)       :- TypeOfArg2(c, e, t1, t2), e = BinStmt(ASSIGN, _, _).	
	CompTypeRel(t2, dom)      :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _), t1 = MapType(dom, cod).	
	CompTypeRel(key, dom)     :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)).
	CompTypeRel(value, cod)   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)).
	CompTypeRel(value, inner) :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)).
	CompTypeRel(t1, inpt)     :- TypeOfArg1(c, e, t1), e = FunStmt(n, _, _, _), FuncSigTupleType(decl, inpt), decl.name = n, FunAvailable(decl, c.owner).
	CompTypeRel(t1, t2)       :- TypeOfArg2(c, e, _, t2), e = FunStmt(n, _, x, _), x: Name, FunAvailable(decl, c.owner), decl.name = n, decl.return = t1.

    //// TypeRel determines the relationship type expressions ta and tb.
    //// If types are not subtype related, then they can
    //// either have an empty (EMPTY) or nonempty (NONEMPTY) intersection. 
    TypeRel ::= (ta: TypeExpr + { ERROR, NIL }, tb: TypeExpr + { ERROR, NIL }, rel: { SUB, SUP, EMPTY, NONEMPTY }).
                            
    //// (1) Type (non-) emptiness.       
    // For convenience, the ERROR type is incomparable to all types, even itself.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = ERROR.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s = ERROR.
    
    // For convenience, the NIL type is incomparable to all types, except itself.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NIL, t != NIL.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s = NIL, t != NIL.
    
    // The NULL type has empty intersections with NonNullBase and complex types.
    NonNullBase ::= { BOOL, INT, FOREIGN }.
    ComplexType ::= TupType  + NmdTupType + SeqType + MapType.
    TypeRel(s, t, EMPTY)   :- CompTypeRel(s, t), s = BaseType(kt), kt : NonNullBase, t = BaseType(NULL).
    TypeRel(t, s, EMPTY)   :- CompTypeRel(t, s), s = BaseType(kt), kt : NonNullBase, t = BaseType(NULL).
    
    TypeRel(s, t, EMPTY)   :- CompTypeRel(s, t), s : ComplexType, t = BaseType(NULL).
    TypeRel(t, s, EMPTY)   :- CompTypeRel(t, s), s : ComplexType, t = BaseType(NULL).
        
    // NonNullBase types have empty intersections with all types, except themselves and ANY.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = BaseType(ks), ks : NonNullBase, s != t, t != BaseType(ANY).
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s = BaseType(ks), ks : NonNullBase, s != t, t != BaseType(ANY).

    // NullBase types have empty intersections with all types, except themselves, ANY, and NULL.
    NullBase    ::= { EVENT, REAL }.    
	
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = BaseType(ks), ks : NullBase, t = BaseType(kt), kt : NonNullBase.
    TypeRel(t, s, EMPTY)    :- CompTypeRel(t, s), s = BaseType(ks), ks : NullBase, t = BaseType(kt), kt : NonNullBase.
    
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = BaseType(ks), ks : NullBase, toSymbol(t) != #BaseType, toSymbol(t) != #InterfaceType.
    TypeRel(t, s, EMPTY)    :- CompTypeRel(t, s), s = BaseType(ks), ks : NullBase, toSymbol(t) != #BaseType, toSymbol(t) != #InterfaceType.
          
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = BaseType(ks), ks : NullBase, t = BaseType(kt), kt : NullBase, s != t, kt != ANY, kt != NULL.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = BaseType(ks), ks : NullBase, t = BaseType(kt), kt : NullBase, s != t, kt != ANY, kt != NULL.

	//Interface Type has empty intersection with all the types except themselves, ANY, REAL and NULL
	TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : InterfaceType, t = BaseType(kt), kt != ANY, kt != NULL, kt != REAL.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s : InterfaceType, t = BaseType(kt), kt != ANY, kt != NULL, kt != REAL.

	TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : InterfaceType, toSymbol(t) != #BaseType, toSymbol(t) != #InterfaceType.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s : InterfaceType, toSymbol(t) != #BaseType, toSymbol(t) != #InterfaceType.

    // Complex types have empty intersections with all differing type kinds, except ANY.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : ComplexType, toSymbol(s) != toSymbol(t), t != BaseType(ANY).
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s : ComplexType, toSymbol(s) != toSymbol(t), t != BaseType(ANY).
    
    // Sequences are EMPTY or NONEMPTY if their inner types are. (Only need one version of these rules.)
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', EMPTY). 
    
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', NONEMPTY). 
    
    // Maps are EMPTY or NONEMPTY if their inner types are. (Only need one version of these rules.)
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = MapType(sd, _),  t = MapType(td, _),  TypeRel(sd, td, EMPTY).
    
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = MapType(_, sc),  t = MapType(_, tc),  TypeRel(sc, tc, EMPTY).    
    
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, NONEMPTY), TypeRel(sc, tc, NONEMPTY). 

    // Tuples and NmdTups are EMPTY if their lengths differ. (Only need one version of these rules.)
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : TupType, t : TupType, lstLength(#TupType, s) != lstLength(#TupType, t).
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : NmdTupType, t : NmdTupType, lstLength(#NmdTupType, s) != lstLength(#NmdTupType, t).
    
    // Tuples are EMPTY if any pair of inner types is EMPTY.  (Only need one version of some of these rules.)
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = TupType(s', _), t = TupType(t', _), TypeRel(s', t', EMPTY). 
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = TupType(_, s'), t = TupType(_, t'), TypeRel(s', t', EMPTY). 
    
    // Tuples are NONEMPTY if not all inners types are in identical super / sub relationships. 
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
                                                                                           
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.

    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', SUB), TypeRel(s'', t'', SUP), s' != t', s'' != t''.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', SUB), TypeRel(s'', t'', SUP), s' != t', s'' != t''.
                               
    // Named Tuples are EMPTY if any pair of inner types is EMPTY or they name arguments differently. (Only need one version of some of these rules.) 
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, _), t = NmdTupType(ft, _), fs.name != ft.name. 
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, _), t = NmdTupType(ft, _), TypeRel(fs.type, ft.type, EMPTY). 
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NmdTupType(_, s'), t = NmdTupType(_, t'), TypeRel(s', t', EMPTY). 
    
    // Named Tuples are NONEMPTY if not all inners types are in identical super / sub relationships. 
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
                                                            
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.

    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUP), fs.type != ft.type, s'' != t''.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUP), fs.type != ft.type, s'' != t''.
                               
    //// (3) Sub-typing.                
    // Any non-ERROR type is sub-type related to itself.
    TypeRel(s, s, SUB) :- CompTypeRel(s, s), s != ERROR.
    TypeRel(s, s, SUP) :- CompTypeRel(s, s), s != ERROR.
   
    // Every proper type is a sub-type of any.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s != ERROR, s != NIL, t = BaseType(ANY).
    TypeRel(t, s, SUP) :- CompTypeRel(t, s), s != ERROR, s != NIL, t = BaseType(ANY).
        
    // NULL is a subtype of all Nullable types.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = BaseType(NULL), t = BaseType(ANY).
    TypeRel(t, s, SUP) :- CompTypeRel(t, s), s = BaseType(NULL), t = BaseType(ANY).
    
    TypeRel(s, t, SUB) :-  CompTypeRel(s, t), s = BaseType(NULL), t = BaseType(kt), kt : NullBase.
    TypeRel(t, s, SUP) :-  CompTypeRel(t, s), s = BaseType(NULL), t = BaseType(kt), kt : NullBase.
    
	// Interface type is a subtype of the machine base-type
	TypeRel(s, t, SUB) :- CompTypeRel(s, t), t = BaseType(REAL), s : InterfaceType. 
	TypeRel(t, s, SUP) :- CompTypeRel(t, s), t = BaseType(REAL), s : InterfaceType. 

	// Subtype relation between interface types.
	SubSetRelation ::= (interface1: InterfaceType, interface2: InterfaceType).
	NoSubSetRelation ::= (interface1: InterfaceType, interface2: InterfaceType).
	SubSetRelation(n1, n2) :- x is InterfaceEventDecl(n1, _), y is InterfaceEventDecl(n2, _), n1 != n2, no { e | InterfaceEventDecl(n1, e), no InterfaceEventDecl(n2, e)}. 
	NoSubSetRelation(n1, n2) :- x is InterfaceEventDecl(n1, _), y is InterfaceEventDecl(n2, _), n1 != n2, count({ e | InterfaceEventDecl(n1, e), no InterfaceEventDecl(n2, e), InterfaceEventDecl(n2, ee), no InterfaceEventDecl(n1, ee)}) > 0.
	
	
	TypeRel(s, t, SUB) :- CompTypeRel(s, t), s : InterfaceType, t : InterfaceType, s != t, SubSetRelation(t, s).
	TypeRel(t, s, SUP) :- CompTypeRel(t, s), s : InterfaceType, t : InterfaceType, s != t, SubSetRelation(t, s).
	TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), t : InterfaceType, s : InterfaceType, s != t, NoSubSetRelation(s, t).
	TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), t : InterfaceType, s : InterfaceType, s != t, NoSubSetRelation(s, t).
	
	//Interface type is a supertype of NULL
	TypeRel(s, t, SUB) :- CompTypeRel(s, t), t : InterfaceType, s = BaseType(NULL).
	TypeRel(t, s, SUP) :- CompTypeRel(t, s), t : InterfaceType, s = BaseType(NULL).

	//Interface type is a subtype of ANY
	TypeRel(s, t, SUB) :- CompTypeRel(s, t), s : InterfaceType, t = BaseType(ANY).
	TypeRel(t, s, SUP) :- CompTypeRel(t, s), s : InterfaceType, t = BaseType(ANY).

    // Sequences are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB)    :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', SUB). 
    TypeRel(s, t, SUP)    :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', SUP). 
    
    // Maps are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, SUB), TypeRel(sc, tc, SUB). 
    TypeRel(s, t, SUP) :- CompTypeRel(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, SUP), TypeRel(sc, tc, SUP). 
    
    // Tuples are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), TypeRel(s', t', SUB), TypeRel(s'', t'', SUB).
    TypeRel(s, t, SUP) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), TypeRel(s', t', SUP), TypeRel(s'', t'', SUP).
    
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUB).    
    TypeRel(s, t, SUP) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, TypeRel(fs.type, ft.type, SUP), TypeRel(s'', t'', SUP).   
	
    /*************************************************************/
    /*                      Payload Inference                    */
    /*************************************************************/	

	//// The type of a payload in some (anonymous) function is based on the events
	//// that could have lead to that execution of that function.
	PayloadType ::= (TypingContext, TypeExpr).

	PayloadType(plc, type) :- plc is PlContext, plc : TypingContext, 
	                          joins = toList(#TypeJoinList, NIL, 
	                          { t | TriggerSet(plc, NULL),    t = BaseType(NULL);
							        TriggerSet(plc, NEW),     t = BaseType(ANY);
									TriggerSet(plc, HALT),    t = BaseType(ANY);
									TriggerSet(plc, EXIT),    t = BaseType(ANY);
									TriggerSet(plc, e), EventDecl(e, _, t), t : TypeExpr;
									TriggerSet(plc, e), EventDecl(e, _, NIL), t = BaseType(NULL) }),
							  TypeJoins(joins, type).

	//// Need to record the set of events that could lead to the evaluation of a function.
	//// A null trigger or initial state results in a null event.

	//// These are the places where payload can be written or read.
	PlContext ::= StateDecl + TransDecl + DoDecl + FunDecl + AnonFunDecl.

	//// The set of events that could have changed trigger and payload in this context.
	//// The NEW constant represents the new pseudo-event.
	TriggerSet ::= (cntxt: PlContext, name: String + { NULL, HALT, NEW, EXIT }).
	
	//// (1) A transition's trigger set is a singleton containing the trigger.
	TriggerSet(t, t.trig) :- t is TransDecl. 

	//// (2) A do's trigger set is a singleton containing the trigger.
	TriggerSet(d, d.trig) :- d is DoDecl. 

	//// (3) A state's trigger set is the set of events that could have lead to this entry function.
	//// This state is an initial state, so give it the NEW pseudo-event.
	TriggerSet(s, NEW) :- m is MachineDecl, s is StateDecl, m.start = s.name, s.owner = m.

	//// This state can be reached by a transition, so give it the trigger of this transition.
	TriggerSet(s, t.trig) :- t is TransDecl, s is StateDecl, s.name = t.dst, s.owner = t.src.owner. 

	//// (4) An AnonFunDecl's trigger set is the set of events of its calling context.
	//// payloads in exit functions are unpredictable.
	//// (TODO: Must change AnonFunDecl's to capture different calling contexts.)
    TriggerSet(a, EXIT) :- s is StateDecl, a = s.exitFun, a : AnonFunDecl.
    TriggerSet(a, e)    :- TriggerSet(s, e), s : StateDecl, a = s.entryAction, a : AnonFunDecl.
    TriggerSet(a, e)    :- TriggerSet(t, e), t : TransDecl, a = t.action, a : AnonFunDecl.
    TriggerSet(a, e)    :- TriggerSet(d, e), d : DoDecl, a = d.action, a : AnonFunDecl.
	TriggerSet(a, e)    :- SubSE(c, cases), cases = Cases(e, a, _), a : AnonFunDecl. 

	//// (5) An FunDecl's trigger set is the set of events of its calling contexts.
	//// payloads in exit functions are unpredictable.
    TriggerSet(f, EXIT) :- s is StateDecl, f is FunDecl, f.name = s.exitFun, FunAvailable(f, s.owner).
    TriggerSet(f, e)    :- TriggerSet(s, e), s : StateDecl, f is FunDecl, f.name = s.entryAction, FunAvailable(f, s.owner).
    TriggerSet(f, e)    :- TriggerSet(t, e), t : TransDecl, f is FunDecl, f.name = t.action, FunAvailable(f, t.src.owner).
    TriggerSet(f, e)    :- TriggerSet(d, e), d : DoDecl, f is FunDecl, f.name = d.action, FunAvailable(f, d.src.owner).
    TriggerSet(f, e)	:- TriggerSet(c, e), SubSE(c, x), x = FunApp(name, _), f is FunDecl, FunAvailable(f, c.owner), f.name = name.
    TriggerSet(f, e)	:- TriggerSet(c, e), SubSE(c, x), x = FunStmt(name, _, _, _), f is FunDecl, FunAvailable(f, c.owner), f.name = name.

	/*************************************************************/
    /*                      Compute type joins                   */
    /*************************************************************/	

	TypeJoinList ::= (TypeExpr, TypeJoinList + { NIL }). 

	//// The join of a pair of types and of a list of types.
	TypeJoin     ::= (ta: TypeExpr + { NIL }, tb: TypeExpr + { NIL }, j: TypeExpr + { NIL }).
    TypeJoins    ::= (list: TypeJoinList + { NIL }, type: TypeExpr).

	//// A pair of joins that need to be computed, and a list of joins that need to be computed.
	CompTypeJoin  ::= (TypeExpr + { NIL }, TypeExpr + { NIL }).
    CompTypeJoins ::= (list: TypeJoinList + { NIL }).

	//// Compute the type joins of payload contexts.
	CompTypeJoins(joins) :- plc is PlContext, 
	                        joins = toList(#TypeJoinList, NIL, 
	                          { t | TriggerSet(plc, NULL),    t = BaseType(NULL);
							        TriggerSet(plc, NEW),     t = BaseType(ANY);
									TriggerSet(plc, HALT),    t = BaseType(ANY);
									TriggerSet(plc, EXIT),    t = BaseType(ANY);
									TriggerSet(plc, e), EventDecl(e, _, t), t : TypeExpr;
									TriggerSet(plc, e), EventDecl(e, _, NIL), t = BaseType(NULL) }).

   //// Compute the joins of sub-lists
   CompTypeJoins(tail) :- CompTypeJoins(TypeJoinList(_, tail)).

   //// To compute the join of a longer list, must compute the binary join of head and joined sub-list.
   CompTypeJoin(hd, tj) :- CompTypeJoins(list), list = TypeJoinList(hd, tl), TypeJoins(tl, tj), tl : TypeJoinList.
   
   //// Once the binary join of head and tail are known, then the join of the list is known.   
   TypeJoins(list, j) :- CompTypeJoins(list), list = TypeJoinList(hd, tl), TypeJoins(tl, tj), TypeJoin(hd, tj, j), tl : TypeJoinList, j : TypeExpr.

   //// The join of a singleton list is the type in the list. 
   TypeJoins(list, t) :- CompTypeJoins(list), list = TypeJoinList(t, NIL).

   //// The join of the empty list is, by definition, the null type.
   TypeJoins(NIL, BaseType(NULL)).

   /*************************************************************/
   /*                      Binary type joins                    */
   /*************************************************************/	

    CompTypeJoin(ta', tb')                     :- CompTypeJoin(ta, tb), ta = SeqType(ta'), tb = SeqType(tb').    
    CompTypeJoin(da, db), CompTypeJoin(ca, cb) :- CompTypeJoin(ta, tb), ta = MapType(da, ca), tb = MapType(db, cb).
    CompTypeJoin(la, lb), CompTypeJoin(ra, rb) :- CompTypeJoin(ta, tb), ta = TupType(la, ra), tb = TupType(lb, rb).
    CompTypeJoin(la, lb), CompTypeJoin(ra, rb) :- CompTypeJoin(ta, tb), ta = NmdTupType(lfa, ra), tb = NmdTupType(lfb, rb), la = lfa.type, lb = lfb.type.

	//// (1) Handle NIL cases.
    TypeJoin(NIL, s, s) :- CompTypeJoin(NIL, s).
    TypeJoin(s, NIL, s) :- CompTypeJoin(s, NIL).

	//// (2) Join is idempotent 
    TypeJoin(s, s, s) :- CompTypeJoin(s, s).

    //// (3) Join of nullable types with null id null   
    TypeJoin(s, t, s) :- CompTypeJoin(s, t), s = BaseType(sk), sk : NullBase, t = BaseType(NULL). 
    TypeJoin(t, s, s) :- CompTypeJoin(t, s), s = BaseType(sk), sk : NullBase, t = BaseType(NULL). 

    //// (4) Join of sequence types. 
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = SeqType(snr), t = SeqType(tnr), TypeJoin(snr, tnr, jnr), j = SeqType(jnr).

    //// (5) Join of map types. 
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeJoin(sd, td, jd), TypeJoin(sc, tc, jc), j = MapType(jd, jc).

    //// (6) Join of tup types. 
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = TupType(sh, st), t = TupType(th, tt), lstLength(#TupType, st) = lstLength(#TupType, tt), 
	                     TypeJoin(sh, th, jh), TypeJoin(st, tt, jt), j = TupType(jh, jt).

    //// (7) Join of named tup types. 
	//// If the tail of the named tuple is NIL, then the named tuple can be joined.
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = NmdTupType(sh, NIL), t = NmdTupType(th, NIL),  
	                     TypeJoin(sh.type, th.type, jh), sh.name = th.name, j = NmdTupType(NmdTupTypeField(sh.name, jh), NIL).

	//// Otherwise, the tail must be joinable to a named tuple for the tuple to be joined
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = NmdTupType(sh, st), t = NmdTupType(th, tt), 
	                     TypeJoin(sh.type, th.type, jh), sh.name = th.name, TypeJoin(st, tt, jt), 
						 st: NmdTupType, tt : NmdTupType, jt : NmdTupType,						 
						 j = NmdTupType(NmdTupTypeField(sh.name, jh), jt).

    //// (8) Remaining cases join to ANY. 
	NonNullAny ::= NonNullBase + { ANY }.

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), toSymbol(s) != toSymbol(t), s : TypeExpr, t : TypeExpr.

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s != t, s = BaseType(sk), t = BaseType(tk), sk != NULL, tk != NULL. 

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s = BaseType(NULL), t = BaseType(tk), tk : NonNullAny. 
    TypeJoin(t, s, BaseType(ANY)) :- CompTypeJoin(t, s), s = BaseType(NULL), t = BaseType(tk), tk : NonNullAny. 

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s : TupType, t : TupType, lstLength(#TupType, s) != lstLength(#TupType, t).

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s : NmdTupType, t : NmdTupType, lstLength(#NmdTupType, s) != lstLength(#NmdTupType, t).
    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s : NmdTupType, t : NmdTupType, s.hd.name != t.hd.name.
    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s = NmdTupType(_, st), t = NmdTupType(_, tt), TypeJoin(st, tt, jt), 
						             st: NmdTupType, tt : NmdTupType, toSymbol(jt) != #NmdTupType.

	/***************************************************************************************************************
	TODO :: static check for map types (this is not done complete)
	****************************************************************************************************************/
	DomOfMapUnSafe ::= (map : MapType).
	ContainsMachOrInterface ::= (type : TypeExpr + {NIL} ).
	ContainsMachOrInterface(type) :- type : TypeExpr, TypeRel(type, BaseType(REAL), SUB);
									 type is MapType(_, k), k : TypeExpr, ContainsMachOrInterface(k);
									 type is SeqType(n), ContainsMachOrInterface(n);
									 type is TupType(hd, tl), ContainsMachOrInterface(hd); 
									 type is TupType(hd, tl), ContainsMachOrInterface(tl);
									 type is NmdTupType(NmdTupTypeField(_, hd), tl), ContainsMachOrInterface(hd); 
									 type is NmdTupType(hd, tl), ContainsMachOrInterface(tl).
									
	
	[rule_Classes = '"error, msg: dom of the map type cannot have machine or interface type"']						    
	DomOfMapUnSafe(map) :- map = MapType(dom, _), dom : TypeExpr, VarDecl(_ , _, map), ContainsMachOrInterface(dom);
						   map = MapType(dom, _), dom : TypeExpr, EventDecl(_ , _, map), ContainsMachOrInterface(dom).
 }