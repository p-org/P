[
   modules.P = '"P at ..\Domains\P.4ml"',
   modules.C = '"C at ..\Domains\C.4ml"'
]

transform P2CProgram (in:: P, outputFileName: String, noSourceInfo: Boolean) returns (out:: C)
/*
[
    compiler_ProductivityCheck = "TypeConstant[0], ExprDepNum[1]"
]
*/
{
    /*************************************************************/
    /**********         Create Header File             ***********/
    /*************************************************************/
    //// Elements will be output to header file in order of position.
    HOut ::= (pos: Natural, cmp: out.Cmp).
    HOutOrder ::= (ord: Natural, cmp: out.Cmp).
	HOutOrder(o, cmp) :- ho is HOut(_, cmp), o = toOrdinal(ho, 0, { ho' | ho' is HOut }). 

    //// Concat elements in order.
	HConcatOut ::= (pos: Integer, cmp: out.Cmp).	
	HConcatOut(-1, NIL).
	HConcatOut(m', cmp) :- HConcatOut(m, before), HOutOrder(m', nxt), m' = m + 1, cmp = Section(before, nxt). 		
		
	out.File(headerFileName, body) :- HConcatOut(count({ho | ho is HOut}) - 1, cmp), 
								      headerFileName = strJoin(%outputFileName, ".h"),
									  ifdefBegin = PpITE(IFDEF, Ident("__cplusplus"), PpEscape(Ident("extern \"C\"{")), NIL),
									  ifdefEnd = PpITE(IFDEF, Ident("__cplusplus"), PpEscape(Ident("}")), NIL),
									  body = PpITE(
									   IFNDEF,
									   Ident("P_PROGRAM_H"),
									   Section(
										   Section(
											  PpDefine(Ident("P_PROGRAM_H"), NIL),
											  Section(
											     PpInclude("PrtUser.h", FALSE),
											     PpInclude("PrtExecution.h", FALSE)											  
											  )),
										   Section(ifdefBegin, Section(cmp, ifdefEnd))),
									   NIL).

    /*************************************************************/
    /**********         Create Code File               ***********/
    /*************************************************************/
    //// Elements will be output to c file in order of position.
    COut ::= (pos: Natural, cmp: out.Cmp).
	COutOrder ::= (ord: Natural, cmp: out.Cmp).

    //// Concat elements in order.
	COutOrder(o, cmp) :- co is COut(_, cmp), o = toOrdinal(co, 0, { co' | co' is COut }). 
	CConcatOut ::= (pos: Integer, cmp: out.Cmp).	
	CConcatOut(-1, NIL).
	CConcatOut(m', cmp) :- CConcatOut(m, before), COutOrder(m', nxt), m' = m + 1, cmp = Section(before, nxt). 		
		
	out.File(codeFileName, body) :- CConcatOut(count({co | co is COut}) - 1, cmp),
	                               headerFileName = strJoin(%outputFileName, ".h"),
								   codeFileName = strJoin(%outputFileName, ".c"),
								   body = Section(PpInclude(headerFileName, FALSE), cmp).

    /*************************************************************/
    /**********         Create Stubs File              ***********/
    /*************************************************************/
	SOut ::= (cmp: out.Cmp).
	SOutOrder ::= (ord: Natural, cmp: out.Cmp).
	SConcatOut ::= (pos: Integer, cmp: out.Cmp).	

	SConcatOut(-1, NIL).
	SOutOrder(o, cmp) :- so is SOut(cmp), o = toOrdinal(so, 0, { so' | so' is SOut }). 
	SConcatOut(m', cmp) :- SConcatOut(m, before), SOutOrder(m', nxt), m' = m + 1, cmp = Section(before, nxt).
	
	SOut(def') :- HOut(10, def), def = FunDef(a, b, c, d, _), def' = FunDef(a, b, c, d, NIL).
	out.File("stubs.c", body) :- SConcatOut(count({so | so is SOut}) - 1, cmp), 
								 body = PpITE(
									   IFNDEF,
									   Ident("P_PROGRAM_H"),
									   Section(
										   Section(
											  PpDefine(Ident("P_PROGRAM_H"), NIL),
											  Section(
											     PpInclude("PrtUser.h", FALSE),
											     PpInclude("PrtExecution.h", FALSE)											  
											  )),
										   cmp),
									   NIL).
								   
    /*************************************************************/
    /**********     Create C Enums for P Decls         ***********/
    /*************************************************************/
	EventDeclExt ::= EventDecl + { NULL, HALT }.
	DeclId ::= (decl: PDecl + TypeDef + { NULL, HALT, PUSH }, id: Natural, cname: String).
	
	//// (0.0) Foreign types
	DeclId(d, id, cn) :- d is TypeDef(name, _), ModelType(name), id = toOrdinal(d, 0, { d' | d' is TypeDef(n, _), ModelType(n) }), cn = strJoin("P_FORGN_TYPE_", name).
	HOut(0, out.EnmDef(NIL, "P_FORGN_TYPES", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : TypeDef, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_FORGN_TYPES_COUNT"), size = count({d | d is TypeDef(n, _), ModelType(n)}) }).  
	
	//// (0.1) Field names for named tuple types that have a type synonym
	HOut(0, out.EnmDef(NIL, enumName, list)) :- 
	   d is TypeDef(name, type), type: NmdTupType, TypeExpansion(type, etype), enumName = strJoin("P_FIELD_INDEX_", name),
	   list = toList(#Elements, NIL, { enumMember | 
									   IndexOf(etype, f, offset, _), cn = strJoin(strJoin(enumName, "_"), f), enumMember = Element(IntLit(offset, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), strJoin(strJoin("_", enumName), "_COUNT")), size = lstLength(#NmdTupType, etype) }).  

	//// (1) EventDecls - Id 0, 1 are reserved for null, halt event, which can appear in transition tables.
	DeclId(NULL, 0, "_P_EVENT_NULL").
	DeclId(HALT, 1, "_P_EVENT_HALT").
	DeclId(d, id, cn) :- d is EventDecl, id = 2 + toOrdinal(d, 0, { d' | d' is EventDecl }), cn = strJoin("P_EVENT_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_EVENTS", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : EventDeclExt, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_EVENTS_COUNT"), size = 2 + count({d | d is EventDecl}) }).  

	//// (2) Real machine decls - Start at Id 0.
	DeclId(d, id, cn) :- d is MachineDecl, d.kind = REAL, 
	                     id = toOrdinal(d, 0, { d' | d' is MachineDecl, d'.kind = REAL }), cn = strJoin("P_MACHINE_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_MACHINES", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : MachineDecl, d.kind = REAL, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   DeclId(d, id, _), d : MachineDecl, d.kind = REAL, d.isMain = TRUE, enumMember = Element(IntLit(id, DEC, NIL), "_P_MACHINE_MAIN"); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_MACHINES_COUNT"), size = count({d | d is MachineDecl, d.kind = REAL}) }).  

	//// (3) Model machine decls - Start at Id 0.
	DeclId(d, id, cn) :- d is MachineDecl, d.kind = MODEL, 
	                     id = toOrdinal(d, 0, { d' | d' is MachineDecl, d'.kind = MODEL }), cn = strJoin("P_MODEL_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_MODELS", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : MachineDecl, d.kind = MODEL, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   DeclId(d, id, _), d : MachineDecl, d.kind = MODEL, d.isMain = TRUE, enumMember = Element(IntLit(id, DEC, NIL), "_P_MACHINE_MAIN"); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_MODELS_COUNT"), size = count({d | d is MachineDecl, d.kind = MODEL}) }).  

	//// (4) VarDecls - Start at Id 0.
	DeclId(d, id, cn) :- d is VarDecl, d.owner.kind = REAL, 
	                     id = toOrdinal(d, 0, { d' | d' is VarDecl, d'.owner = d.owner }), 
						 cn = strJoin("P_VAR_", strJoin(d.owner.name, strJoin("_", d.name))).
	
	HOut(0, out.EnmDef(NIL, enumName, list)) :- 
	   m is MachineDecl,
	   enumName = strJoin("P_VARS_", m.name),
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : VarDecl, d.owner = m, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), strJoin("_P_VARS_", strJoin(m.name, "_COUNT"))), size = count({d | d is VarDecl, d.owner = m}) }).  

	//// (5) (Anon)FunDecls - Start at Id 1. The id 0 is reserved for the PUSH action.
	AnonOrNamedFun ::= FunDecl + AnonFunDecl.

	DeclId(d, id, cn) :- d is AnonFunDecl, d.owner = NIL, AnonFunDeclKind(d, REAL),
	                     num = toOrdinal(d, 0, { d' | d' is AnonFunDecl, d'.owner = NIL, AnonFunDeclKind(d', REAL) }),
	                     id = 1 + num, 
						 cn = strJoin("P_FUN_ANON", toString(num)).

	DeclId(d, id, cn) :- d is FunDecl, d.owner = NIL,
	                     id = 1 + count({ d' | d' is AnonFunDecl, d'.owner = NIL, AnonFunDeclKind(d', REAL) }) 
						        + toOrdinal(d, 0, { d' | d' is FunDecl, d'.owner = NIL }), 
	                     cn = strJoin("P_FUN_", d.name).

	DeclId(d, id, cn) :- d is AnonFunDecl, d.owner.kind = REAL, AnonFunDeclKind(d, REAL),
	                     num = toOrdinal(d, 0, { d' | d' is AnonFunDecl, d'.owner = d.owner, AnonFunDeclKind(d', REAL) }),
	                     id = 1 + count({ d' | d' is AnonFunDecl, d'.owner = NIL, AnonFunDeclKind(d', REAL) }) 
								+ count({ d' | d' is FunDecl, d'.owner = NIL }) 
								+ num, 
						 cn = strJoin("P_FUN_", strJoin(d.owner.name, strJoin("_ANON", toString(num)))).

	DeclId(d, id, cn) :- d is FunDecl, d.owner.kind = REAL,
	                     id = 1 + count({ d' | d' is AnonFunDecl, d'.owner = NIL, AnonFunDeclKind(d', REAL) })
								+ count({ d' | d' is FunDecl, d'.owner = NIL })
						        + count({ d' | d' is AnonFunDecl, d'.owner = d.owner, AnonFunDeclKind(d', REAL) }) 
						        + toOrdinal(d, 0, { d' | d' is FunDecl, d'.owner = d.owner }), 
	                     cn = strJoin("P_FUN_", strJoin(d.owner.name, strJoin("_", d.name))).

	
	HOut(0, out.EnmDef(NIL, "P_FUNS_GLOBAL", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   enumMember = Element(IntLit(0, DEC, NIL), "_P_FUN_PUSH_OR_IGN");
									   DeclId(d, id, cn), d : AnonFunDecl, d.owner = NIL, AnonFunDeclKind(d, REAL), enumMember = Element(IntLit(id, DEC, NIL), cn);
									   DeclId(d, id, cn), d : FunDecl, d.owner = NIL, enumMember = Element(IntLit(id, DEC, NIL), cn) }).  

	HOut(0, out.EnmDef(NIL, enumName, list)) :- 
	   m is MachineDecl, m.kind = REAL,
	   enumName = strJoin("P_FUNS_", m.name),
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : AnonFunDecl, d.owner = m, AnonFunDeclKind(d, REAL), enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   DeclId(d, id, cn), d : FunDecl, d.owner = m, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), strJoin("_P_FUNS_", strJoin(m.name, "_COUNT"))), 
									   size = 1 + count({d | d is AnonFunDecl, d.owner = NIL, AnonFunDeclKind(d, REAL)}) 
												+ count({d | d is FunDecl, d.owner = NIL}) 
									            + count({d | d is AnonFunDecl, d.owner = m, AnonFunDeclKind(d, REAL)}) 
												+ count({d | d is FunDecl, d.owner = m}) }).

	//// (6) StateDecls - Start at Id 0. Need to encode qualified names.
	DeclId(d, id, cn) :- d is StateDecl, d.owner.kind = REAL, 
	                     QualName2CStr(d.name, name), 
					     id = toOrdinal(d, 0, { d' | d' is StateDecl, d'.owner = d.owner }), 
						 cn = strJoin("P_STATE_", strJoin(d.owner.name, strJoin("_", name))).
	
	HOut(0, out.EnmDef(NIL, enumName, list)) :- 
	   m is MachineDecl,
	   enumName = strJoin("P_STATES_", m.name),
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : StateDecl, d.owner = m, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), strJoin("_P_STATES_", strJoin(m.name, "_COUNT"))), size = count({d | d is StateDecl, d.owner = m}) }).  

    /*************************************************************/
    /******               Generate Helper Macros            ******/
    /*************************************************************/	

	//// Args lists of the form (xn, ..., x0)
	MacroArgList ::= (args: out.Args, len: Natural, aux: Natural).
	MacroArgList(args, 0, m) :- m = max(
	                                  maxAll(0, { k | RhsEvalOrder(_, _, _, k) }),
									max(
									  maxAll(0, { k | TypeOf(_, _, t), t : TupType, k = lstLength(#TupType, t) - 1 }),
									max(
									  maxAll(0, { k | TypeOf(_, _, t), t : NmdTupType, k = lstLength(#NmdTupType, t) - 1 }),
									max(
									  maxAll(0, { k | StmtExprSize(_, k'), k = k' - 1 }),
									max(
									  maxAll(0, { k | FunStmtRhs(_, _, k, _) }),
									  2))))),									  
	                            m : Natural, 
								args = out.Args(Ident("x0"), Args(Ident("f0"), NIL)).
	MacroArgList(args, i, j) :- MacroArgList(tl, i', j'), i = i' + 1, j = j' - 1, j : Natural, 
								args = out.Args(Ident(strJoin("x", toString(i))), Args(Ident(strJoin("f", toString(i))), tl)). 

	TupleMacroArgList ::= (args: out.Args, len: Natural, aux: Natural).
	TupleMacroArgList(args, 0, m) :- m = max(
	                                  maxAll(0, { k | RhsEvalOrder(_, _, _, k) }),
									max(
									  maxAll(0, { k | TypeOf(_, _, t), t : TupType, k = lstLength(#TupType, t) - 1 }),
									max(
									  maxAll(0, { k | TypeOf(_, _, t), t : NmdTupType, k = lstLength(#NmdTupType, t) - 1 }),
									max(
									  maxAll(0, { k | StmtExprSize(_, k'), k = k' - 1 }),
									max(
									  maxAll(0, { k | FunStmtRhs(_, _, k, _) }),
									  2))))),									  
									 m : Natural, 
									 args = out.Args(Ident("x0"), NIL).
	TupleMacroArgList(args, i, j) :- TupleMacroArgList(tl, i', j'), i = i' + 1, j = j' - 1, j : Natural, 
									 args = out.Args(Ident(strJoin("x", toString(i))), tl). 

	//// Generate the bodies for P_EXPR_n
	PExprBodyArgs ::= (args: out.Args, size: Natural, freeNum: Integer, asnNum: Integer).

	PExprBodyArgs(a, n, n', n) :- RhsMaxOrder(_, _, n), a = out.Args(Ident(strJoin("p_tmp_expr_", toString(n))), NIL), n' = n - 1.

	PExprBodyArgs(a, n, n', n) :- FunStmtRhs(_, _, n, _), a = out.Args(Ident(strJoin("p_tmp_expr_", toString(n))), NIL), n' = n - 1.

	PExprBodyArgs(a, n, i', n) :- PExprBodyArgs(tl, n, i, n), i : Natural, i' = i - 1, a = out.Args(condFree, tl), 
							      free = out.FunApp(Ident("PrtFreeValue"), Args(Ident(strJoin("p_tmp_expr_", toString(i))), NIL)),
								  condFree = out.Paren(TerApp(TCOND, Paren(Ident(strJoin("f", toString(i)))), free, IntLit(0, DEC, U))).

	PExprBodyArgs(a, n, -1, i') :- PExprBodyArgs(tl, n, -1, i), i : Natural, i' = i - 1, a = out.Args(asn, tl), 
							      asn = out.BinApp(ASN, Ident(strJoin("p_tmp_expr_", toString(i))), Paren(Ident(strJoin("x", toString(i))))).

	//// Generate the bodies for P_STMT_n
	PStmtBodyArgs ::= (args: out.Args, size: Natural, freeNum: Integer, asnNum: Integer).

	PStmtBodyArgs(a, n, i', n)  :- StmtExprSize(_, n'), n : Natural, n = n' - 1, i' = n' - 2, a = out.Args(condFree, NIL), 
							       free = out.FunApp(Ident("PrtFreeValue"), Args(Ident(strJoin("p_tmp_stmt_", toString(n))), NIL)),
								   condFree = out.Paren(TerApp(TCOND, Paren(Ident(strJoin("f", toString(n)))), free, IntLit(0, DEC, U))).

	PStmtBodyArgs(a, n, i', n)  :- PStmtBodyArgs(tl, n, i, n), i : Natural, i' = i - 1, a = out.Args(condFree, tl), 
							       free = out.FunApp(Ident("PrtFreeValue"), Args(Ident(strJoin("p_tmp_stmt_", toString(i))), NIL)),
								   condFree = out.Paren(TerApp(TCOND, Paren(Ident(strJoin("f", toString(i)))), free, IntLit(0, DEC, U))).

	PStmtBodyArgs(a, n, -2, n)  :- PStmtBodyArgs(tl, n, -1, n), a = out.Args(Paren(Ident("s")), tl).

	PStmtBodyArgs(a, n, -2, i') :- PStmtBodyArgs(tl, n, -2, i), i : Natural, i' = i - 1, a = out.Args(asn, tl), 
							       asn = out.BinApp(ASN, Ident(strJoin("p_tmp_stmt_", toString(i))), Paren(Ident(strJoin("x", toString(i))))).

	//// Generate the bodies for P_TUPLE_n
	PTupleBodyArgs ::= (args: out.Args, size: Natural, asnNum: Integer).

	PTupleBodyArgs(a, n, n)  :- TypeOf(_, _, t), t : TupType, n = lstLength(#TupType, t), a = out.Args(Ident("p_tmp_tuple"), NIL).
	PTupleBodyArgs(a, n, n)  :- TypeOf(_, _, t), t : NmdTupType, n = lstLength(#NmdTupType, t), a = out.Args(Ident("p_tmp_tuple"), NIL).
	PTupleBodyArgs(a, n, i') :- PTupleBodyArgs(tl, n, i), i' : Natural, i' = i - 1, a = out.Args(asn, tl), 
							    asn = out.FunApp(Ident("PrtTupleSet"), Args(Ident("p_tmp_tuple"), Args(IntLit(i', DEC, U), Args(Paren(Ident(strJoin("x", toString(i')))), NIL)))).
	PTupleBodyArgs(a, n, -1) :- PTupleBodyArgs(tl, n, 0), a = out.Args(asn, tl), 
							    asn = out.BinApp(ASN, Ident("p_tmp_tuple"), FunApp(Ident("PrtMkDefaultValue"), Args(Ident("t"), NIL))).

	//// Generate fixed macros
	COut(0, def) :- def = out.PpDefine(Ident("P_SEQ"), NIL). 

	COut(1, def) :- PStmtBodyArgs(bodyArgs, n, -2, -1), MacroArgList(paramArgs, n, _),
	                def = out.PpDefine(
					         FunApp(Ident(strJoin("P_STMT_", toString(n))), Args(Ident("s"), paramArgs)),
					         FunApp(Ident("P_SEQ"), bodyArgs)).

	PBoolExprBodyArgs ::= (out.Args).
	PBoolExprBodyArgs(bodyArgs) :- 
					bodyArgs = out.Args(asn0, Args(asnb, Args(condFree0, Args(retb, NIL)))),
			        asn0 = out.BinApp(ASN, Ident("p_tmp_expr_0"), Paren(Ident("x0"))),
			        asnb = out.BinApp(ASN, Ident("p_tmp_bool"), FunApp(Ident("PrtPrimGetBool"), Args(Ident("p_tmp_expr_0"), NIL))),
			        free0 = out.FunApp(Ident("PrtFreeValue"), Args(Ident("p_tmp_expr_0"), NIL)),
					condFree0 = out.Paren(TerApp(TCOND, Paren(Ident(strJoin("f", toString(0)))), free0, IntLit(0, DEC, U))),
					retb = Ident("p_tmp_bool").
	COut(2, def) :- def = out.PpDefine(
					         FunApp(Ident("P_BOOL_EXPR"), Args(Ident("x0"), Args(Ident("f0"), NIL))),
					         FunApp(Ident("P_SEQ"), bodyArgs)),
					PBoolExprBodyArgs(bodyArgs).
															        
	COut(2, def) :- PExprBodyArgs(bodyArgs, n, -1, -1), MacroArgList(paramArgs, n, _),
	                def = out.PpDefine(
					         FunApp(Ident(strJoin("P_EXPR_", toString(n))), paramArgs),
					         FunApp(Ident("P_SEQ"), bodyArgs)).

	COut(2, def) :- PTupleBodyArgs(bodyArgs, n, -1), n' = n - 1, TupleMacroArgList(paramArgs, n', _), 
	                def = out.PpDefine(
					         FunApp(Ident(strJoin("P_TUPLE_", toString(n'))), Args(Ident("t"), lstReverse(out.#Args, paramArgs))),
					         FunApp(Ident("P_SEQ"), bodyArgs)).

    /*************************************************************/
    /******     Generate C statics for types in program     ******/
    /*************************************************************/
	TranslatedTypeExpr ::= (type: TypeExpr).
	TranslatedTypeExpr(eType) :- TypeExpansion(_, eType).

	//// Labels a type expression with a number greater than the labels of all its sub-expressions.
	//// TypeId linearizes the dependency order to get a schedule for emitting type expressions.
	TypeId      ::= (id: Natural, type: TypeExpr).
	TypeDepNum  ::= (id: Natural, type: TypeExpr).

	TypeDepNum(0, t) :- TranslatedTypeExpr(t), t : in.BaseType.
	TypeDepNum(0, t) :- TranslatedTypeExpr(t), t : in.NameType. 
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = SeqType(t'), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = MapType(t', t''), TypeDepNum(j, t'), TypeDepNum(k, t''),  i = j + k + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = TupType(t', NIL), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = TupType(t', t''), TypeDepNum(j, t'), TypeDepNum(k, t''),  i = j + k + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = NmdTupType(NmdTupTypeField(_, _, t'), NIL), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = NmdTupType(NmdTupTypeField(_, _, t'), t''), TypeDepNum(j, t'), TypeDepNum(k, t''), i = j + k + 1.  
	TypeId(id, t) :- td is TypeDepNum(_, t), id = toOrdinal(td, 0, { td' | td' is TypeDepNum }).

	//// Build type initializers in linearization order.
	//// defs is the definitions that precede the encoding of this type constant.
	TypeConstant ::= (type: TypeExpr + { NIL }, typeExprId: Integer, defs: out.Section + { NIL }).
	TypeConstant(NIL, -1, NIL).

	//// Base types
	BaseType2Kind ::= ({ NULL, BOOL, INT, EVENT, REAL, ANY }, String).
	BaseType2Kind(NULL, "PRT_KIND_NULL").
	BaseType2Kind(BOOL, "PRT_KIND_BOOL").
	BaseType2Kind(INT, "PRT_KIND_INT").
	BaseType2Kind(EVENT, "PRT_KIND_EVENT").
	BaseType2Kind(REAL, "PRT_KIND_MACHINE").
	BaseType2Kind(ANY, "PRT_KIND_ANY").
	
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = in.BaseType(base), BaseType2Kind(base, kind),
								defs = out.Section(before, def),
								def = out.VarDef(NIL, NmdType(NIL, "PRT_TYPE"), typeName, typeStruct),
								typeName = strJoin("P_GEND_TYPE_", toString(m)),
                                typeStruct = out.Init(Args(Ident(kind), Args(Init(Args(Ident("NULL"), NIL)), NIL))).						              
	
	//// Foreign types
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = in.NameType(name), 
								defs = out.Section(before, def),
								def = out.VarDef(NIL, NmdType(NIL, "PRT_TYPE"), typeName, typeStruct),
								typeName = strJoin("P_GEND_TYPE_", toString(m)),
								indexName = strJoin("P_FORGN_TYPE_", name),
                                typeStruct = out.Init(Args(Ident("PRT_KIND_FORGN"), 
								                      Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), Ident(indexName)), NIL)), NIL))).						              
	
	//// Complex type Seq 
	//// (cast to PRT_MAPTYPE * is used to avoid compiler warnings when initializing union)
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = in.SeqType(tinner), TypeConstant(tinner, tinnerid, _),
								              defs = out.Section(Section(before, defSeq), def),
                              defSeq = out.VarDef(
                                     NIL, 
                                     NmdType(NIL, "PRT_SEQTYPE"), 
                                     typeNameSeq, 
                                     Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(tinnerid)))), NIL))),										 
                              def = out.VarDef(
                                     NIL, 
                                     NmdType(NIL, "PRT_TYPE"), 
                                     strJoin("P_GEND_TYPE_", toString(m)), 
                                     typeStruct),
								              typeStruct = out.Init(
										              Args(Ident("PRT_KIND_SEQ"), 
											            Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameSeq))), NIL)), 
											            NIL))),
									            typeNameSeq = strJoin("P_GEND_TYPE_SEQ_", toString(m)). 

	//// Complex type Map 
	TypeConstant(t, m, defs) :- 
	                       TypeId(m, t), TypeConstant(_, m - 1, before), t = in.MapType(tdom, tcod), 
	                       TypeConstant(tdom, domid, _), TypeConstant(tcod, codid, _),
								         defs = out.Section(Section(before, defMap), def),
										     defMap = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_MAPTYPE"), 
														  typeNameMap, 
														  Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(domid)))), 
														       Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(codid)))), 
														       NIL)))),
										      def = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_TYPE"), 
														  strJoin("P_GEND_TYPE_", toString(m)), 
														  typeStruct),
							            typeStruct = out.Init(
										            Args(Ident("PRT_KIND_MAP"), 
											          Args(Init(Args(UnApp(ADDR, Ident(typeNameMap)), NIL)), 
											          NIL))),														  
										      typeNameMap = strJoin("P_GEND_TYPE_MAP_", toString(m)).
	//// Complex type Tuple 
	Tup2ArrayInit ::= (type: TupType, arr: out.Expr). 
	Tup2ArrayInit(t, init) :- TranslatedTypeExpr(t), t = TupType(t', NIL), TypeConstant(t', id', _), init = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), NIL)). 
	Tup2ArrayInit(t, init) :- TranslatedTypeExpr(t), t = TupType(t', t''), TypeConstant(t', id', _), Tup2ArrayInit(t'', Init(ts'')), 
	                          init = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), ts'')). 

	TypeConstant(t, m, defs) :- 
	                       TypeId(m, t), TypeConstant(_, m - 1, before), Tup2ArrayInit(t, arrInit), t : in.TupType, 
								         defs = out.Section(Section(before, Section(defTupArr, defTup)), def),
										     defTupArr = out.VarDef(
										           NIL, 
															 ArrType(PtrType(NmdType(NIL, "PRT_TYPE")), NIL), 
															 typeNameTupArr, 
															 arrInit),
										     defTup = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_TUPTYPE"), 
														  typeNameTup, 
														  Init(
														    Args(IntLit(lstLength(#TupType, t), DEC, NIL), 
															  Args(Ident(typeNameTupArr), 
															  NIL)))),
										     def = out.VarDef(
										         NIL, 
													   NmdType(NIL, "PRT_TYPE"), 
													   strJoin("P_GEND_TYPE_", toString(m)), 
													   typeStruct),
										    typeStruct = out.Init(
													  Args(Ident("PRT_KIND_TUPLE"), 
													  Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameTup))), NIL)),
													  NIL))),
										     typeNameTupArr = strJoin("P_GEND_TYPE_TUP_ARR_", toString(m)),
										     typeNameTup = strJoin("P_GEND_TYPE_TUP_", toString(m)).

	//// Complex type NmdTuple 
	NmdTup2ArrayInit ::= (type: NmdTupType, narr: out.Expr, tarr: out.Expr). 
	NmdTup2ArrayInit(t, narr, tarr) :- TranslatedTypeExpr(t), t = NmdTupType(NmdTupTypeField(_, n', t'), NIL), TypeConstant(t', id', _), 
	                                   tarr = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), NIL)), 
	                                   narr = Init(Args(StringLit(n', NIL), NIL)).
									    
	NmdTup2ArrayInit(t, narr, tarr) :- TranslatedTypeExpr(t), t = NmdTupType(NmdTupTypeField(_, n', t'), t''), TypeConstant(t', id', _), NmdTup2ArrayInit(t'', Init(n''), Init(ts'')), 
	                                   tarr = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), ts'')),
	                                   narr = Init(Args(StringLit(n', NIL), n'')).

	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), NmdTup2ArrayInit(t, narr, tarr), t : in.NmdTupType, 
								     defs = out.Section(before, Section(defNmdTupNArr, Section(defNmdTupTArr, Section(defNmdTup, def)))),
										 defNmdTupNArr = out.VarDef(
										              NIL, 
															    ArrType(NmdType(NIL, "PRT_STRING"), NIL), 
															    typeNameNmdTupNArr, 
															    narr),
										 defNmdTupTArr = out.VarDef(
										              NIL, 
															    ArrType(PtrType(NmdType(NIL, "PRT_TYPE")), NIL), 
															    typeNameNmdTupTArr, 
															    tarr),
										 defNmdTup = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_NMDTUPTYPE"), 
														  typeNameNmdTup, 
														  Init(
														  Args(IntLit(lstLength(#NmdTupType, t), DEC, NIL), 
															Args(Ident(typeNameNmdTupNArr), 
															Args(Ident(typeNameNmdTupTArr), 
															NIL))))),
										 def = out.VarDef(
										         NIL, 
													   NmdType(NIL, "PRT_TYPE"), 
													   strJoin("P_GEND_TYPE_", toString(m)), 
													   typeStatic),
							       typeStatic = out.Init(
										      Args(Ident("PRT_KIND_NMDTUP"), 
											    Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameNmdTup))), NIL)),
											    NIL))),
										 typeNameNmdTupTArr = strJoin("P_GEND_TYPE_NMDTUP_TARR_", toString(m)),
										 typeNameNmdTupNArr = strJoin("P_GEND_TYPE_NMDTUP_NARR_", toString(m)),
										 typeNameNmdTup = strJoin("P_GEND_TYPE_NMDTUP_", toString(m)).

    COut(3, defs) :- TypeConstant(_, c, defs), defs : out.Section, c = count({ td | td is TypeId}) - 1.
    
	/*************************************************************/
    /******   Generate C statics for typedefs in program   ******/
    /*************************************************************/
	TypeDefConstant ::= (typeDefId: Integer, defs: out.Section + { NIL }).
	TypeDefConstant(-1, NIL).

	TypeDefConstant(m, defs) :- typeDef is TypeDef(name, _), m = toOrdinal(typeDef, 0, { typeDef' | typeDef' is TypeDef }),
	                            TypeDefConstant(m - 1, before),  
								typeName = strJoin("P_GEND_TYPE_", name), TypeToExpr(NameType(name), expr),
								def = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, expr),
								defs = out.Section(before, def).
	
	COut(4, defs) :- TypeDefConstant(c, defs), defs : out.Section, c = count({ typeDef | typeDef is TypeDef}) - 1.

	TypeDefExtern ::= (typeDefId: Integer, defs: out.Section + { NIL }).
	TypeDefExtern(-1, NIL).
	
	TypeDefExtern(m, defs) :- typeDef is TypeDef(name, _), m = toOrdinal(typeDef, 0, { typeDef' | typeDef' is TypeDef }),
	                          TypeDefExtern(m - 1, before),
							  defs = out.Section(before, def),
							  def = out.VarDef(EXTERN, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, NIL),
							  typeName = strJoin("P_GEND_TYPE_", name).
	
	HOut(0, defs) :- TypeDefExtern(c, defs), defs : out.Section, c = count({ typeDef | typeDef is TypeDef}) - 1.

    /*************************************************************/
    /******   Generate C statics for constants in program   ******/
    /*************************************************************/

	ConstExpr ::= (e: in.Expr).
	ConstExpr(NulApp(NULL)).
	ConstExpr(NulApp(HALT)).
	ConstExpr(e) :- SubSE(_, e), e = Name(n), eventDecl is EventDecl(n, _, _), DeclId(eventDecl, _, _). 
	ConstExpr(e) :- SubSE(_, e), e = NulApp(op), op: Integer.
	ConstExpr(e) :- SubSE(_, e), e = NulApp(op), op: Boolean.

	ConstId      ::= (id: Natural, const: in.Expr).
	ConstId(id, c) :- ConstExpr(c), id = toOrdinal(c, 0, { c' | ConstExpr(c') }).

	//// Build constant initializers in linearization order.
	//// defs is the definitions that precede the encoding of this type constant.
	Constant ::= (const: in.Expr + { NIL }, constExprId: Integer, defs: out.Section + { NIL }).
	Constant(NIL, -1, NIL).

	//// Base types
	BaseConstant2Kind ::= (const: in.Expr, kind: String, value: out.Expr).
	BaseConstant2Kind(NulApp(NULL), "PRT_VALUE_KIND_NULL", out.Ident("PRT_SPECIAL_EVENT_NULL")).
	BaseConstant2Kind(NulApp(HALT), "PRT_VALUE_KIND_EVENT", out.Ident("PRT_SPECIAL_EVENT_HALT")).
	BaseConstant2Kind(e, "PRT_VALUE_KIND_EVENT", out.Ident(eventName)) :- ConstExpr(e), e = Name(n), eventDecl is EventDecl(n, _, _), DeclId(eventDecl, _, eventName). 
	BaseConstant2Kind(e, "PRT_VALUE_KIND_INT", IntLit(n, DEC, U)) :- ConstExpr(e), e = NulApp(n), n: Integer.
	BaseConstant2Kind(e, "PRT_VALUE_KIND_BOOL", out.Ident("PRT_FALSE")) :- ConstExpr(e), e = NulApp(FALSE).
	BaseConstant2Kind(e, "PRT_VALUE_KIND_BOOL", out.Ident("PRT_TRUE")) :- ConstExpr(e), e = NulApp(TRUE).

	Constant(c, m, defs) :- ConstId(m, c), Constant(_, m - 1, before), BaseConstant2Kind(c, kind, value),
							defs = out.Section(before, def), def = out.VarDef(NIL, NmdType(NIL, "PRT_VALUE"), constName, constStruct),
							constName = strJoin("P_GEND_VALUE_", toString(m)), constStruct = out.Init(Args(Ident(kind), Args(Init(Args(value, NIL)), NIL))).						              

    COut(4, defs) :- Constant(_, c, defs), defs : out.Section, c = count({ x | x is ConstId}) - 1.


	/*************************************************************/
    /******            Generate event decls                 ******/
    /*************************************************************/	
	EvDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	EvDecl2PayloadType ::= (EventDecl, out.Expr).
	//// An EventDecl without a payload type has a null payload type.
	EvDecl2PayloadType(d, expr) :- d is EventDecl(_, _, NIL), TypeToExpr(in.BaseType(NULL), expr).
	//// An EventDecl with a payload type refers to one of the statically generated types.
	EvDecl2PayloadType(d, expr) :- d is EventDecl(_, _, type), type : in.TypeExpr, TypeToExpr(type, expr).

	EvDecl2EvCard      ::= (EventDecl, out.Expr).
	//// An EventDecl without a queue constraint allows 2^32 - 1 events in a queue.
	EvDecl2EvCard(d, e) :- d is EventDecl(_, NIL, _), e = IntLit(4294967295, DEC, U).
	//// An EventDecl with a payload type refers to one of the statically generated types.
	EvDecl2EvCard(d, e) :- d is EventDecl(_, card, _), e = IntLit(card.bound, DEC, U).

	//// Base case
	EvDeclConcat(c, NIL) :- c = count({d | d is EventDecl}) + 2.

    //// Build event array in reverse order
	EvDeclConcat(m, arr) :- DeclId(d, m, cn), EvDeclConcat(m + 1, after), arr = out.Args(def, after), EvDecl2PayloadType(d, expr), EvDecl2EvCard(d, card), 
	                        def = Init(
							   Args(Ident(cn),
							   Args(StringLit(d.name, NIL),
							   Args(card,
							   Args(expr,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	//// Define the halt event
	EvDeclConcat(1, arr) :- EvDeclConcat(2, after), arr = out.Args(def, after), TypeConstant(in.BaseType(ANY), typeId, _),
	                        def = Init(
							   Args(Ident("_P_EVENT_HALT"),
							   Args(StringLit("halt", NIL),
							   Args(IntLit(4294967295, DEC, U),
							   Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeId)))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	//// Define the default event
	EvDeclConcat(0, arr) :- EvDeclConcat(1, after), arr = out.Args(def, after), TypeConstant(in.BaseType(NULL), typeId, _),
	                        def = Init(
							   Args(Ident("_P_EVENT_NULL"),
							   Args(StringLit("null", NIL),
							   Args(IntLit(0, DEC, U),
							   Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeId)))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

    //// Emit the event decl array.
	COut(4, def) :- EvDeclConcat(0, arr), 
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_EVENTDECL"), NIL), 
								  "P_GEND_EVENTS", 
								  Init(arr)).

    /*************************************************************/
    /******            Generate Variable Decl Arrays        ******/
    /*************************************************************/	
	VarDeclConcat ::= (pos: Natural, mach: MachineDecl, arr: out.Args + {NIL}).

	//// Base case
	VarDeclConcat(c, m, NIL) :- m is MachineDecl, m.kind = REAL, c = count({v | v is VarDecl, v.owner = m}).

    //// Build every variable array in reverse order
	VarDeclConcat(m, d.owner, arr) :- 
							DeclId(d, m, cvar), DeclId(d.owner, _, cmach), VarDeclConcat(m + 1, d.owner, after), 
							d : VarDecl, TypeToExpr(d.type, expr),
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cvar),
							   Args(Ident(cmach),
							   Args(StringLit(d.name, NIL),
							   Args(expr,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	COut(5, def) :- VarDeclConcat(0, mach, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_VARDECL"), NIL), 
								  strJoin("P_GEND_VARS_", mach.name), 
								  Init(arr)).

    /*************************************************************/
    /******          Generate Transition Decl Arrays        ******/
    /*************************************************************/	
	TransDeclConcat ::= (pos: Natural, context: StateDecl, arr: out.Args + {NIL}).
	TransDeclId     ::= (decl: TransDecl, id: Natural, srcName: String, dstName: String, machName: String).

	//// Transition Id also contains source, destination, and owner machine ids
	TransDeclId(t, id, srcname, dstname, machname) :- 
	                t is TransDecl, 
					t.src.owner.kind = REAL,
					id = toOrdinal(t, 0, { t' | t' is TransDecl, t'.src = t.src }),
					DeclId(t.src, _, srcname), 
					DeclId(t.src.owner, _, machname),
					DeclId(dst, _, dstname), dst is StateDecl, dst.owner = t.src.owner, dst.name = t.dst.

    //// Transition event Id depends on whether the transition is a user event, default, or halt.
    TransDeclEvnt  ::= (decl: TransDecl, evName: String, id: Natural).
	NullOrHalt     ::= { NULL, HALT }.
	TransDeclEvnt(t, evname, id) :- t is TransDecl, t.src.owner.kind = REAL, ev is EventDecl, ev.name = t.trig, DeclId(ev, id, evname).
	TransDeclEvnt(t, evname, id) :- t is TransDecl, t.src.owner.kind = REAL, trig = t.trig, trig : NullOrHalt, DeclId(trig, id, evname).

	//// Transition action index depends on whether the transition is a push transition or not.
    TransDeclAction  ::= (decl: TransDecl, funName: String).
	TransDeclAction(t, funname) :- t is TransDecl, t.src.owner.kind = REAL, t.action = PUSH, funname = "_P_FUN_PUSH_OR_IGN". 
	TransDeclAction(t, funname) :- t is TransDecl, t.src.owner.kind = REAL, act = t.action, act : AnonFunDecl, DeclId(act, _, funname). 
	TransDeclAction(t, funname) :- t is TransDecl, t.src.owner.kind = REAL, act = t.action, act : String, f is FunDecl, FunAvailable(f, t.src.owner), f.name = act, DeclId(f, _, funname). 

	//// Base case
	TransDeclConcat(c, s, NIL) :- s is StateDecl, s.owner.kind = REAL, c = count({t | t is TransDecl, t.src = s}).

    //// Build every transition list in reverse order
	TransDeclConcat(m, d.src, arr) :- 
							TransDeclId(d, m, srcname, dstname, machname),
							TransDeclEvnt(d, evname, _),
							TransDeclAction(d, funname),
							TransDeclConcat(m + 1, d.src, after), 
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(IntLit(m, DEC, NIL),
							   Args(Ident(srcname),
							   Args(Ident(machname),
							   Args(Ident(evname),
							   Args(Ident(dstname),
							   Args(Ident(funname),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))).

	COut(6, def) :- TransDeclConcat(0, state, arr),
	                QualName2CStr(state.name, statename),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_TRANSDECL"), NIL), 
								  strJoin("P_GEND_TRANS_", strJoin(state.owner.name, strJoin("_", statename))), 
								  Init(arr)).

    /*************************************************************/
    /******             Generate Do Decl Arrays             ******/
    /*************************************************************/	
	DoDeclConcat ::= (pos: Natural, context: StateDecl, arr: out.Args + {NIL}).
	DoDeclId     ::= (decl: DoDecl, id: Natural, srcName: String, machName: String).

	//// DoDeclId Id also contains source and owner machine ids
	DoDeclId(d, id, srcname, machname) :- 
	                d is DoDecl, d.action != DEFER, d.src.owner.kind = REAL,
					id = toOrdinal(d, 0, { d' | d' is DoDecl, d'.src = d.src, d'.action != DEFER }),
					DeclId(d.src, _, srcname), 
					DeclId(d.src.owner, _, machname).

    //// Do event Id depends on whether the do is a user event, default, or halt.
    DoDeclEvnt  ::= (decl: DoDecl, evName: String, id: Natural).
	DoDeclEvnt(d, evname, id) :- d is DoDecl, d.src.owner.kind = REAL, d.action != DEFER, ev is EventDecl, ev.name = d.trig, DeclId(ev, id, evname).
	DoDeclEvnt(d, evname, id) :- d is DoDecl, d.src.owner.kind = REAL, d.action != DEFER, trig = d.trig, trig : NullOrHalt, DeclId(trig, id, evname).

    //// Defer event Id depends on whether the do is a user event, default, or halt.
    DeferEvnt  ::= (decl: DoDecl, evName: String, id: Natural).
	DeferEvnt(d, evname, id) :- d is DoDecl, d.src.owner.kind = REAL, d.action = DEFER, ev is EventDecl, ev.name = d.trig, DeclId(ev, id, evname).
	DeferEvnt(d, evname, id) :- d is DoDecl, d.src.owner.kind = REAL, d.action = DEFER, trig = d.trig, trig : NullOrHalt, DeclId(trig, id, evname).

	//// Do action index depends on whether the do is an ignore or not.
    DoDeclAction  ::= (decl: DoDecl, funName: String).
	DoDeclAction(d, funname) :- d is DoDecl, d.src.owner.kind = REAL, d.action = IGNORE, funname = "_P_FUN_PUSH_OR_IGN". 
	DoDeclAction(d, funname) :- d is DoDecl, d.src.owner.kind = REAL, act = d.action, act : AnonOrNamedFun, DeclId(act, _, funname). 
	DoDeclAction(d, funname) :- d is DoDecl, d.src.owner.kind = REAL, act = d.action, act : String, f is FunDecl, FunAvailable(f, d.src.owner), f.name = act, DeclId(f, _, funname). 

	//// Base case
	DoDeclConcat(c, s, NIL) :- s is StateDecl, s.owner.kind = REAL, c = count({d | d is DoDecl, d.src = s, d.action != DEFER}).

    //// Build every transition list in reverse order
	DoDeclConcat(m, d.src, arr) :- 
							DoDeclId(d, m, srcname, machname),
							DoDeclEvnt(d, evname, _),
							DoDeclAction(d, funname),
							DoDeclConcat(m + 1, d.src, after), 
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(IntLit(m, DEC, NIL),
							   Args(Ident(srcname),
							   Args(Ident(machname),
							   Args(Ident(evname),
							   Args(Ident(funname),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))).

	COut(7, def) :- DoDeclConcat(0, state, arr),
	                QualName2CStr(state.name, statename),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_DODECL"), NIL), 
								  strJoin("P_GEND_DOS_", strJoin(state.owner.name, strJoin("_", statename))), 
								  Init(arr)).

    /*************************************************************/
    /******            Generate Fun Implementations         ******/
    /*************************************************************/	

	ContextTransStmtExpr ::= (TypingContext, out.Stmt + out.Cases + out.Case + out.Args + { NIL }).
	ContextTransStmtExpr(c, body) :- BodyTrans(c, body).
	ContextTransStmtExpr(c, s1), ContextTransStmtExpr(c, s2) :- ContextTransStmtExpr(c, out.Seq(s1, s2)).
	ContextTransStmtExpr(c, s) :- ContextTransStmtExpr(c, out.Block(_, s)).
	ContextTransStmtExpr(c, s) :- ContextTransStmtExpr(c, out.Lbl(_, s)).
	ContextTransStmtExpr(c, e) :- ContextTransStmtExpr(c, out.Return(e)).
	ContextTransStmtExpr(c, e), ContextTransStmtExpr(c, s1), ContextTransStmtExpr(c, s2):- ContextTransStmtExpr(c, out.ITE(e, s1, s2)).
	ContextTransStmtExpr(c, e), ContextTransStmtExpr(c, cases) :- ContextTransStmtExpr(c, out.Switch(e, cases)).
	ContextTransStmtExpr(c, case), ContextTransStmtExpr(c, cases) :- ContextTransStmtExpr(c, out.Cases(case, cases)).
	ContextTransStmtExpr(c, e) :- ContextTransStmtExpr(c, out.Case(e, _)), e: out.Expr.
	ContextTransStmtExpr(c, s) :- ContextTransStmtExpr(c, out.Case(_, s)).
	ContextTransStmtExpr(c, e), ContextTransStmtExpr(c, s) :- ContextTransStmtExpr(c, out.Loop(_, e, s)).
	ContextTransStmtExpr(c, e0), ContextTransStmtExpr(c, e1), ContextTransStmtExpr(c, e2), ContextTransStmtExpr(c, s):- ContextTransStmtExpr(c, out.For(e0, e1, e2, s)).
	ContextTransStmtExpr(c, e) :- ContextTransStmtExpr(c, out.SizeOf(e)), e: out.Expr. 
	ContextTransStmtExpr(c, e) :- ContextTransStmtExpr(c, out.Cast(_, e)). 
	ContextTransStmtExpr(c, e) :- ContextTransStmtExpr(c, out.UnApp(_, e)). 
	ContextTransStmtExpr(c, e0), ContextTransStmtExpr(c, e1) :- ContextTransStmtExpr(c, out.BinApp(_, e0, e1)). 
	ContextTransStmtExpr(c, e0), ContextTransStmtExpr(c, e1), ContextTransStmtExpr(c, e2) :- ContextTransStmtExpr(c, out.TerApp(_, e0, e1, e2)).
	ContextTransStmtExpr(c, e), ContextTransStmtExpr(c, args) :- ContextTransStmtExpr(c, out.FunApp(e, args)). 
	ContextTransStmtExpr(c, e) :- ContextTransStmtExpr(c, out.Paren(e)).
	ContextTransStmtExpr(c, args) :- ContextTransStmtExpr(c, out.Init(args)).
	ContextTransStmtExpr(c, e), ContextTransStmtExpr(c, args) :- ContextTransStmtExpr(c, out.Args(e, args)).
	ContextTransStmtExpr(c, args) :- ContextTransStmtExpr(c, out.FunApp(Ident(name), _)), name = strJoin("P_STMT_", toString(n)), PStmtBodyArgs(args, n, -2, -1).
	ContextTransStmtExpr(c, args) :- ContextTransStmtExpr(c, out.FunApp(Ident(name), _)), name = strJoin("P_EXPR_", toString(n)), PExprBodyArgs(args, n, -1, -1).
	ContextTransStmtExpr(c, args) :- ContextTransStmtExpr(c, out.FunApp(Ident(name), _)), name = strJoin("P_TUPLE_", toString(n')), PTupleBodyArgs(args, n, -1), n' = n - 1.
	ContextTransStmtExpr(c, args) :- ContextTransStmtExpr(c, out.FunApp(Ident("P_BOOL_EXPR"), _)), PBoolExprBodyArgs(args).

	//// Computes the variable definitions required for function bodies.
	BodyTmpVars ::= (context: TypingContext, nExprVars: Integer, nStmtVars: Integer, defs: out.Defs + { NIL }).
	
	BodyTmpVars(c, nExprs, nStmts, NIL) :- SubSE(c, _), 
	                                       nExprs = maxAll(-1, { k | SubSE(c, s), s : in.Stmt, RhsEvalOrder(s, _, _, k); 
										                             SubSE(c, s), s : in.FunStmt, RhsEvalOrder(s, _, _, k'), k = k' + 1}), nExprs : Integer,
	                                       nStmts = maxAll(0,  { k | SubSE(c, s), s : in.Stmt, StmtExprSize(s, k) }) - 1, nStmts : Integer.

    BodyTmpVars(c, i', n, defs)  :- BodyTmpVars(c, i, n, tl), i : Natural, i' = i - 1, defs = out.Defs(def, tl),
	                                def = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_VALUE")), strJoin("p_tmp_expr_", toString(i)), NIL).

    BodyTmpVars(c, -1, i', defs) :- BodyTmpVars(c, -1, i, tl), i : Natural, i' = i - 1, defs = out.Defs(def, tl),
	                                def = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_VALUE")), strJoin("p_tmp_stmt_", toString(i)), NIL).

    BodyTmpVars(c, -1, -2, defs) :- BodyTmpVars(c, -1, -1, tl), defs = out.Defs(defpc, Defs(defb, Defs(defr, Defs(deft, Defs(deff, Defs(frame, tl)))))),
									frame  = out.VarDef(NIL, NmdType(NIL, "PRT_FUNSTACK_INFO"), "p_tmp_frame", NIL),
									deff   = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_VALUE")), "p_tmp_funstmt_ret", NIL),
									deft   = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_VALUE")), "p_tmp_tuple", NIL),
	                                defr   = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_VALUE")), "p_tmp_ret", NIL),
	                                defb   = out.VarDef(NIL, NmdType(NIL, "PRT_BOOLEAN"), "p_tmp_bool", NIL),
									defpc  = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_MACHINEINST_PRIV")), "p_tmp_mach_priv", NIL).

	LocalVarsIter ::= (TypingContext, out.Defs + { NIL }, out.Defs + { NIL }).
	LocalVarsIter(c, tmpVars, NIL) :- BodyTmpVars(c, -1, -2, tmpVars).
	LocalVarsIter(c, tl, tmpVars') :- LocalVarsIter(c, out.Defs(tmpVar, tl), tl'), tmpVars' = out.Defs(tmpVar, tl').
	LocalVarsTable ::= (TypingContext, out.VarDef).
	LocalVarsTable(c, tmpVar) :- LocalVarsIter(c, out.Defs(tmpVar, tl), _), tmpVar: out.VarDef.

	COut(7, def) :- DeclId(f, id, name), id > 0, f : FunDecl, f.kind = REAL, RealOwner(f),
	                params = Params(Param(NIL, "context"), NIL),
				    funType = FunType(PtrType(NmdType(NIL, "PRT_VALUE")), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_MACHINEINST")), NIL),
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin(name, "_IMPL"),
					  params,
					  UNKNOWN).

	PatchReturn ::= (f: in.FunDecl + in.AnonFunDecl, e: out.Stmt).
	PatchReturn(f, cs) :- DeclId(f, _, _), f: AnonFunDecl, cs = out.Return(Ident("p_tmp_ret")).
	PatchReturn(f, cs) :- DeclId(f, _, _), f = FunDecl(_, _, _, _, NIL, _, _), cs = out.Return(Ident("p_tmp_ret")).
	PatchReturn(f, cs) :- DeclId(f, _, _), f = FunDecl(_, _, _, _, type, _, _), type : TypeExpr, ParamsType(f, expr),  
						  cs = out.ITE(BinApp(EQ, Ident("p_tmp_ret"), Ident("NULL")), 
									   Return(FunApp(Ident("PrtMkDefaultValue"), Args(expr, NIL))),
									   Return(Ident("p_tmp_ret"))).

	ContextSourceInfo ::= (TypingContext, out.Stmt, out.Stmt, out.Stmt).
	ContextSourceInfo(f, NIL, NIL, NIL) :- in.FileInfo(f, NIL); 
										   in.FileInfo(f, _), %noSourceInfo = TRUE. 
	ContextSourceInfo(f, entryInfo, info, exitInfo) :- 
					%noSourceInfo = FALSE, in.FileInfo(f, srcFileName), in.LineInfo(f, ENTRY, entry), in.LineInfo(f, EXIT, exit),
					entryInfo = out.PpLine(entry, srcFileName), info = out.PpLine(entry, NIL), exitInfo = out.PpLine(exit, NIL).

	ContextLineInfo ::= (TypingContext, in.Stmt, out.Stmt).
	ContextLineInfo(f, s, NIL) :- SubSE(f, s), s: in.Stmt, %noSourceInfo = TRUE.
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.NewStmt(_, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.Raise(_, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.Send(_, _, _, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.Monitor(_, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.FunStmt(_, _, _, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.NulStmt(_, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.BinStmt(_, _, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.Return(_, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.While(_, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.Ite(_, _, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.Receive(_, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.Assert(_, _, x), info = out.PpLine(x.line, NIL).
	ContextLineInfo(f, s, info) :- SubSE(f, s), %noSourceInfo = FALSE, s = in.Print(_, x), info = out.PpLine(x.line, NIL).
	
	BodyTrans ::= (TypingContext, out.Stmt).
	BodyTrans(f, body) :- 
				    StmtTrans(f, f.body, ctrans),
					header = out.Seq(Seq(info, BinApp(ASN, Ident("p_tmp_mach_priv"), Cast(PtrType(NmdType(NIL, "PRT_MACHINEINST_PRIV")), Ident("context")))), 
					             Seq(Seq(info, BinApp(ASN, Ident("p_tmp_ret"), Ident("NULL"))), 
								     Seq(info, FunApp(Ident("PrtPopFrame"), Args(Ident("p_tmp_mach_priv"), Args(UnApp(ADDR, Ident("p_tmp_frame")), NIL)))))),
					Trampoline(f, f.body, trampoline),
					PatchReturn(f, patchReturn),
					footer = out.Seq(Goto("P_EXIT_FUN"),
					                 Lbl("P_EXIT_FUN", 
					                   Seq(
									     Seq(exitInfo, FunApp(Ident("PrtFreeLocals"), Args(Ident("p_tmp_mach_priv"), Args(UnApp(ADDR, Ident("p_tmp_frame")), NIL)))),
									     Seq(exitInfo, patchReturn)))),
					ContextSourceInfo(f, _, info, exitInfo),
					body = out.Seq(header, Seq(trampoline, Seq(ctrans, footer))).
				
	COut(8, def) :- DeclId(f, id, name), id > 0, f : FunDecl, f.kind = REAL, RealOwner(f),
				    tmpVars = toList(#Defs, NIL, { varDef | LocalVarsTable(f, varDef), ContextTransStmtExpr(f, out.Ident(varDef.name)) }),
	                params = Params(Param(NIL, "context"), NIL),
				    funType = FunType(PtrType(NmdType(NIL, "PRT_VALUE")), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_MACHINEINST")), NIL),
					ContextSourceInfo(f, entryInfo, _, _),
					BodyTrans(f, body),
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin(name, "_IMPL"),
					  params,
					  out.Seq(entryInfo, Block(tmpVars, body))).

	COut(8, def) :- DeclId(f, id, name), id > 0, AnonFunDeclKind(f, REAL),
					tmpVars = toList(#Defs, NIL, { varDef | LocalVarsTable(f, varDef), ContextTransStmtExpr(f, out.Ident(varDef.name)) }),
	                params = Params(Param(NIL, "context"), NIL),
				    funType = FunType(PtrType(NmdType(NIL, "PRT_VALUE")), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_MACHINEINST")), NIL),
					ContextSourceInfo(f, entryInfo, _, _),
					BodyTrans(f, body),
	                def = FunDef(
					  STATIC,
					  funType,
					  strJoin(name, "_IMPL"),
					  params,
					  out.Seq(entryInfo, Block(tmpVars, body))).

	HOut(1, def) :- DeclId(f, id, name), id > 0, f : FunDecl, f.kind = MODEL, RealOwner(f),
	                params = Params(Param(NIL, "context"), NIL),
				    funType = FunType(PtrType(NmdType(NIL, "PRT_VALUE")), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_MACHINEINST")), NIL),
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin(name, "_IMPL"),
					  params,
					  UNKNOWN).
				
    /*************************************************************/
    /******         Generate EventSet Decl Arrays           ******/
    /*************************************************************/	
	EventPackList ::= (dat: EventPackData, tl: EventPackList + { NIL }).
	EventPackData ::= (arrIndex: Natural, events: Natural). 
	EventPacking  ::= (list: EventPackList + { NIL }, rem: EventPackList + { NIL }, arrIndex: Natural, packArr: out.Args + { NIL }).
	EventsPacked  ::= (state: StateDecl, cntxt : { #TransDecl, #DoDecl, DEFER }, list: EventPackList + { NIL }).
	ReceiveEventsPacked ::= (c: TypingContext, receive: Receive, list: EventPackList + { NIL }).

	ReceivedId ::= (c: TypingContext, receive: Receive, id: Natural, cases: in.Cases + { NIL }).
	ReceivedId(c, receive, k, cases) :- c is TypingContext, receive: Receive, SubSE(c, receive), 
			  						    receive = Receive(cases', _, _), cases' = in.Cases(e, _, cases), CaseEvent(e, k, _). 
	ReceivedId(c, receive, k, cases) :- c is TypingContext, receive: Receive, SubSE(c, receive), 
									    ReceivedId(c, receive, _, cases'), cases' = in.Cases(e, _, cases), CaseEvent(e, k, _).

	ReceiveEventsPacked(c, receive, rlist),
	EventPacking(rlist, rlist, size, NIL) :- 
		 c is TypingContext, receive: Receive, SubSE(c, receive),
		 list = toList(
		           #EventPackList, 
				   NIL, 
				   { EventPackData(i, n) | 
				        ReceivedId(c, receive, j, _), i = qtnt(j / 32, 1), 
				        n = sum(0, { m | ReceivedId(c, receive, k, _), i = qtnt(k / 32, 1), PowOf2(k % 32, m) }), n : Natural 
	               }),
		 rlist = lstReverse(#EventPackList, list),
		 highestEventIndex = 1 + count({decl | decl is EventDecl}), size = 1 + qtnt(highestEventIndex / 32, 1), size: Natural.

	//// Generate event sets for transitions
	EventsPacked(s, #TransDecl, rlist),
	EventPacking(rlist, rlist, size, NIL) :- 
	     s is StateDecl, s.owner.kind = REAL, 
	     list = toList(
		           #EventPackList, 
				   NIL, 
				   { EventPackData(i, n) | 
				        TransDeclEvnt(t, _, j), t.src = s, i = qtnt(j / 32, 1), 
				        n = sum(0, { m | TransDeclEvnt(t', _, k), t'.src = s, i = qtnt(k / 32, 1), PowOf2(k % 32, m) }), n : Natural 
	               }),
		 rlist = lstReverse(#EventPackList, list),
		 highestEventIndex = 1 + count({decl | decl is EventDecl}), size = 1 + qtnt(highestEventIndex / 32, 1), size: Natural.

	//// Generate event sets for non-defer do's
	EventsPacked(s, #DoDecl, rlist),
	EventPacking(rlist, rlist, size, NIL) :- 
	     s is StateDecl, s.owner.kind = REAL, 
	     list = toList(
		           #EventPackList, 
				   NIL, 
				   { EventPackData(i, n) | 
				        DoDeclEvnt(d, _, j), d.action != DEFER, d.src = s, i = qtnt(j / 32, 1), 
				        n = sum(0, { m | DoDeclEvnt(d', _, k), d'.action != DEFER, d'.src = s, i = qtnt(k / 32, 1), PowOf2(k % 32, m) }), n : Natural 
	               }),
		 rlist = lstReverse(#EventPackList, list),
		 highestEventIndex = 1 + count({decl | decl is EventDecl}), size = 1 + qtnt(highestEventIndex / 32, 1), size: Natural.

	//// Generate event sets for defer do's
	EventsPacked(s, DEFER, rlist),
	EventPacking(rlist, rlist, size, NIL) :- 
	     s is StateDecl, s.owner.kind = REAL, 
	     list = toList(
		           #EventPackList, 
				   NIL, 
				   { EventPackData(i, n) | 
				        DeferEvnt(d, _, j), d.action = DEFER, d.src = s, i = qtnt(j / 32, 1), 
				        n = sum(0, { m | DeferEvnt(d', _, k), d'.action = DEFER, d'.src = s, i = qtnt(k / 32, 1), PowOf2(k % 32, m) }), n : Natural 
	               }),
		 rlist = lstReverse(#EventPackList, list),
		 highestEventIndex = 1 + count({decl | decl is EventDecl}), size = 1 + qtnt(highestEventIndex / 32, 1), size: Natural.

    //// Build up pack array.
	EventPacking(l, NIL,  i',  a') :- EventPacking(l, NIL, i, a), i > 0, i' = i - 1, i' : Natural, a' = Args(IntLit(0, HEX, U), a).
	EventPacking(l, r, i',  a') :- EventPacking(l, r,   i, a), i > 0, i' = i - 1, i' : Natural, r.dat.arrIndex < i', a' = Args(IntLit(0, HEX, U), a).
	EventPacking(l, r.tl, i',  a') :- EventPacking(l, r,   i, a), i > 0, i' = i - 1, i' : Natural, r.dat.arrIndex = i', a' = Args(IntLit(r.dat.events, HEX, U), a).

	COut(9, def) :- EventPacking(l, _, 0, a),
	                id = toOrdinal(l, 0, { l' | EventPacking(l', _, 0, _) }),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_UINT32"), NIL), 
								  strJoin("P_GEND_EVENTSET_", toString(id)), 
								  Init(a)).

    //// Build up event sets.
	EvSetDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	//// Base case
	EvSetDeclConcat(c, NIL) :- c = count({l | EventPacking(l, _, 0, _) }).

    //// Build every event set array in reverse order
	EvSetDeclConcat(m, arr) :- 
	                        EventPacking(l, _, _, NIL),
	                        m = toOrdinal(l, 0, { l' | EventPacking(l', _, 0, _) }),
							EvSetDeclConcat(m + 1, after),							  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(IntLit(m, DEC, NIL),
							   Args(Ident(strJoin("P_GEND_EVENTSET_", toString(m))),
							   NIL))).

	COut(10, def) :- EvSetDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_EVENTSETDECL"), NIL), 
								  "P_GEND_EVENTSETS", 
								  Init(arr)).

    /*************************************************************/
    /******            Generate Fun Decl Arrays             ******/
    /*************************************************************/	
	TypeToExpr ::= (type: TypeExpr, expr: out.Expr).
	TypeToExpr(type, expr) :- TypeExpansion(type, etype), TypeId(typeIndex, etype), 
	                          typeName = strJoin("P_GEND_TYPE_", toString(typeIndex)), 
							  expr = out.UnApp(ADDR, Ident(typeName)).

	ParamsType ::= (decl: FunDecl, expr: out.Expr).
	ParamsType(d, expr) :- d is FunDecl, d.params = NIL, expr = out.Ident("NULL").
	ParamsType(d, expr) :- d is FunDecl, TypeToExpr(d.params, expr).

	LocalsType ::= (decl: AnonOrNamedFun, expr: out.Expr).
	LocalsType(d, expr) :- d is AnonOrNamedFun, d.locals = NIL, expr = out.Ident("NULL").
	LocalsType(d, expr) :- d is AnonOrNamedFun, TypeToExpr(d.locals, expr).

	CaseEvent ::= (trig: String + { NULL, HALT }, id: Natural, name: String).
	CaseEvent(trig, id, name) :- trig : String, ev is EventDecl, ev.name = trig, DeclId(ev, id, name).
	CaseEvent(NULL, id, name) :- DeclId(NULL, id, name).
	CaseEvent(HALT, id, name) :- DeclId(HALT, id, name).

	CaseDeclConcat ::= (pos: Natural, decl: AnonOrNamedFun, cases: in.Cases + { NIL }, arr: out.Args + { NIL }).
	CaseDeclConcat(0, decl, NIL, NIL) :- decl is AnonOrNamedFun.
	CaseDeclConcat(c, decl, cases, arr) :- SubSE(decl, cases), cases = in.Cases(trig, act, cases'), CaseDeclConcat(c', decl, cases', arr'),
										   CaseEvent(trig, _, eventName), DeclId(act, funIndex, _),
										   def = out.Init(Args(Ident(eventName), Args(IntLit(funIndex, DEC, U), NIL))),
										   arr = out.Args(def, arr'), c = c' + 1.

	COut(9, def) :- decl is AnonOrNamedFun, SubSE(decl, receive), receive = Receive(cases, label, _),
					CaseDeclConcat(nCases, decl, cases, arr), DeclId(decl, _, declName),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_CASEDECL"), NIL), 
								  strJoin("P_GEND_CASES_", toString(label)), 
								  Init(arr)).

	ReceiveDeclConcat ::= (pos: Natural, decl: AnonOrNamedFun, arr: out.Args + { NIL }).
	ReceiveDeclConcat(c, decl, NIL) :- decl is AnonOrNamedFun, SubSE(decl, _), c = count({r | r: Receive, SubSE(decl, r)}).
	ReceiveDeclConcat(c, decl, arr) :- decl is AnonOrNamedFun, SubSE(decl, receive), receive = Receive(cases, label, _),
									   c = toOrdinal(receive, 0, {r | r: Receive, SubSE(decl, r)}), 
									   ReceiveDeclConcat(c + 1, decl, arr'), arr = out.Args(def, arr'),
									   CaseDeclConcat(nCases, decl, cases, casesInit), DeclId(decl, _, declName),
									   ReceiveEventsPacked(decl, receive, rlist),
									   index = toOrdinal(rlist, 0, { l | EventPacking(l, _, 0, _) }), 
									   def = out.Init(
												Args(IntLit(label, DEC, U),
												Args(IntLit(index, DEC, U),
												Args(IntLit(nCases, DEC, U),
												Args(Ident(strJoin("P_GEND_CASES_", toString(label))),
												NIL))))).

	COut(10, def) :- decl is AnonOrNamedFun, ReceiveDeclConcat(nReceives, decl, NIL), ReceiveDeclConcat(0, decl, arr), arr: out.Args, 
					 DeclId(decl, _, declName),
	                 def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_RECEIVEDECL"), NIL), 
								  strJoin("P_GEND_RECEIVE_", declName), 
								  Init(arr)).

	ReceiveDeclInit ::= (decl: AnonOrNamedFun, nReceives: Natural, receives: out.Expr).
	ReceiveDeclInit(decl, 0, receives) :- decl is AnonOrNamedFun, ReceiveDeclConcat(0, decl, NIL), receives = Ident("NULL").
	ReceiveDeclInit(decl, 0, receives) :- decl is FunDecl, RealOwner(decl), decl.kind = MODEL, receives = Ident("NULL").
	ReceiveDeclInit(decl, nReceives, receives) :- 
				decl is AnonOrNamedFun, ReceiveDeclConcat(nReceives, decl, NIL), ReceiveDeclConcat(0, decl, arr), arr: out.Args,
				DeclId(decl, _, declName), receives = Ident(strJoin("P_GEND_RECEIVE_", declName)).

	FunDeclConcat ::= (pos: Natural, mach: MachineDecl, arr: out.Args + {NIL}).

	//// Base case
	FunDeclConcat(c, m, NIL) :- m is MachineDecl, m.kind = REAL, 
										  c = 1 + count({d | d is AnonFunDecl, d.owner = NIL, AnonFunDeclKind(d, REAL)}) 
												+ count({d | d is FunDecl, d.owner = NIL}) 
									            + count({d | d is AnonFunDecl, d.owner = m, AnonFunDeclKind(d, REAL)}) 
												+ count({d | d is FunDecl, d.owner = m}).

    //// Build every fundecl array in reverse order
	FunDeclConcat(m, d.owner, arr) :-  
							DeclId(d, m, cfun), DeclId(d.owner, _, cmach), FunDeclConcat(m + 1, d.owner, after), d : FunDecl,
							MaxNumLocals(d, maxNumLocals), 
							LocalsType(d, localsType),
							ReceiveDeclInit(d, nReceives, receives), 
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cfun),
							   Args(Ident(cmach),
							   Args(StringLit(d.name, NIL),
							   Args(UnApp(ADDR, Ident(strJoin(cfun, "_IMPL"))),
							   Args(IntLit(maxNumLocals, DEC, U),
							   Args(IntLit(0, DEC, U),
							   Args(localsType,
							   Args(IntLit(nReceives, DEC, U),
							   Args(receives,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))))))).

	FunDeclConcat(m, d.owner, arr) :- 
							DeclId(d, m, cfun), DeclId(d.owner, _, cmach), FunDeclConcat(m + 1, d.owner, after), d : AnonFunDecl,
							MaxNumLocals(d, maxNumLocals), 
							LocalsType(d, localsType),
							ReceiveDeclInit(d, nReceives, receives),
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cfun),
							   Args(Ident(cmach),
							   Args(Ident("NULL"),
							   Args(UnApp(ADDR, Ident(strJoin(cfun, "_IMPL"))),
							   Args(IntLit(maxNumLocals, DEC, U),
							   Args(IntLit(lstLength(#NmdTupType, d.envVars), DEC, U),
							   Args(localsType,
							   Args(IntLit(nReceives, DEC, U),
							   Args(receives,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))))))).

  	FunDeclConcat(m, mdecl, arr) :-  
							DeclId(d, m, cfun), DeclId(mdecl, _, cmach), FunDeclConcat(m + 1, mdecl, after), d : FunDecl, d.owner = NIL,
							MaxNumLocals(d, maxNumLocals), 
							LocalsType(d, localsType),
							ReceiveDeclInit(d, nReceives, receives), 
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cfun),
							   Args(Ident(cmach),
							   Args(StringLit(d.name, NIL),
							   Args(UnApp(ADDR, Ident(strJoin(cfun, "_IMPL"))),
							   Args(IntLit(maxNumLocals, DEC, U),
							   Args(IntLit(0, DEC, U),
							   Args(localsType,
							   Args(IntLit(nReceives, DEC, U),
							   Args(receives,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))))))).

	FunDeclConcat(m, mdecl, arr) :- 
							DeclId(d, m, cfun), DeclId(mdecl, _, cmach), FunDeclConcat(m + 1, mdecl, after), d : AnonFunDecl, d.owner = NIL,
							MaxNumLocals(d, maxNumLocals), 
							LocalsType(d, localsType),
							ReceiveDeclInit(d, nReceives, receives),
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cfun),
							   Args(Ident(cmach),
							   Args(Ident("NULL"),
							   Args(UnApp(ADDR, Ident(strJoin(cfun, "_IMPL"))),
							   Args(IntLit(maxNumLocals, DEC, U),
							   Args(IntLit(lstLength(#NmdTupType, d.envVars), DEC, U),
							   Args(localsType,
							   Args(IntLit(nReceives, DEC, U),
							   Args(receives,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))))))).

	//// Reserve the zeroth decl for the push transition
	FunDeclConcat(0, m, arr) :- FunDeclConcat(1, m, after), DeclId(m, _, cmach), arr = out.Args(def, after),
	                        def = Init(
							   Args(Ident("_P_FUN_PUSH_OR_IGN"),
							   Args(Ident(cmach),
							   Args(Ident("NULL"),
							   Args(Ident("NULL"),
							   Args(IntLit(0, DEC, U),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))))))).

	COut(11, def) :- FunDeclConcat(0, mach, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_FUNDECL"), NIL), 
								  strJoin("P_GEND_FUNS_", mach.name), 
								  Init(arr)).

    /*************************************************************/
    /******            Generate State Decl Arrays           ******/
    /*************************************************************/	
	StateDeclConcat      ::= (pos: Natural, mach: MachineDecl, arr: out.Args + {NIL}).

	StateEventSetIndices ::= (state: StateDecl, transIndex: Natural, doIndex: Natural, deferIndex: Natural).
	StateEventSetIndices(s, ti, doi, dfi) :- 
	                     s.owner.kind = REAL,
	                     EventsPacked(s, #TransDecl, tlist),
						 ti = toOrdinal(tlist, 0, { l | EventPacking(l, _, 0, _) }), 
	                     EventsPacked(s, #DoDecl, dolist),
						 doi = toOrdinal(dolist, 0, { l | EventPacking(l, _, 0, _) }), 
	                     EventsPacked(s, DEFER, dflist),
						 dfi = toOrdinal(dflist, 0, { l | EventPacking(l, _, 0, _) }).

    StateEntryAction  ::= (decl: StateDecl, funName: String).
	StateEntryAction(s, funname) :- s is StateDecl, s.owner.kind = REAL, act = s.entryAction, act : AnonFunDecl, DeclId(act, _, funname). 
	StateEntryAction(s, funname) :- s is StateDecl, s.owner.kind = REAL, act = s.entryAction, act : String, f is FunDecl, FunAvailable(f, s.owner), f.name = act, DeclId(f, _, funname). 

    StateExitFun  ::= (decl: StateDecl, funName: String).
	StateExitFun(s, funname) :- s is StateDecl, s.owner.kind = REAL, act = s.exitFun, act : AnonFunDecl, DeclId(act, _, funname). 
	StateExitFun(s, funname) :- s is StateDecl, s.owner.kind = REAL, act = s.exitFun, act : String, f is FunDecl, FunAvailable(f, s.owner), f.name = act, DeclId(f, _, funname). 

    StateHandlerArrays ::= (decl: StateDecl, transArrSize: Natural, transArr: out.Ident, doArrSize: Natural, doArr: out.Ident).

	StateHandlerArrays(s, transArrSize, transArr, doArrSize, doArr) :-
		s is StateDecl, s.owner.kind = REAL, 
		transArrSize = 0, transArr = out.Ident("NULL"),
		doArrSize = 0, doArr = out.Ident("NULL"),
		transArrSize = count({ t  | t is TransDecl, t.src = s }),
		doArrSize = count({ do | do is DoDecl, do.src = s, do.action != DEFER }). 

	StateHandlerArrays(s, transArrSize, transArr, doArrSize, doArr) :-
		s is StateDecl, s.owner.kind = REAL,
		QualName2CStr(s.name, sname),
		transArrSize > 0, transArr = out.Ident(strJoin("P_GEND_TRANS_", strJoin(s.owner.name, strJoin("_", sname)))),
		doArrSize = 0, doArr = out.Ident("NULL"),
		transArrSize = count({ t  | t is TransDecl, t.src = s }),
		doArrSize = count({ do | do is DoDecl, do.src = s, do.action != DEFER }). 

	StateHandlerArrays(s, transArrSize, transArr, doArrSize, doArr) :-
		s is StateDecl, s.owner.kind = REAL,
		QualName2CStr(s.name, sname),
		transArrSize = 0, transArr = out.Ident("NULL"),
		doArrSize > 0, doArr = out.Ident(strJoin("P_GEND_DOS_", strJoin(s.owner.name, strJoin("_", sname)))),
		transArrSize = count({ t  | t is TransDecl, t.src = s }),
		doArrSize = count({ do | do is DoDecl, do.src = s, do.action != DEFER }). 

	StateHandlerArrays(s, transArrSize, transArr, doArrSize, doArr) :-
		s is StateDecl, s.owner.kind = REAL,
		QualName2CStr(s.name, sname),
		transArrSize > 0, transArr = out.Ident(strJoin("P_GEND_TRANS_", strJoin(s.owner.name, strJoin("_", sname)))),
		doArrSize > 0, doArr = out.Ident(strJoin("P_GEND_DOS_", strJoin(s.owner.name, strJoin("_", sname)))),
		transArrSize = count({ t | t is TransDecl, t.src = s }),
		doArrSize = count({ do | do is DoDecl, do.src = s, do.action != DEFER }). 
    
	//// Base case
	StateDeclConcat(c, m, NIL) :- m is MachineDecl, m.kind = REAL, c = count({s | s is StateDecl, s.owner = m}).

    //// Build every variable array in reverse order
	StateDeclConcat(m, d.owner, arr) :- 
							DeclId(d, m, cstate), 
							DeclId(d.owner, _, cmach), 
							StateDeclConcat(m + 1, d.owner, after), d : StateDecl, 
							QualName2CStr(d.name, sname),
							StateEventSetIndices(d, ti, doi, dfi),
							StateEntryAction(d, entryname),
							StateExitFun(d, exitname),
							StateHandlerArrays(d, transArrSize, transArr, doArrSize, doArr),
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cstate),
							   Args(Ident(cmach),
							   Args(StringLit(sname, NIL),
							   Args(IntLit(transArrSize, DEC, NIL),
							   Args(IntLit(doArrSize, DEC, NIL),
							   Args(IntLit(dfi, DEC, NIL),
							   Args(IntLit(ti, DEC, NIL),
							   Args(IntLit(doi, DEC, NIL),
							   Args(transArr,
							   Args(doArr,
							   Args(Ident(entryname),
							   Args(Ident(exitname),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))))))).

	COut(12, def) :- StateDeclConcat(0, mach, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_STATEDECL"), NIL), 
								  strJoin("P_GEND_STATES_", mach.name), 
								  Init(arr)).

    /*************************************************************/
    /******          Generate Machine Decl Arrays           ******/
    /*************************************************************/	
	MachineDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	MachVarArr ::= (decl: MachineDecl, size: Natural, arr: out.Ident).
	MachVarArr(m, size, arr) :- m is MachineDecl, m.kind = REAL, 
	                size = 0, arr = out.Ident("NULL"),
	                size = count({ v | v is VarDecl, v.owner = m }).

	MachVarArr(m, size, arr) :- m is MachineDecl, m.kind = REAL, 
	                size > 0, arr = out.Ident(strJoin("P_GEND_VARS_", m.name)),
	                size = count({ v | v is VarDecl, v.owner = m }).

	MachStateArr ::= (decl: MachineDecl, size: Natural, arr: out.Ident).
	MachStateArr(m, size, arr) :- m is MachineDecl, m.kind = REAL, 
	                size > 0, arr = out.Ident(strJoin("P_GEND_STATES_", m.name)),
	                size = count({ s | s is StateDecl, s.owner = m }).

	MachFunArr ::= (decl: MachineDecl, size: Natural, arr: out.Ident).
	MachFunArr(m, size, arr) :- m is MachineDecl, m.kind = REAL, 
	                arr = out.Ident(strJoin("P_GEND_FUNS_", m.name)),
	                size = 1 + count({ f | f is AnonOrNamedFun, f.owner = m }).

	MachQueueSize ::= (decl: MachineDecl, size: Natural).
	MachQueueSize(m, size) :- m is MachineDecl, m.kind = REAL, m.card = NIL, size = 4294967295. 
	MachQueueSize(m, size) :- m is MachineDecl, m.kind = REAL, size = m.card.bound.

	//// Base case
	MachineDeclConcat(c, NIL) :- c = count({m | m is MachineDecl, m.kind = REAL}).

	MachineDeclConcat(m, arr) :- 
							DeclId(d, m, cmach), d.kind = REAL, d : MachineDecl,
							MachineDeclConcat(m + 1, after),  
							MachVarArr(d, varArrSize, varArrName),
							MachStateArr(d, stateArrSize, stateArrName),
							MachFunArr(d, funArrSize, funArrName),
							MachQueueSize(d, queueSize),
							QualName2CStr(d.start, sname),
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cmach),
							   Args(StringLit(d.name, NIL),
							   Args(IntLit(varArrSize, DEC, NIL),
							   Args(IntLit(stateArrSize, DEC, NIL),
							   Args(IntLit(funArrSize, DEC, NIL),
							   Args(IntLit(queueSize, DEC, NIL),
							   Args(Ident(strJoin("P_STATE_", strJoin(d.name, strJoin("_", sname)))),
							   Args(varArrName,
							   Args(stateArrName,
							   Args(funArrName,
							   Args(UnApp(ADDR, Ident(strJoin("P_CTOR_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("P_DTOR_", strJoin(d.name, "_IMPL")))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))))))).

	COut(13, def) :- MachineDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_MACHINEDECL"), NIL), 
								  "P_GEND_MACHINES", 
								  Init(arr)).

	HOut(10, def) :- m is MachineDecl, m.kind = REAL,
	                params = Params(Param(NIL, "context"), 
							 Params(Param(NIL, "value"), NIL)),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_MACHINEINST")),
							   PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")), NIL)),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_CTOR_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(10, def) :- m is MachineDecl, m.kind = REAL,
	                params = Params(Param(NIL, "context"), NIL),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_MACHINEINST")), NIL),
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_DTOR_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

    /*************************************************************/
    /******     Generate Model Machine Decl Arrays          ******/
    /*************************************************************/	
	ModelDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	//// Base case
	ModelDeclConcat(c, NIL) :- c = count({m | m is MachineDecl, m.kind = MODEL}).

	ModelDeclConcat(m, arr) :- 
							DeclId(d, m, cmach), d.kind = MODEL, d : MachineDecl,
							ModelDeclConcat(m + 1, after),  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cmach),
							   Args(StringLit(d.name, NIL),
							   Args(UnApp(ADDR, Ident(strJoin("P_CTOR_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("P_SEND_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("P_DTOR_", strJoin(d.name, "_IMPL")))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))).

	COut(14, def) :- ModelDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_MODELIMPLDECL"), NIL), 
								  "P_GEND_MODELS", 
								  Init(arr)).

	HOut(11, def) :- m is MachineDecl, m.kind = MODEL,
	                params = Params(Param(NIL, "context"), 
							 Params(Param(NIL, "value"), NIL)),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_MACHINEINST")),
							   PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")), NIL)),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_CTOR_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(11, def) :- m is MachineDecl, m.kind = MODEL,
	                params = Params(Param(NIL, "context"), NIL),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_MACHINEINST")), NIL),
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_DTOR_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(11, def) :- m is MachineDecl, m.kind = MODEL,
	                params = Params(Param(NIL, "context"), 
						     Params(Param(NIL, "evnt"), 
							 Params(Param(NIL, "payload"), 
							 Params(Param(NIL, "doTransfer"), NIL)))),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_MACHINEINST")),
					           PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")),
							   PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")), 
							   PrmTypes(NmdType(NIL, "PRT_BOOLEAN"), NIL)))),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_SEND_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

    /*************************************************************/
    /******     Generate foreign type Decl Arrays           ******/
    /*************************************************************/	
	ForeignTypeDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	//// Base case
	ForeignTypeDeclConcat(c, NIL) :- c = count({t | t is TypeDef, ModelType(t.name)}).

	ForeignTypeDeclConcat(m, arr) :- 
							DeclId(d, m, ctype), ModelType(d.name), d : TypeDef, 
							ForeignTypeDeclConcat(m + 1, after),  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(ctype),
							   Args(StringLit(d.name, NIL),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_MKDEF_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_CLONE_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_FREE_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_GETHASHCODE_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_ISEQUAL_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_TOSTRING_", strJoin(d.name, "_IMPL")))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))).

	COut(15, def) :- ForeignTypeDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_FOREIGNTYPEDECL"), NIL), 
								  "P_GEND_FOREIGNTYPES", 
								  Init(arr)).

	HOut(12, def) :- t is TypeDef, ModelType(t.name),
	                params = NIL,
				    funType = FunType(NmdType(NIL, "PRT_UINT64"), argTypes),
					argTypes = PrmTypes(BaseType(VOID), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_MKDEF_", strJoin(t.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(12, def) :- t is TypeDef, ModelType(t.name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(NmdType(NIL, "PRT_UINT64"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_CLONE_", strJoin(t.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(12, def) :- t is TypeDef, ModelType(t.name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_FREE_", strJoin(t.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(12, def) :- t is TypeDef, ModelType(t.name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(NmdType(NIL, "PRT_UINT32"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_GETHASHCODE_", strJoin(t.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(12, def) :- t is TypeDef, ModelType(t.name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(NmdType(NIL, "PRT_STRING"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_TOSTRING_", strJoin(t.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(12, def) :- t is TypeDef, ModelType(t.name),
	                params = Params(Param(NIL, "frgnVal1"),
					         Params(Param(NIL, "frgnVal2"), 
							 NIL)),
				    funType = FunType(NmdType(NIL, "PRT_BOOLEAN"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), 
							   PrmTypes(NmdType(NIL, "PRT_UINT64"), 
							   NIL)),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_ISEQUAL_", strJoin(t.name, "_IMPL")),
					  params,
					  UNKNOWN).

    /*************************************************************/
    /******            Generate Program Decl                ******/
    /*************************************************************/	

	ProgEvntArray ::= (size: Natural, arr: out.Ident).
	ProgEvntArray(size, arr) :- size = 2 + count({ e | e is EventDecl }), arr = out.Ident("P_GEND_EVENTS").

	ProgEvntSetArray ::= (size: Natural, arr: out.Ident).
	ProgEvntSetArray(size, arr) :- size = count({ l | EventPacking(l, _, 0, _) }), size = 0, arr = out.Ident("NULL").
	ProgEvntSetArray(size, arr) :- size = count({ l | EventPacking(l, _, 0, _) }), size > 0, arr = out.Ident("P_GEND_EVENTSETS").

	ProgMachArray ::= (size: Natural, arr: out.Ident).
	ProgMachArray(size, arr) :- size = count({ m | m is MachineDecl, m.kind = REAL }), size = 0, arr = out.Ident("NULL").
	ProgMachArray(size, arr) :- size = count({ m | m is MachineDecl, m.kind = REAL }), size > 0, arr = out.Ident("P_GEND_MACHINES").

	ProgModelArray ::= (size: Natural, arr: out.Ident).
	ProgModelArray(size, arr) :- size = count({ m | m is MachineDecl, m.kind = MODEL }), size = 0, arr = out.Ident("NULL").
	ProgModelArray(size, arr) :- size = count({ m | m is MachineDecl, m.kind = MODEL }), size > 0, arr = out.Ident("P_GEND_MODELS").

	ProgForeignTypesArray ::= (size: Natural, arr: out.Ident).
	ProgForeignTypesArray(size, arr) :- size = count({ t | t is TypeDef, ModelType(t.name) }), size = 0, arr = out.Ident("NULL").
	ProgForeignTypesArray(size, arr) :- size = count({ t | t is TypeDef, ModelType(t.name) }), size > 0, arr = out.Ident("P_GEND_FOREIGNTYPES").

	HOut(13, def) :- def = out.VarDef(
							      EXTERN, 
								  NmdType(NIL, "PRT_PROGRAMDECL"), 
								  "P_GEND_PROGRAM", 
								  NIL).

	COut(16, def) :- ProgEvntArray(evArrSize, evArrName),
	                 ProgEvntSetArray(evSetArrSize, evSetArrName),
					 ProgMachArray(machArrSize, machArrName),
					 ProgModelArray(modelArrSize, modelArrName),
					 ProgForeignTypesArray(foreignTypesSize, foreignTypesArrName),
	                 def = out.VarDef(
							      NIL, 
								  NmdType(NIL, "PRT_PROGRAMDECL"), 
								  "P_GEND_PROGRAM", 
								  init),
				     init = Init(
							   Args(IntLit(evArrSize, DEC, U),
							   Args(IntLit(evSetArrSize, DEC, U),
							   Args(IntLit(machArrSize, DEC, U),
							   Args(IntLit(modelArrSize, DEC, U),
							   Args(IntLit(foreignTypesSize, DEC, U),
							   Args(evArrName,
							   Args(evSetArrName,
							   Args(machArrName,
							   Args(modelArrName,
							   Args(foreignTypesArrName,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))))).

    /*************************************************************/
    /******                RHS Translation                  ******/
    /*************************************************************/	

	//// The translation of the ith expression in a statement.
	RhsExpr ::= (cntxt: TypingContext, stmt: in.Stmt, pos: Natural, trans: out.FunApp, doFree: out.Ident).
	RhsExpr(c, s, i, macroApp, doFree) :- RhsTrans(c, s, i, k, args), RhsMaxOrder(s, i, k), RhsNext(c, s, i, k, e, _), 
										  macroApp = out.FunApp(Ident(strJoin("P_EXPR_", toString(k))), args),
										  ValueAvailable(e, TRUE), doFree = out.Ident("PRT_FALSE"). 
	RhsExpr(c, s, i, macroApp, doFree) :- RhsTrans(c, s, i, k, args), RhsMaxOrder(s, i, k), RhsNext(c, s, i, k, e, _), 
										  macroApp = out.FunApp(Ident(strJoin("P_EXPR_", toString(k))), args),
										  ValueAvailable(e, FALSE), doFree = out.Ident("PRT_TRUE"). 

	//// Translates in context the ith expression appearing in stmt into a list of C args.
	//// The number subId indicates the id of the subexpression currently at the head of the trans list.
	RhsTrans ::= (cntxt: TypingContext, stmt: in.Stmt, pos: Natural, subId: Natural + { -1 }, trans: out.Args + { NIL }).

	//// The next expression that needs to be translated, given the translation of the previous expression.
	RhsNext ::= (cntxt: TypingContext, stmt: in.Stmt, pos: Natural, subId: Natural + { -1 }, nxt: in.Expr, prv: out.Args + { NIL }).
	RhsNext(c, s, i, j', e, trans) :- RhsTrans(c, s, i, j, tail), RhsEvalOrder(s, i, e, j'), j' = j + 1,
									  ValueAvailable(e, TRUE), trans = out.Args(Ident("PRT_FALSE"), tail).
	RhsNext(c, s, i, j', e, trans) :- RhsTrans(c, s, i, j, tail), RhsEvalOrder(s, i, e, j'), j' = j + 1,
									  ValueAvailable(e, FALSE), trans = out.Args(Ident("PRT_TRUE"), tail).
									  
	//// Translates (named) exprs into a list of args that are applied to the P_TUPLE macro.
	//// The number subId indicates the id of the subexpression currently at the head of the trans list.
	ExprsTrans ::= (cntxt: TypingContext, stmt: in.Stmt, pos: Natural, exprs: in.Exprs + in.NamedExprs, trans: out.Args).

	ExprsTrans(c, s, i, e, trans) :- SubSE(c, s), RhsCntxt(s, i, e), e = in.Exprs(_, e', NIL), RhsEvalOrder(s, i, e', j),
	                                 trans = out.Args(Ident(strJoin("p_tmp_expr_", toString(j))), NIL). 
	ExprsTrans(c, s, i, e, trans) :- SubSE(c, s), RhsCntxt(s, i, e), e = in.NamedExprs(_, e', NIL), RhsEvalOrder(s, i, e', j),
	                                 trans = out.Args(Ident(strJoin("p_tmp_expr_", toString(j))), NIL). 

	ExprsTrans(c, s, i, e, trans) :- SubSE(c, s), RhsCntxt(s, i, e), e = in.Exprs(_, e', e''), RhsEvalOrder(s, i, e', j),
	                                 ExprsTrans(c, s, i, e'', tl),
	                                 trans = out.Args(Ident(strJoin("p_tmp_expr_", toString(j))), tl). 

	ExprsTrans(c, s, i, e, trans) :- SubSE(c, s), RhsCntxt(s, i, e), e = in.NamedExprs(_, e', e''), RhsEvalOrder(s, i, e', j),
	                                 ExprsTrans(c, s, i, e'', tl),
	                                 trans = out.Args(Ident(strJoin("p_tmp_expr_", toString(j))), tl). 

	NaturalList ::= (i: Natural, tl: NaturalList + { NIL }).
	ExprsTransIndex ::= (cntxt: TypingContext, stmt: in.Stmt, pos: Natural, exprs: in.Exprs + in.NamedExprs, transIndex: NaturalList).
	ExprsTransIndex(c, s, i, e, trans) :- SubSE(c, s), RhsCntxt(s, i, e), e = in.Exprs(_, e', NIL), RhsEvalOrder(s, i, e', j),
	                                      trans = NaturalList(j, NIL). 
	ExprsTransIndex(c, s, i, e, trans) :- SubSE(c, s), RhsCntxt(s, i, e), e = in.Exprs(_, e', e''), RhsEvalOrder(s, i, e', j),
	                                      ExprsTransIndex(c, s, i, e'', tl), trans = NaturalList(j, tl). 

	//// Base case: Initially, the translation is the empty list.
	RhsTrans(c, s, i, -1, NIL) :- SubSE(c, s), s : in.Stmt, RhsCntxt(s, i, _).

	IndexOf ::= (t: NmdTupType, name: String, offset: Natural, tail: NmdTupType + {NIL}).
	IndexOf(t, name, 0, tail)  :- f is AnonOrNamedFun, LocalVars(f, t), t = NmdTupType(NmdTupTypeField(_, name, _), tail).
	IndexOf(et, name, 0, tail) :- TypeDef(_, t), TypeExpansion(t, et), et = NmdTupType(NmdTupTypeField(_, name, _), tail).
	IndexOf(t, name, 0, tail)  :- TypeOf(_, _, t), t = NmdTupType(NmdTupTypeField(_, name, _), tail).
	IndexOf(t, name, i', tail) :- IndexOf(t, _, i, tail'), tail' = NmdTupType(NmdTupTypeField(_, name, _), tail), i' = i + 1.

	//// Identifier
	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = Name(n), IsLocalVar(c, n, _), LocalVars(c, locals), IndexOf(locals, n, localIndex, _),
									ec = out.BinApp(AAC, BinApp(FLD, Ident("p_tmp_frame"), Ident("locals")), IntLit(localIndex, DEC, U)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = Name(n), IsMachineVar(c, n, varDecl, _), DeclId(varDecl, _, varName),
									ec = out.BinApp(AAC, BinApp(PFLD, Ident("p_tmp_mach_priv"), Ident("varValues")), Ident(varName)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail),
									e = Name(n), IsEventCnst(c, n, _), ConstId(m, e),
									ec = out.UnApp(ADDR, Ident(strJoin("P_GEND_VALUE_", toString(m)))). 

	//// Machine creation
	MkMachineFuncName ::= (s: String).
	MkMachineFuncName(s) :- s = "PrtMkMachine".

	FormalTrans ::= (c: FunDecl, f: String, e: out.Args).
	FormalTrans(c, f, e) :- FormalParam(c, f), LocalVars(c, locals), IndexOf(locals, f, formalIndex, _),
					        e = out.Args(BinApp(AAC, BinApp(FLD, Ident("p_tmp_frame"), Ident("locals")), IntLit(formalIndex, DEC, U)), NIL).

	ContainerInNewCall ::= (c: TypingContext, name: String, funName: String, machineName: String, e: out.Args + { NIL }).
	ContainerInNewCall(c, name, funName, machineName, container) :- 
										 SubSE(c, _), no Annotation(c, "container", _), container = NIL,
	                                     machineDecl is MachineDecl(name, REAL, _, _, _), DeclId(machineDecl, _, machineName), 
										 MkMachineFuncName(funName).
	
	ContainerInNewCall(c, name, funName, machineName, container) :- 
										 c: FunDecl, Annotation(c, "container", f), FormalTrans(c, f, container),
	                                     machineDecl is MachineDecl(name, REAL, _, _, _), DeclId(machineDecl, _, machineName), 
										 funName = "PrtMkMachineRemote".

	ContainerInNewCall(c, name, funName, machineName, container) :- 
										 SubSE(c, _), no Annotation(c, "container", _), container = NIL,
	                                     machineDecl is MachineDecl(name, MODEL, _, _, _), DeclId(machineDecl, _, machineName), 
										 funName = "PrtMkModel".
	
	ContainerInNewCall(c, name, funName, machineName, container) :- 
										 c: FunDecl, Annotation(c, "container", f), FormalTrans(c, f, container),
	                                     machineDecl is MachineDecl(name, MODEL, _, _, _), DeclId(machineDecl, _, machineName), 
										 funName = "PrtMkModelRemote".

	PayloadEvalOrder ::= (s: in.Stmt, i: Natural, p: in.Expr + { NIL }, h: Natural).
	PayloadEvalOrder(s, i, p, h) :- p = NIL, RhsEvalOrder(s, i, in.NulApp(NULL), h).
	PayloadEvalOrder(s, i, p, h) :- p: in.Expr, RhsEvalOrder(s, i, p, h).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = New(name, arg), PayloadEvalOrder(s, i, arg, h),
									ContainerInNewCall(c, name, funName, machineName, container),
									process = out.BinApp(PFLD, Ident("context"), Ident("process")),
									newCall = out.FunApp(Ident(funName), Args(process, Args(Ident(machineName), Args(Ident(strJoin("p_tmp_expr_", toString(h))), container)))),
									ec = out.FunApp(Ident("PrtCloneValue"), Args(out.BinApp(PFLD, newCall, Ident("id")), NIL)).

	//// Function application
	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), e = in.FunApp(name, NIL), 
									DeclId(funDecl, funIndex, funName), funDecl.name = name, FunAvailable(funDecl, c.owner), 
									pushFrame = out.FunApp(Ident("PrtPushNewFrame"), Args(Ident("p_tmp_mach_priv"), Args(IntLit(funIndex, DEC, U), NIL))),
									wrapFunStmt = out.FunApp(Ident("PrtWrapFunStmt"), Args(UnApp(ADDR, Ident("p_tmp_frame")), Args(IntLit(0, DEC, U), Args(Ident("p_tmp_mach_priv"), Args(IntLit(funIndex, DEC, U), NIL))))),
									ec = out.FunApp(Ident("P_SEQ"), Args(pushFrame, Args(wrapFunStmt, NIL))).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), e = in.FunApp(name, args), args != NIL, 
									DeclId(funDecl, funIndex, funName), funDecl.name = name, FunAvailable(funDecl, c.owner), 
									TransformFunArgs(c, s, i, NIL, ecs', NIL),
									pushFrame = out.FunApp(Ident("PrtPushNewFrame"), Args(Ident("p_tmp_mach_priv"), Args(IntLit(funIndex, DEC, U), lstReverse(#Args, ecs')))),
									wrapFunStmt = out.FunApp(Ident("PrtWrapFunStmt"), Args(UnApp(ADDR, Ident("p_tmp_frame")), Args(IntLit(0, DEC, U), Args(Ident("p_tmp_mach_priv"), Args(IntLit(funIndex, DEC, U), NIL))))),
									ec = out.FunApp(Ident("P_SEQ"), Args(pushFrame, Args(wrapFunStmt, NIL))).
	//// Nullary expressions
	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = NulApp(n), n : Integer,
									ConstId(m, e), ec = out.UnApp(ADDR, Ident(strJoin("P_GEND_VALUE_", toString(m)))). 

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = NulApp(FALSE), 
									ConstId(m, e), ec = out.UnApp(ADDR, Ident(strJoin("P_GEND_VALUE_", toString(m)))). 

    RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = NulApp(TRUE), 
									ConstId(m, e), ec = out.UnApp(ADDR, Ident(strJoin("P_GEND_VALUE_", toString(m)))). 

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = NulApp(THIS),
									ec = out.BinApp(PFLD, Ident("p_tmp_mach_priv"), Ident("id")).
									 
	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = NulApp(NONDET),
									ec = out.FunApp(Ident("PrtMkNondetBoolValue"), NIL). 

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = NulApp(FAIRNONDET),
									ec = out.FunApp(Ident("PrtMkNondetBoolValue"), NIL). 

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = NulApp(NULL),
									ConstId(m, e), ec = out.UnApp(ADDR, Ident(strJoin("P_GEND_VALUE_", toString(m)))). 

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = NulApp(HALT),
									ConstId(m, e), ec = out.UnApp(ADDR, Ident(strJoin("P_GEND_VALUE_", toString(m)))). 

	//// Unary expressions
	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.UnApp(NOT, e1), RhsEvalOrder(s, i, e1, tmp1),
									getBool = out.FunApp(Ident("PrtPrimGetBool"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(UnApp(LNOT, getBool), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.UnApp(NEG, e1), RhsEvalOrder(s, i, e1, tmp1),
									getInt = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									ec = out.FunApp(Ident("PrtMkIntValue"), Args(UnApp(NEG, getInt), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.UnApp(KEYS, e1), RhsEvalOrder(s, i, e1, tmp1),
									ec = out.FunApp(Ident("PrtMapGetKeys"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.UnApp(VALUES, e1), RhsEvalOrder(s, i, e1, tmp1),
									ec = out.FunApp(Ident("PrtMapGetValues"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.UnApp(SIZEOF, e1), RhsEvalOrder(s, i, e1, tmp1),
									TypeOf(c, e1, MapType(_, _)),
									ec = out.FunApp(Ident("PrtMkIntValue"), Args(FunApp(Ident("PrtMapSizeOf"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.UnApp(SIZEOF, e1), RhsEvalOrder(s, i, e1, tmp1),
									TypeOf(c, e1, SeqType(_)),
									ec = out.FunApp(Ident("PrtMkIntValue"), Args(FunApp(Ident("PrtSeqSizeOf"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)), NIL)).

	//// Binary expressions
	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(ADD, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getInt1 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getInt2 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkIntValue"), Args(BinApp(ADD, getInt1, getInt2), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(SUB, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getInt1 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getInt2 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkIntValue"), Args(BinApp(SUB, getInt1, getInt2), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(MUL, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getInt1 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getInt2 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkIntValue"), Args(BinApp(MUL, getInt1, getInt2), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(INTDIV, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getInt1 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getInt2 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkIntValue"), Args(BinApp(DIV, getInt1, getInt2), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(AND, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getBool1 = out.FunApp(Ident("PrtPrimGetBool"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getBool2 = out.FunApp(Ident("PrtPrimGetBool"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(BinApp(LAND, getBool1, getBool2), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(OR, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getBool1 = out.FunApp(Ident("PrtPrimGetBool"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getBool2 = out.FunApp(Ident("PrtPrimGetBool"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(BinApp(LOR, getBool1, getBool2), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(EQ, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getBool = out.FunApp(Ident("PrtIsEqualValue"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL))),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(getBool, NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(NEQ, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getBool = out.FunApp(Ident("PrtIsEqualValue"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL))),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(UnApp(LNOT, getBool), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(LT, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getInt1 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getInt2 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(BinApp(LT, getInt1, getInt2), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(LE, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getInt1 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getInt2 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(BinApp(LE, getInt1, getInt2), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(GT, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getInt1 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getInt2 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(BinApp(GT, getInt1, getInt2), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(GE, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getInt1 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp1))), NIL)),
									getInt2 = out.FunApp(Ident("PrtPrimGetInt"), Args(Ident(strJoin("p_tmp_expr_", toString(tmp2))), NIL)),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(BinApp(GE, getInt1, getInt2), NIL)).

	Accessor ::= (c: TypingContext, e: in.Expr, acc: out.Expr).
	Accessor(c, e, acc)			 :- TypeOf(c, e, MapType(_, _)), ValueAvailable(e, TRUE), acc = Ident("PrtMapGetNC").
	Accessor(c, e, acc)			 :- TypeOf(c, e, MapType(_, _)), ValueAvailable(e, FALSE), acc = Ident("PrtMapGet").
	Accessor(c, e, acc)			 :- TypeOf(c, e, SeqType(_)), ValueAvailable(e, TRUE), acc = Ident("PrtSeqGetNC").
	Accessor(c, e, acc)			 :- TypeOf(c, e, SeqType(_)), ValueAvailable(e, FALSE), acc = Ident("PrtSeqGet").
	Accessor(c, e, acc)			 :- TypeOf(c, e, TupType(_, _)), ValueAvailable(e, TRUE), acc = Ident("PrtTupleGetNC").
	Accessor(c, e, acc)			 :- TypeOf(c, e, TupType(_, _)), ValueAvailable(e, FALSE), acc = Ident("PrtTupleGet").
	Accessor(c, e, acc)			 :- TypeOf(c, e, NmdTupType(_, _)), ValueAvailable(e, TRUE), acc = Ident("PrtTupleGetNC").
	Accessor(c, e, acc)			 :- TypeOf(c, e, NmdTupType(_, _)), ValueAvailable(e, FALSE), acc = Ident("PrtTupleGet").

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(IDX, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									TypeOf(c, e1, MapType(_, _)),
									getMap = Ident(strJoin("p_tmp_expr_", toString(tmp1))),
									getIndex = Ident(strJoin("p_tmp_expr_", toString(tmp2))),
									Accessor(c, e1, acc), ec = out.FunApp(acc, Args(getMap, Args(getIndex, NIL))).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(IDX, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									TypeOf(c, e1, SeqType(_)),
									getMap = Ident(strJoin("p_tmp_expr_", toString(tmp1))),
									getIndex = Ident(strJoin("p_tmp_expr_", toString(tmp2))),
									Accessor(c, e1, acc), ec = out.FunApp(acc, Args(getMap, Args(getIndex, NIL))).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.BinApp(IN, e1, e2), RhsEvalOrder(s, i, e1, tmp1), RhsEvalOrder(s, i, e2, tmp2),
									getKey = Ident(strJoin("p_tmp_expr_", toString(tmp1))),
									getMap = Ident(strJoin("p_tmp_expr_", toString(tmp2))),
									ec = out.FunApp(Ident("PrtMkBoolValue"), Args(FunApp(Ident("PrtMapExists"), Args(getMap, Args(getKey, NIL))), NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.Field(e1, f), RhsEvalOrder(s, i, e1, tmp1),
									f : String, TypeOf(c, e1, nmdTupleType), IndexOf(nmdTupleType, f, offset, _),
									getNmdTuple = Ident(strJoin("p_tmp_expr_", toString(tmp1))), 
									Accessor(c, e1, acc), ec = out.FunApp(acc, Args(getNmdTuple, Args(IntLit(offset, DEC, NIL), NIL))).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
							        e = in.Field(e1, f), RhsEvalOrder(s, i, e1, tmp1),
									f : Natural,
									getTuple = Ident(strJoin("p_tmp_expr_", toString(tmp1))),
									Accessor(c, e1, acc), ec = out.FunApp(acc, Args(getTuple, Args(IntLit(f, DEC, NIL), NIL))).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = in.Default(type), TypeToExpr(type, expr),
									ec = out.FunApp(Ident("PrtMkDefaultValue"), Args(expr, NIL)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = in.Cast(arg, type), RhsEvalOrder(s, i, arg, tmp1), TypeToExpr(type, expr), 
									getArg = Ident(strJoin("p_tmp_expr_", toString(tmp1))),
									ec = out.FunApp(Ident("PrtCastValue"), Args(getArg, Args(expr, NIL))).
	
	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = in.Tuple(es), TypeOf(c, e, type), TypeToExpr(type, expr),
									ExprsTrans(c, s, i, es, ecs), 
									ec = out.FunApp(Ident(strJoin("P_TUPLE_", toString(lstLength(in.#TupType, type) - 1))), Args(expr, ecs)).

	RhsTrans(c, s, i, j', trans) :- RhsNext(c, s, i, j', e, tail), trans = out.Args(ec, tail), 
									e = in.NamedTuple(es), TypeOf(c, e, type), TypeToExpr(type, expr),
									ExprsTrans(c, s, i, es, ecs), 
									ec = out.FunApp(Ident(strJoin("P_TUPLE_", toString(lstLength(in.#NmdTupType, type) - 1))), Args(expr, ecs)).

    /*************************************************************/
    /******             Statement translation               ******/
    /*************************************************************/	
	
	Trampoline ::= (cntxt: TypingContext, stmt: in.Stmt, trans: out.Stmt + { NIL }).
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.Receive(_, label, _), ContextSourceInfo(c, _, info, _),
		                    cs = out.Seq(info, 
							             ITE(out.BinApp(EQ, out.BinApp(FLD, Ident("p_tmp_frame"), Ident("returnTo")),
														    out.IntLit(label, DEC, U)), 
										     out.Seq(info, Goto(strJoin("L", toString(label)))),
										     NIL)).
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.NewStmt(_, _, _), cs = NIL.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.Raise(_, _, _), cs = NIL.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.Send(_, _, _, _, _), cs = NIL.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.Monitor(_, _, _), cs = NIL.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.FunStmt(_, _, _, label, _), ContextSourceInfo(c, _, info, _),
	                        cs = out.Seq(info, 
							             ITE(out.BinApp(EQ, out.BinApp(FLD, Ident("p_tmp_frame"), Ident("returnTo")),
														    out.IntLit(label, DEC, U)), 
										     out.Seq(info, Goto(strJoin("L", toString(label)))),
										     NIL)).
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.NulStmt(_, _), cs = NIL.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.Assert(_, _, _), cs = NIL.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.Print(_, _), cs = NIL.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.BinStmt(_, _, _, _), cs = NIL.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.Return(_, _), cs = NIL.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.While(_, s1, _), Trampoline(c, s1, cs1), cs = cs1.
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.Ite(_, s1, s2, _), Trampoline(c, s1, cs1), Trampoline(c, s2, cs2), cs = out.Seq(cs1, cs2).
	Trampoline(c, s, cs) :- SubSE(c, s), s = in.Seq(s1, s2), Trampoline(c, s1, cs1), Trampoline(c, s2, cs2), cs = out.Seq(cs1, cs2).

    StmtTrans ::= (cntxt: TypingContext, stmt: in.Stmt, trans: out.Stmt + { NIL }).

	//// Receive
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.Receive(_, label, x),
						   receiveCall = out.FunApp(Ident("PrtReceive"), Args(Ident("p_tmp_mach_priv"), Args(UnApp(ADDR, Ident("p_tmp_frame")), Args(IntLit(label, DEC, U), NIL)))),
						   receive = Lbl(strJoin("L", toString(label)), out.Seq(info, ITE(BinApp(LAND, BinApp(EQ, BinApp(FLD, Ident("p_tmp_frame"), Ident("rcase")), Ident("NULL")), UnApp(LNOT, receiveCall)), Seq(info, Return(Ident("NULL"))), NIL))),
						   caseFun = out.FunApp(Ident("PrtGetFunction"), Args(Ident("p_tmp_mach_priv"), Args(BinApp(PFLD, BinApp(FLD, Ident("p_tmp_frame"), Ident("rcase")), Ident("funIndex")), NIL))),
						   case = out.FunApp(caseFun, Args(Ident("context"), NIL)),
						   blocked = out.ITE(BinApp(NEQ, BinApp(PFLD, Ident("p_tmp_mach_priv"), Ident("receive")), Ident("NULL")), Seq(Seq(info, FunApp(Ident("PrtPushFrame"), Args(Ident("p_tmp_mach_priv"), Args(UnApp(ADDR, Ident("p_tmp_frame")), NIL)))), Seq(info, Return(Ident("NULL")))), NIL), 
						   exception = out.ITE(BinApp(NEQ, BinApp(PFLD, Ident("p_tmp_mach_priv"), Ident("lastOperation")), Ident("ReturnStatement")), Seq(info, Goto("P_EXIT_FUN")), NIL),
						   resetRcase = out.BinApp(ASN, BinApp(FLD, Ident("p_tmp_frame"), Ident("rcase")), Ident("NULL")),
						   resetReturnTo = out.BinApp(ASN, BinApp(FLD, Ident("p_tmp_frame"), Ident("returnTo")), IntLit(65535, HEX, U)),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(receive, Seq(Seq(info, case), Seq(Seq(info, blocked), Seq(Seq(info, exception), Seq(Seq(info, resetRcase), Seq(info, resetReturnTo)))))).
	
	//// New Machine or Model
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.NewStmt(name, NIL, x), 
						   ContainerInNewCall(c, name, funName, machineName, container),
						   newCall = out.FunApp(Ident(funName),
										Args(BinApp(PFLD, Ident("context"), Ident("process")),
										Args(Ident(machineName),
										Args(Ident("p_tmp_stmt_0"), container)))),
						   ConstId(m, in.NulApp(NULL)), mkNull = out.UnApp(ADDR, Ident(strJoin("P_GEND_VALUE_", toString(m)))),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident("P_STMT_0"), Args(newCall, Args(mkNull, Args(Ident("PRT_FALSE"), NIL))))).

	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.NewStmt(name, pay, x), 
						   ContainerInNewCall(c, name, funName, machineName, container),
						   newCall = out.FunApp(Ident(funName),
										Args(BinApp(PFLD, Ident("context"), Ident("process")),
										Args(Ident(machineName),
										Args(Ident("p_tmp_stmt_0"), container)))),
						   pay : in.Expr, RhsExpr(c, s, 0, payTrans, doFree),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident("P_STMT_0"), Args(newCall, Args(payTrans, Args(doFree, NIL))))).

	//// Raise
	StmtTrans(c, s, cs) :- SubSE(c, s), 
	                       s = in.Raise(ev, NIL, x), RhsExpr(c, s, 0, evTrans, doFree),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(Seq(info, FunApp(Ident("P_STMT_1"), Args(raiseCall, Args(mkNull, Args(Ident("PRT_FALSE"), Args(evTrans, Args(doFree, NIL))))))), Goto("P_EXIT_FUN")),
						   raiseCall = out.FunApp(Ident("PrtRaise"),
						                 Args(context,
										 Args(Ident("p_tmp_stmt_0"),
										 Args(Ident("p_tmp_stmt_1"), NIL)))),
						   ConstId(m, in.NulApp(NULL)), mkNull = out.UnApp(ADDR, Ident(strJoin("P_GEND_VALUE_", toString(m)))),
						   context = Ident("p_tmp_mach_priv").

	StmtTrans(c, s, cs) :- SubSE(c, s), 
	                       s = in.Raise(ev, pay, x), pay : in.Expr, 
						   RhsExpr(c, s, 0, evTrans, doFreeEvTrans), RhsExpr(c, s, 1, payTrans, doFreePayTrans),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(Seq(info, FunApp(Ident("P_STMT_1"), Args(raiseCall, Args(payTrans, Args(doFreePayTrans, Args(evTrans, Args(doFreeEvTrans, NIL))))))), Goto("P_EXIT_FUN")),
						   raiseCall = out.FunApp(Ident("PrtRaise"),
						                 Args(context,
										 Args(Ident("p_tmp_stmt_0"),
										 Args(Ident("p_tmp_stmt_1"), NIL)))),
						   context = Ident("p_tmp_mach_priv").

	//// Send
	SendFuncName ::= (n: Ident).
	SendFuncName(n) :- n = Ident("PrtSend").	
							
	StmtTrans(c, s, cs) :- SubSE(c, s), 
	                       s = in.Send(dest, ev, NIL, _, x), RhsExpr(c, s, 0, destTrans, doFreeDestTrans), RhsExpr(c, s, 1, evTrans, doFreeEvTrans),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident("P_STMT_2"), Args(FunApp(Ident("P_SEQ"), Args(checkCall, Args(sendCall, NIL))), Args(mkNull, Args(Ident("PRT_FALSE"), Args(evTrans, Args(doFreeEvTrans, Args(destTrans, Args(doFreeDestTrans, NIL))))))))),
						   checkCall = out.FunApp(Ident("PrtCheckIsLocalMachineId"), Args(Ident("context"), Args(Ident("p_tmp_stmt_0"), NIL))),
						   SendFuncName(name),
						   sendCall =  out.FunApp(name, 
						                 Args(FunApp(Ident("PrtGetMachine"), Args(BinApp(PFLD, Ident("context"), Ident("process")), Args(Ident("p_tmp_stmt_0"), NIL))),
										 Args(Ident("p_tmp_stmt_1"),
										 Args(Ident("p_tmp_stmt_2"), 
										 Args(Ident("PRT_FALSE"), NIL))))),
						   ConstId(m, in.NulApp(NULL)), mkNull = out.UnApp(ADDR, Ident(strJoin("P_GEND_VALUE_", toString(m)))).

	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.Send(dest, ev, pay, NONE, x), pay : in.Expr,
						   RhsExpr(c, s, 0, destTrans, doFreeDestTrans), RhsExpr(c, s, 1, evTrans, doFreeEvTrans), RhsExpr(c, s, 2, payTrans, doFreePayTrans),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident("P_STMT_2"), Args(FunApp(Ident("P_SEQ"), Args(checkCall, Args(sendCall, NIL))), Args(payTrans, Args(doFreePayTrans, Args(evTrans, Args(doFreeEvTrans, Args(destTrans, Args(doFreeDestTrans, NIL))))))))),
						   checkCall = out.FunApp(Ident("PrtCheckIsLocalMachineId"), Args(Ident("context"), Args(Ident("p_tmp_stmt_0"), NIL))),
						   SendFuncName(name), 
						   sendCall = out.FunApp(name,
						                 Args(FunApp(Ident("PrtGetMachine"), Args(BinApp(PFLD, Ident("context"), Ident("process")), Args(Ident("p_tmp_stmt_0"), NIL))),
										 Args(Ident("p_tmp_stmt_1"),
										 Args(Ident("p_tmp_stmt_2"), 
										 Args(Ident("PRT_FALSE"), NIL))))).

 	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.Send(dest, ev, pay, XFER, x), pay : in.Expr,
						   RhsExpr(c, s, 0, destTrans, doFreeDestTrans), RhsExpr(c, s, 1, evTrans, doFreeEvTrans), RhsExpr(c, s, 2, payTrans, doFreePayTrans),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident("P_STMT_2"), Args(FunApp(Ident("P_SEQ"), Args(checkCall, Args(sendCall, Args(nullStmt, NIL)))), Args(payTrans, Args(doFreePayTrans, Args(evTrans, Args(doFreeEvTrans, Args(destTrans, Args(doFreeDestTrans, NIL))))))))),
						   checkCall = out.FunApp(Ident("PrtCheckIsLocalMachineId"), Args(Ident("context"), Args(Ident("p_tmp_stmt_0"), NIL))),
						   SendFuncName(name), 
						   RhsTrans(c, s, 2, j, out.Args(payVar, _)), RhsMaxOrder(s, 2, j), nullStmt = out.BinApp(ASN, payVar, Ident("NULL")),
						   sendCall = out.FunApp(name,
						                 Args(FunApp(Ident("PrtGetMachine"), Args(BinApp(PFLD, Ident("context"), Ident("process")), Args(Ident("p_tmp_stmt_0"), NIL))),
										 Args(Ident("p_tmp_stmt_1"),
										 Args(Ident("p_tmp_stmt_2"), 
										 Args(Ident("PRT_TRUE"), NIL))))).

	//// Monitor (erased)
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.Monitor(_, _, _), cs = NIL.

	//// NulStmt
	StmtTrans(c, s, cs) :- SubSE(c, s), context = Ident("p_tmp_mach_priv"),
	                       s = in.NulStmt(POP, x),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(Seq(info, FunApp(Ident("PrtPop"), Args(context, NIL))), Goto("P_EXIT_FUN")).

	//// Assert
	StmtTrans(c, s, cs) :- SubSE(c, s), context = Ident("p_tmp_mach_priv"),
	                       s = in.Assert(arg, NIL, x), RhsExpr(c, s, 0, argTrans, doFree),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, ITE(out.UnApp(LNOT, FunApp(Ident("P_BOOL_EXPR"), Args(argTrans, Args(doFree, NIL)))), Seq(info, assertCall), NIL)),
						   assertCall = out.FunApp(Ident("PrtHandleError"), 
											Args(Ident("PRT_STATUS_ASSERT"), 
											Args(context, NIL))).
	StmtTrans(c, s, cs) :- SubSE(c, s), context = Ident("p_tmp_mach_priv"),
	                       s = in.Assert(arg, msg, x), msg: String, RhsExpr(c, s, 0, argTrans, doFree),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, ITE(out.UnApp(LNOT, FunApp(Ident("P_BOOL_EXPR"), Args(argTrans, Args(doFree, NIL)))), Seq(Seq(info, printCall), Seq(info, assertCall)), NIL)),
						   printCall = out.FunApp(Ident("PrtPrintf"), Args(StringLit(msg, NIL), NIL)),
						   assertCall = out.FunApp(Ident("PrtHandleError"), 
											Args(Ident("PRT_STATUS_ASSERT"), 
											Args(context, NIL))).

	//// Print
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.Print(msg, x), 
	                       ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident("PrtPrintf"), Args(StringLit(msg, NIL), NIL))).

	//// Skip 
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.NulStmt(SKIP, _), cs = NIL.
	
	//// Return
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.Return(NIL, _), cs = out.Goto("P_EXIT_FUN").
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.Return(e, x), e : in.Expr, RhsExpr(c, s, 0, ce, Ident("PRT_TRUE")),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(Seq(info, BinApp(ASN, Ident("p_tmp_ret"), ce)), out.Goto("P_EXIT_FUN")).
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.Return(e, x), e : in.Expr, RhsExpr(c, s, 0, ce, Ident("PRT_FALSE")),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(Seq(info, BinApp(ASN, Ident("p_tmp_ret"), out.FunApp(Ident("PrtCloneValue"), Args(ce, NIL)))), out.Goto("P_EXIT_FUN")).

	//// While
	StmtTrans(c, s, cs) :- SubSE(c, s), 
	                       s = in.While(cond, s1, x), RhsExpr(c, s, 0, condTrans, doFree), StmtTrans(c, s1, cs1),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, Loop(WHILE, out.FunApp(Ident("P_BOOL_EXPR"), Args(condTrans, Args(doFree, NIL))), Seq(cs1, info))).
    
	//// Ite
	StmtTrans(c, s, cs) :- SubSE(c, s), 
	                       s = in.Ite(cond, s1, s2, x), RhsExpr(c, s, 0, condTrans, doFree), StmtTrans(c, s1, cs1), StmtTrans(c, s2, cs2),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, ITE(out.FunApp(Ident("P_BOOL_EXPR"), Args(condTrans, Args(doFree, NIL))), cs1, cs2)).

	//// Seq
	StmtTrans(c, s, cs) :- SubSE(c, s), 
	                       s = in.Seq(s1, s2), StmtTrans(c, s1, cs1), StmtTrans(c, s2, cs2),
						   cs = out.Seq(cs1, cs2).

    //// Fun
	FunStmtCleanup ::= (cntxt: TypingContext, stmt: in.Stmt, trans: out.Stmt).
	FunStmtCleanup(c, s, cs) :- SubSE(c, s), s = FunStmt(_, _, NIL, _, x), ret = Ident("p_tmp_funstmt_ret"), ContextLineInfo(c, s, info),
								cs = out.ITE(BinApp(NEQ, ret, Ident("NULL")), Seq(info, FunApp(Ident("PrtFreeValue"), Args(ret, NIL))), NIL).
	FunStmtCleanup(c, s, cs) :- SubSE(c, s), s = FunStmt(_, _, aout, _, _), aout: in.Name, ret = Ident("p_tmp_funstmt_ret"),
								varDecl is VarDecl(aout.name, c.owner, _), DeclId(varDecl, _, varName), no TypeOfLocalVar(c, aout.name, _),
								cs =  out.FunApp(Ident("PrtSetGlobalVarEx"),
						                     Args(Ident("p_tmp_mach_priv"),
											 Args(Ident(varName),
											 Args(ret,
											 Args(Ident("PRT_FALSE"),
											      NIL))))).
	FunStmtCleanup(c, s, cs) :- SubSE(c, s), s = FunStmt(_, _, aout, _, _), aout: in.Name, ret = Ident("p_tmp_funstmt_ret"),
								TypeOfLocalVar(c, aout.name, _), LocalVars(c, locals), IndexOf(locals, aout.name, i, _),
								cs = out.FunApp(Ident("PrtSetLocalVarEx"),
						                     Args(BinApp(FLD, Ident("p_tmp_frame"), Ident("locals")),
											 Args(IntLit(i, DEC, U),
											 Args(ret,
											 Args(Ident("PRT_FALSE"),
											      NIL))))).

	StmtTrans(c, s, cs) :- SubSE(c, s), context = Ident("context"),
						   s = in.FunStmt(name, NIL, _, label, x), DeclId(funDecl, funIndex, funName), FunAvailable(funDecl, c.owner), funDecl.name = name,
						   ret = Ident("p_tmp_funstmt_ret"),
						   pushFrame = out.FunApp(Ident("PrtPushNewFrame"), Args(Ident("p_tmp_mach_priv"), Args(IntLit(funIndex, DEC, U), NIL))),
						   funcall = out.BinApp(ASN, ret, FunApp(Ident("PrtWrapFunStmt"), Args(UnApp(ADDR, Ident("p_tmp_frame")), Args(IntLit(label, DEC, U), Args(Ident("p_tmp_mach_priv"), Args(IntLit(funIndex, DEC, U), NIL)))))),
						   blocked = out.ITE(BinApp(NEQ, BinApp(PFLD, Ident("p_tmp_mach_priv"), Ident("receive")), Ident("NULL")), Seq(info, Return(ret)), NIL),
						   exception = out.ITE(BinApp(NEQ, BinApp(PFLD, Ident("p_tmp_mach_priv"), Ident("lastOperation")), Ident("ReturnStatement")), Seq(info, Goto("P_EXIT_FUN")), NIL),
						   FunStmtCleanup(c, s, cleanup),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(pushFrame, Lbl(strJoin("L", toString(label)), Seq(Seq(info, funcall), Seq(Seq(info, blocked), Seq(Seq(info, exception), Seq(info, cleanup)))))).

	TransformFunArgs ::= (TypingContext, in.Stmt, Natural, NaturalList + { NIL }, out.Args + { NIL }, in.Exprs + { NIL }).
	TransformFunArgs(c, s, 0, ii, NIL, s.args):- SubSE(c, s), s : in.FunStmt, s.args != NIL, ExprsTransIndex(c, s, 0, s.args, ii).
	TransformFunArgs(c, s, i, ii, NIL, e.args):- RhsNext(c, s, i, _, e, _), e: in.FunApp, e.args != NIL, ExprsTransIndex(c, s, i, e.args, ii).
	TransformFunArgs(c, s, i, ii, args', tl) :- TransformFunArgs(c, s, i, NaturalList(j, ii), args, in.Exprs(NONE, _, tl)), 
												ec = Ident(strJoin("p_tmp_expr_", toString(j))), 
												args' = out.Args(ec, Args(Ident("PRT_FUN_PARAM_CLONE"), args)).
	TransformFunArgs(c, s, i, ii, args', tl) :- TransformFunArgs(c, s, i, NaturalList(j, ii), args, in.Exprs(REF, _, tl)),
												RhsTrans(c, s, i, j, out.Args(ec, _)), 
												args' = out.Args(UnApp(ADDR, ec), Args(Ident("PRT_FUN_PARAM_REF"), args)).
	TransformFunArgs(c, s, i, ii, args', tl) :- TransformFunArgs(c, s, i, NaturalList(j, ii), args, in.Exprs(XFER, _, tl)), 
												RhsTrans(c, s, i, j, out.Args(ec, _)), 
												args' = out.Args(UnApp(ADDR, ec), Args(Ident("PRT_FUN_PARAM_XFER"), args)).

	StmtTrans(c, s, cs) :- FunStmtRhs(c, s, size, tail), s = in.FunStmt(name, args, _, label, x), args != NIL, 
	                       DeclId(fn, funIndex, funName), fn.name = name, FunAvailable(fn, c.owner),  
						   TransformFunArgs(c, s, 0, NIL, ecs', NIL),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(Seq(info, pushFrame), Lbl(strJoin("L", toString(label)), Seq(Seq(info, funCall), Seq(Seq(info, blocked), Seq(Seq(info, exception), Seq(info, cleanup)))))),
						   pushFrame = out.FunApp(Ident(strJoin("P_EXPR_", toString(size))), Args(out.FunApp(Ident("PrtPushNewFrame"), Args(Ident("p_tmp_mach_priv"), Args(IntLit(funIndex, DEC, U), lstReverse(#Args, ecs')))), Args(Ident("PRT_FALSE"), tail))),
						   funCall = out.BinApp(ASN, ret, FunApp(Ident("PrtWrapFunStmt"), Args(UnApp(ADDR, Ident("p_tmp_frame")), Args(IntLit(label, DEC, U), Args(Ident("p_tmp_mach_priv"), Args(IntLit(funIndex, DEC, U), NIL)))))),
						   blocked = out.ITE(BinApp(NEQ, BinApp(PFLD, Ident("p_tmp_mach_priv"), Ident("receive")), Ident("NULL")), Seq(info, Return(ret)), NIL),
						   exception = out.ITE(BinApp(NEQ, BinApp(PFLD, Ident("p_tmp_mach_priv"), Ident("lastOperation")), Ident("ReturnStatement")), Seq(info, Goto("P_EXIT_FUN")), NIL),
						   FunStmtCleanup(c, s, cleanup),
						   ret = Ident("p_tmp_funstmt_ret"),
						   context = Ident("context").
    
	FunStmtRhs ::= (cntxt: TypingContext, stmt: in.FunStmt, exprSize: Natural, args: out.Args).
	FunStmtRhs(c, s, size, args) :- RhsTrans(c, s, 0, j, args), RhsMaxOrder(s, 0, j), size = j + 1, s : in.FunStmt, args: out.Args. 

	/*************************************************************/
	/******            Value availability                   ******/
	/*************************************************************/

	ValueAvailable ::= (expr: in.Expr, Boolean).
	ValueAvailable(NulApp(NULL), TRUE).
	ValueAvailable(NulApp(HALT), TRUE).
	ValueAvailable(e, TRUE) :- SubSE(_, e), e: in.Name.
	ValueAvailable(e, TRUE) :- SubSE(_, e), e: in.NulApp, e.op != NONDET, e.op != FAIRNONDET.

	ValueAvailable(e, FALSE) :- SubSE(_, e), e: in.New.
	ValueAvailable(e, FALSE) :- SubSE(_, e), e: in.FunApp.
	ValueAvailable(e, FALSE) :- SubSE(_, e), e: in.NulApp, e.op = NONDET.
	ValueAvailable(e, FALSE) :- SubSE(_, e), e: in.NulApp, e.op = FAIRNONDET.
	ValueAvailable(e, FALSE) :- SubSE(_, e), e: in.UnApp.
	ValueAvailable(e, FALSE) :- SubSE(_, e), e: in.BinApp, e.op != IDX.
	ValueAvailable(e, FALSE) :- SubSE(_, e), e: in.Default.
	ValueAvailable(e, FALSE) :- SubSE(_, e), e: in.Tuple.
	ValueAvailable(e, FALSE) :- SubSE(_, e), e: in.NamedTuple.

	ValueAvailable(e, b) :- SubSE(_, e), e = in.BinApp(IDX, e', _), ValueAvailable(e', b).
	ValueAvailable(e, b) :- SubSE(_, e), e = in.Field(e', _), ValueAvailable(e', b).
	ValueAvailable(e, b) :- SubSE(_, e), e = in.Cast(e', _), ValueAvailable(e', b).


    /*************************************************************/
    /******            Expression dependencies              ******/
    /*************************************************************/	

	//// ExprDepNum labels each expression in the global expression DAG with a number 
	//// greater than the labels of all its sub-expressions.
	ExprDepNum ::= (id: Natural, expr: in.Expr + in.Exprs + in.NamedExprs).

	//// These expressions have no dependencies.
	ExprDepNum(0, e) :- SubSE(_, e), e : in.Name.
	ExprDepNum(0, e) :- SubSE(_, e), e : in.NulApp. 
	ExprDepNum(0, e) :- SubSE(_, e), e : in.Default.

	//// New app has a hidden dependency on NULL if it is an nullary app.
	ExprDepNum(0, h),
	ExprDepNum(1, e) :- SubSE(_, e), e = in.New(_, NIL), h = in.NulApp(NULL). 
	ExprDepNum(i, e) :- SubSE(_, e), e = in.New(_, e'), ExprDepNum(j, e'), i = j + 1. 

	//// Fun app has zero or one depenencies.
	ExprDepNum(0, e) :- SubSE(_, e), e = in.FunApp(_, NIL). 
	ExprDepNum(i, e) :- SubSE(_, e), e = in.FunApp(_, e'), ExprDepNum(j, e'), i = j + 1.

	//// These expressions have one depenency.
	ExprDepNum(i, e) :- SubSE(_, e), e = in.UnApp(_, e'), ExprDepNum(j, e'), i = j + 1. 
	ExprDepNum(i, e) :- SubSE(_, e), e = in.Field(e', _), ExprDepNum(j, e'), i = j + 1. 
	ExprDepNum(i, e) :- SubSE(_, e), e = in.Cast(e', _), ExprDepNum(j, e'), i = j + 1. 
	ExprDepNum(i, e) :- SubSE(_, e), e = in.Tuple(e'), ExprDepNum(j, e'), i = j + 1. 
	ExprDepNum(i, e) :- SubSE(_, e), e = in.NamedTuple(e'), ExprDepNum(j, e'), i = j + 1. 

	//// These expressions have one or two depenencies.
	ExprDepNum(i, e) :- SubSE(_, e), e = in.Exprs(_, e', NIL), ExprDepNum(j, e'), i = j + 1. 
	ExprDepNum(i, e) :- SubSE(_, e), e = in.NamedExprs(_, e', NIL), ExprDepNum(j, e'), i = j + 1. 

	ExprDepNum(i, e) :- SubSE(_, e), e = in.Exprs(_, e', e''), ExprDepNum(j, e'), ExprDepNum(k, e''), i = j + k + 1. 
	ExprDepNum(i, e) :- SubSE(_, e), e = in.NamedExprs(_, e', e''), ExprDepNum(j, e'), ExprDepNum(k, e''), i = j + k + 1.

	//// These expressions have two depenencies.
	ExprDepNum(i, e) :- SubSE(_, e), e = in.BinApp(_, e', e''), ExprDepNum(j, e'), ExprDepNum(k, e''), i = j + k + 1.

    /*************************************************************/
    /******                 RHS Eval Order                  ******/
    /*************************************************************/	
	//// Indicates the maximum order of the ith expression in statement.
	RhsMaxOrder ::= (stmt: in.Stmt, pos: Natural, maxo: Natural). 

	//// Marks the expressions that appear in statements. RhsCntxt(s, i, e) means
	//// e is a sub-expression of the ith expression appearing in statement s. 
	RhsCntxt ::= (stmt: in.Stmt, pos: Natural, expr: in.Expr + in.Exprs + in.NamedExprs). 

	//// The number of top-level expressions in a statement (possibly including hidden null expressions).
	StmtExprSize ::= (stmt: in.Stmt, pos: Natural). 

	//// Rhs eval order tells the order in which subexpressions of a statement are evaluated in C. 
	RhsEvalOrder ::= (stmt: in.Stmt, pos: Natural, expr: in.Expr, order: Natural).

	RhsEvalOrder(s, i, e, k) :- RhsCntxt(s, i, e), dn is ExprDepNum(j, e), e : in.Expr, 
	                            k = toOrdinal(dn, 0, { dn' | RhsCntxt(s, i, e'), dn' is ExprDepNum(l, e'), e' : in.Expr }). 

	RhsCntxt(s, 0, e)    :- SubSE(_, s), s = in.NewStmt(_, e, _), e : in.Expr.
	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.NewStmt(_, e, _), e : in.Expr, RhsEvalOrder(s, 0, e, k).
	StmtExprSize(s, 1)   :- SubSE(_, s), s : in.NewStmt.
	
	RhsCntxt(s, 0, e)    :- SubSE(_, s), s = in.FunStmt(_, e, _, _, _), e : in.Exprs.
	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.FunStmt(_, e, _, _, _), e : in.Exprs,
							k = maxAll(0, { k' | RhsEvalOrder(s, 0, _, k') }), k: Natural.
	StmtExprSize(s, 1)   :- SubSE(_, s), s : in.FunStmt.
	
	RhsCntxt(s, 0, e)    :- SubSE(_, s), s = in.Return(e, _), e : in.Expr.
	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.Return(e, _), e : in.Expr, RhsEvalOrder(s, 0, e, k).
	StmtExprSize(s, 1)   :- SubSE(_, s), s : in.Return.

	RhsCntxt(s, 0, e)    :- SubSE(_, s), s = in.While(e, _, _).
	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.While(e, _, _), e : in.Expr, RhsEvalOrder(s, 0, e, k).
	StmtExprSize(s, 1)   :- SubSE(_, s), s : in.While.

	RhsCntxt(s, 0, e)    :- SubSE(_, s), s = in.Ite(e, _, _, _).
	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.Ite(e, _, _, _), e : in.Expr, RhsEvalOrder(s, 0, e, k).
	StmtExprSize(s, 1)   :- SubSE(_, s), s : in.Ite.

	RhsCntxt(s, 0, e)    :- SubSE(_, s), s = in.Assert(e, _, _).
	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.Assert(e, _, _), e : in.Expr, RhsEvalOrder(s, 0, e, k).
	StmtExprSize(s, 1)   :- SubSE(_, s), s : in.Assert.

	RhsCntxt(s, 0, e)    :- SubSE(_, s), s = in.Raise(e, _, _).
	RhsCntxt(s, 1, e)    :- SubSE(_, s), s = in.Raise(_, e, _), e : in.Expr.
	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.Raise(e, _, _), e : in.Expr, RhsEvalOrder(s, 0, e, k).
	RhsMaxOrder(s, 1, k) :- SubSE(_, s), s = in.Raise(_, e, _), e : in.Expr, RhsEvalOrder(s, 1, e, k).
	StmtExprSize(s, 2)   :- SubSE(_, s), s : in.Raise.

	RhsCntxt(s, 0, e)    :- SubSE(_, s), s = in.Monitor(e, _, _).
	RhsCntxt(s, 1, e)    :- SubSE(_, s), s = in.Monitor(_, e, _), e : in.Expr.
	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.Monitor(e, _, _), e : in.Expr, RhsEvalOrder(s, 0, e, k).
	RhsMaxOrder(s, 1, k) :- SubSE(_, s), s = in.Monitor(_, e, _), e : in.Expr, RhsEvalOrder(s, 1, e, k).
	StmtExprSize(s, 2)   :- SubSE(_, s), s : in.Monitor.

	RhsCntxt(s, 0, e) :- SubSE(_, s), s = in.Send(e, _, _, _, _).
	RhsCntxt(s, 1, e) :- SubSE(_, s), s = in.Send(_, e, _, _, _).
	RhsCntxt(s, 2, e) :- SubSE(_, s), s = in.Send(_, _, e, _, _), e : in.Expr.
	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.Send(e, _, _, _, _), e : in.Expr, RhsEvalOrder(s, 0, e, k).
	RhsMaxOrder(s, 1, k) :- SubSE(_, s), s = in.Send(_, e, _, _, _), e : in.Expr, RhsEvalOrder(s, 1, e, k).
	RhsMaxOrder(s, 2, k) :- SubSE(_, s), s = in.Send(_, _, e, _, _), e : in.Expr, RhsEvalOrder(s, 2, e, k).
	StmtExprSize(s, 3)   :- SubSE(_, s), s : in.Send.

	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.New(_, e'), e' : in.Expr. 
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.New(_, NIL), e' = in.NulApp(NULL). 

	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.FunApp(_, e'), e' : in.Exprs.
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.UnApp(_, e').
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.Field(e', _).
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.Cast(e', _).
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.Tuple(e').
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.NamedTuple(e').
	
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.Exprs(_, e', _). 
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.NamedExprs(_, e', _). 
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.Exprs(_, _, e'), e' : in.Exprs. 
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.NamedExprs(_, _, e'), e' : in.NamedExprs. 
	 
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.BinApp(_, e', _). 
	RhsCntxt(s, i, e') :- RhsCntxt(s, i, e), e = in.BinApp(_, _, e'). 

    /*************************************************************/
    /******         Translation of BinStmt                  ******/
    /*************************************************************/
	
	//// Records the sequence of getters in an LHS expression.
	//// Numbers each getter involving a key expression.	
	LhsPath ::= (stmt: in.BinStmt, getter: in.Expr, keyNum: Natural).

	LhsPath(s, e, 1)   :- SubSE(_, s), s = in.BinStmt(_, e, _, _), e = in.BinApp(IDX, _, _).
	LhsPath(s, e, 0)   :- SubSE(_, s), s = in.BinStmt(_, e, _, _), toSymbol(e) != in.#BinApp.

	LhsPath(s, e', i') :- LhsPath(s, e, i), e = in.BinApp(IDX, e', _), e' = in.BinApp(IDX, _, _), i' = i + 1.
	LhsPath(s, e', i)  :- LhsPath(s, e, i), e = in.BinApp(IDX, e', _), toSymbol(e') != in.#BinApp.

	LhsPath(s, e', i') :- LhsPath(s, e, i), e = in.Field(e', _), e' = in.BinApp(IDX, _, _), i' = i + 1.
	LhsPath(s, e', i)  :- LhsPath(s, e, i), e = in.Field(e', _), toSymbol(e') != in.#BinApp.

	RhsCntxt(s, 0, e)  :- SubSE(_, s), s = in.BinStmt(_, _, e, _).
	RhsCntxt(s, i, e)  :- LhsPath(s, g, i), g = in.BinApp(IDX, _, e).
	StmtExprSize(s, n) :- LhsPath(s, Name(_), i), n = i + 1.

	RhsMaxOrder(s, 0, k) :- SubSE(_, s), s = in.BinStmt(_, _, e, _), e : in.Expr, RhsEvalOrder(s, 0, e, k).
	RhsMaxOrder(s, i, k) :- LhsPath(s, g, i), g = in.BinApp(IDX, _, e), RhsEvalOrder(s, i, e, k).

	//// Caches the cnames of global variables in LhsPaths
    LhsGlobalVar ::= (lp: LhsPath, owner: MachineDecl, cname: String).
    LhsGlobalVar(lp, m, varName) :- lp is LhsPath(s, Name(n), _), DeclId(varDecl, _, varName), 
	                                varDecl : in.VarDecl, varDecl.name = n, m = varDecl.owner.

	//// Translates the entire access path
	LhsTrans ::= (cntxt: TypingContext, path: LhsPath, trans: out.Expr).

    LhsTrans(c, lp, trans) :- SubSE(c, s), lp is LhsPath(s, Name(n), _), 
							  TypeOfLocalVar(c, n, _), LocalVars(c, locals), IndexOf(locals, n, i, _),
	                          trans = out.BinApp(AAC, BinApp(FLD, Ident("p_tmp_frame"), Ident("locals")), IntLit(i, DEC, U)). 

	LhsTrans(c, lp, trans) :- SubSE(c, s), LhsGlobalVar(lp, c.owner, varName), lp = LhsPath(s, Name(n), _),   
							  no TypeOfLocalVar(c, n, _), 
							  trans = out.BinApp(AAC, BinApp(PFLD, Ident("p_tmp_mach_priv"), Ident("varValues")), Ident(varName)).

	LhsTrans(c, lp, trans) :- LhsTrans(c, LhsPath(s, g, _), e), lp is LhsPath(s, in.Field(g, n), _), n : Natural,
	                          trans = out.FunApp(Ident("PrtTupleGetNC"), Args(e, Args(IntLit(n, DEC, U), NIL))).   

	LhsTrans(c, lp, trans) :- LhsTrans(c, LhsPath(s, g, _), e), lp is LhsPath(s, in.Field(g, n), _), n : String,
	                          TypeOf(c, g, t), IndexOf(t, n, i, _),
	                          trans = out.FunApp(Ident("PrtTupleGetNC"), Args(e, Args(IntLit(i, DEC, U), NIL))).   

	LhsTrans(c, lp, trans) :- LhsTrans(c, LhsPath(s, g, _), e), lp is LhsPath(s, in.BinApp(IDX, g, k), i),
	                          TypeOf(c, g, t), toSymbol(t) = #SeqType, tmpVar = strJoin("p_tmp_stmt_", toString(i)),
	                          trans = out.FunApp(Ident("PrtSeqGetNC"), 
							                     Args(e, Args(Ident(tmpVar), NIL))).

	LhsTrans(c, lp, trans) :- LhsTrans(c, LhsPath(s, g, _), e), lp is LhsPath(s, in.BinApp(IDX, g, k), i),
	                          TypeOf(c, g, t), toSymbol(t) = #MapType, tmpVar = strJoin("p_tmp_stmt_", toString(i)),
	                          trans = out.FunApp(Ident("PrtMapGetNC"), Args(e, Args(Ident(tmpVar), NIL))).

    //// Concat all statement-level expressions
	LhsExprs ::= (cntxt: TypingContext, stmt: in.BinStmt, indx: Natural, args: out.Args). 
	LhsExprs(c, s, 0, args)  :- SubSE(c, s), s = in.BinStmt(REMOVE, _, _, _), RhsExpr(c, s, 0, trans, doFree), args = out.Args(trans, Args(doFree, NIL)).
	LhsExprs(c, s, 0, args)  :- SubSE(c, s), s = in.BinStmt(op, _, _, _), op != REMOVE, RhsExpr(c, s, 0, trans, _), args = out.Args(trans, Args(Ident("PRT_FALSE"), NIL)).
	LhsExprs(c, s, i', args) :- LhsExprs(c, s, i, a), i' = i + 1, RhsExpr(c, s, i', trans, doFree), args = out.Args(trans, Args(doFree, a)). 

    //// ASSIGN / UPDATE
	//// Case 1: Assign global variable
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(ASSIGN, e, _, x), e = Name(glbl), 
	                       varDecl is VarDecl(glbl, c.owner, _), DeclId(varDecl, _, varName), no TypeOfLocalVar(c, glbl, _),  
	                       StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs),
						   ContextLineInfo(c, s, info), 
						   cs = out.Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(asgn, exprs))), 
						   RhsExpr(c, s, 0, _, doFree), doClone = out.UnApp(LNOT, doFree),
						   asgn = out.FunApp(Ident("PrtSetGlobalVarEx"),
						                     Args(Ident("p_tmp_mach_priv"),
											 Args(Ident(varName),
											 Args(Ident("p_tmp_stmt_0"),
											 Args(doClone,
											      NIL))))).

	//// Case 2: Assign a local variable
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(ASSIGN, e, _, x), e = Name(lcl), 
                           TypeOfLocalVar(c, lcl, _), LocalVars(c, locals), IndexOf(locals, lcl, i, _),                 
                           StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs), 
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(asgn, exprs))),
						   RhsExpr(c, s, 0, _, doFree), doClone = out.UnApp(LNOT, doFree),
						   asgn = out.FunApp(Ident("PrtSetLocalVarEx"),
						                     Args(BinApp(FLD, Ident("p_tmp_frame"), Ident("locals")),
											 Args(IntLit(i, DEC, U),
											 Args(Ident("p_tmp_stmt_0"),
											 Args(doClone,
											      NIL))))).

	//// Case 3: Assign a tuple by int index
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(ASSIGN, e, _, x), e = in.Field(getter, i), i : Natural, 	                       
                           StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs),
						   LhsTrans(c, LhsPath(s, getter, _), egetter), 
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(asgn, exprs))),
						   RhsExpr(c, s, 0, _, doFree), doClone = out.UnApp(LNOT, doFree),
						   asgn = out.FunApp(Ident("PrtTupleSetEx"),
						                     Args(egetter,
											 Args(IntLit(i, DEC, U),
											 Args(Ident("p_tmp_stmt_0"),
											 Args(doClone,
											      NIL))))).

	//// Case 4: Assign a tuple by name
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(ASSIGN, e, _, x), e = in.Field(getter, field), field : String, 	                       
                           StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs),
						   TypeOf(c, getter, t), IndexOf(t, field, i, _), LhsTrans(c, LhsPath(s, getter, _), egetter), 
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(asgn, exprs))),
						   RhsExpr(c, s, 0, _, doFree), doClone = out.UnApp(LNOT, doFree),
						   asgn = out.FunApp(Ident("PrtTupleSetEx"),
						                     Args(egetter,
											 Args(IntLit(i, DEC, U),
											 Args(Ident("p_tmp_stmt_0"),
											 Args(doClone,
											      NIL))))).

	//// Case 5: Assign a sequence (rewrite the reading version of the translation)
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(ASSIGN, e, _, x), e = in.BinApp(IDX, _, _), 	                       
                           StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs),
						   LhsTrans(c, LhsPath(s, e, _), egetter), 
						   egetter = out.FunApp(Ident("PrtSeqGetNC"), Args(seq, Args(ndex, NIL))),
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(asgn, exprs))),
						   RhsExpr(c, s, 0, _, doFree), doClone = out.UnApp(LNOT, doFree),
						   asgn = out.FunApp(Ident("PrtSeqUpdateEx"),
						                     Args(seq,
											 Args(ndex,
											 Args(Ident("p_tmp_stmt_0"),
											 Args(doClone,
											      NIL))))).

	//// Case 6: Assign a map (rewrite the reading version of the translation)
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(ASSIGN, e, _, x), e = in.BinApp(IDX, _, _), 	                       
                           StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs),
						   LhsTrans(c, LhsPath(s, e, _), egetter), 
						   egetter = out.FunApp(Ident("PrtMapGetNC"), Args(map, Args(key, NIL))),  
						   ContextLineInfo(c, s, info), 
						   cs = out.Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(asgn, exprs))),
						   RhsExpr(c, s, 0, _, doFree), doClone = out.UnApp(LNOT, doFree),
						   asgn = out.FunApp(Ident("PrtMapUpdateEx"),
						                     Args(map,
											 Args(key,
											 Args(Ident("PRT_TRUE"),
											 Args(Ident("p_tmp_stmt_0"),
											 Args(doClone,
											      NIL)))))).

    //// INSERT
	//// Case 1: Insert into a sequence
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(INSERT, e, _, x), 
	                       TypeOf(c, e, t), toSymbol(t) = #SeqType, LhsTrans(c, LhsPath(s, e, _), egetter), 
	                       StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs), 
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(insert, exprs))),
						            Seq(Seq(info, freeKey),
									Seq(Seq(info, freeTupleArray),
									Seq(Seq(info, freeTuple),
									Seq(Seq(info, freeValue),
									    NIL))))),
						   insert = out.FunApp(Ident("PrtSeqInsertEx"),
						                     Args(egetter,
											 Args(key,
											 Args(val,
											 Args(Ident("PRT_FALSE"),
											      NIL))))),
						   key = out.FunApp(Ident("PrtTupleGetNC"),
												        Args(Ident("p_tmp_stmt_0"),
												        Args(IntLit(0, DEC, U),
												        NIL))),
				   		   val = out.FunApp(Ident("PrtTupleGetNC"),
									                    Args(Ident("p_tmp_stmt_0"),
									                    Args(IntLit(1, DEC, U),
									                    NIL))),
						   freeKey = out.FunApp(Ident("PrtFree"), Args(key, NIL)),
						   freeTupleArray = out.FunApp(Ident("PrtFree"), 
											       Args(BinApp(PFLD, BinApp(FLD, out.BinApp(PFLD, Ident("p_tmp_stmt_0"), Ident("valueUnion")), Ident("tuple")), Ident("values")),
												        NIL)),
						   freeTuple = out.FunApp(Ident("PrtFree"), 
											       Args(BinApp(FLD, out.BinApp(PFLD, Ident("p_tmp_stmt_0"), Ident("valueUnion")), Ident("tuple")),
												        NIL)),
						   freeValue = out.FunApp(Ident("PrtFree"), Args(Ident("p_tmp_stmt_0"), NIL)).

	//// Case 2: Insert into a map
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(INSERT, e, _, x), 
	                       TypeOf(c, e, t), toSymbol(t) = #MapType, LhsTrans(c, LhsPath(s, e, _), egetter), 
	                       StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs), 
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(insert, exprs))),
						            Seq(Seq(info, freeTupleArray),
									Seq(Seq(info, freeTuple),
									Seq(Seq(info, freeValue),
									    NIL)))),
						   insert = out.FunApp(Ident("PrtMapInsertEx"),
						                     Args(egetter,
											 Args(key,
											 Args(Ident("PRT_FALSE"),
											 Args(val,
											 Args(Ident("PRT_FALSE"),
											      NIL)))))),
						   key = out.FunApp(Ident("PrtTupleGetNC"),
												        Args(Ident("p_tmp_stmt_0"),
												        Args(IntLit(0, DEC, U),
												        NIL))),
				   		   val = out.FunApp(Ident("PrtTupleGetNC"),
									                    Args(Ident("p_tmp_stmt_0"),
									                    Args(IntLit(1, DEC, U),
									                    NIL))),
						   freeTupleArray = out.FunApp(Ident("PrtFree"), 
											       Args(BinApp(PFLD, BinApp(FLD, out.BinApp(PFLD, Ident("p_tmp_stmt_0"), Ident("valueUnion")), Ident("tuple")), Ident("values")),
												        NIL)),
						   freeTuple = out.FunApp(Ident("PrtFree"), 
											       Args(BinApp(FLD, out.BinApp(PFLD, Ident("p_tmp_stmt_0"), Ident("valueUnion")), Ident("tuple")),
												        NIL)),
						   freeValue = out.FunApp(Ident("PrtFree"), Args(Ident("p_tmp_stmt_0"), NIL)).

    //// REMOVE
	//// Case 1: Remove from a sequence
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(REMOVE, e, _, x), 
	                       TypeOf(c, e, t), toSymbol(t) = #SeqType, LhsTrans(c, LhsPath(s, e, _), egetter), 
	                       StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs), 
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(remove, exprs))),
						   remove = out.FunApp(Ident("PrtSeqRemove"),
						                     Args(egetter,
											 Args(Ident("p_tmp_stmt_0"),
											      NIL))).

	//// Case 2: Remove from a map
	StmtTrans(c, s, cs) :- SubSE(c, s), s = in.BinStmt(REMOVE, e, _, x), 
	                       TypeOf(c, e, t), toSymbol(t) = #MapType, LhsTrans(c, LhsPath(s, e, _), egetter), 
	                       StmtExprSize(s, n), n' = n - 1, n' : Natural, LhsExprs(c, s, n', exprs), 
						   ContextLineInfo(c, s, info),
						   cs = out.Seq(info, FunApp(Ident(strJoin("P_STMT_", toString(n'))), Args(insert, exprs))),
						   insert = out.FunApp(Ident("PrtMapRemove"),
						                     Args(egetter,
											 Args(Ident("p_tmp_stmt_0"),
											      NIL))).

    /*************************************************************/
    /******                 Powers of two                   ******/
    /*************************************************************/	

	PowOf2 ::= (exp: {0..31}, val: Natural).

	PowOf2(0, 1).          PowOf2(1, 2).          PowOf2(2, 4).           PowOf2(3, 8).
	PowOf2(4, 16).         PowOf2(5, 32).         PowOf2(6, 64).          PowOf2(7, 128).
	PowOf2(8, 256).        PowOf2(9, 512).        PowOf2(10, 1024).       PowOf2(11, 2048).
	PowOf2(12, 4096).      PowOf2(13, 8192).      PowOf2(14, 16384).      PowOf2(15, 32768).
	PowOf2(16, 65536).     PowOf2(17, 131072).    PowOf2(18, 262144).     PowOf2(19, 524288).
	PowOf2(20, 1048576).   PowOf2(21, 2097152).   PowOf2(22, 4194304).    PowOf2(23, 8388608).
	PowOf2(24, 16777216).  PowOf2(25, 33554432).  PowOf2(26, 67108864).   PowOf2(27, 134217728).
	PowOf2(28, 268435456). PowOf2(29, 536870912). PowOf2(30, 1073741824). PowOf2(31, 2147483648).

    /*************************************************************/
    /******                 String conversions              ******/
    /*************************************************************/

	QualNameSub ::= sub (QualifiedName).
	QualName2CStr ::= (QualifiedName, String).
	QualName2CStr(q, s) :- QualNameSub(q), q = QualifiedName(s, NIL).
	QualName2CStr(q, sj) :- QualNameSub(q), QualName2CStr(q', s'), q = QualifiedName(s, q'), sj = strJoin(s', strJoin("_", s)).
}	