∀e0: eGrant ∀e1: eGrant :: (e0.payload.node == e1.payload.node) -> (e0.payload.epoch == e1.payload.epoch)
∀e0: eTransfer ∀e1: eGrant :: (e0.payload.node == e1.payload.node) -> (e0.payload.epoch == e1.payload.epoch)
∀e0: eTransfer :: ∃e1: eGrant :: (indexof(e0) > indexof(e1)) ∧ (e0.payload.epoch == e1.payload.epoch) ∧ (e0.payload.node == e1.payload.node)
∀e0: eTransfer ∀e1: eTransfer :: (indexof(e0) > indexof(e1)) -> (e0.payload.epoch > e1.payload.epoch) ∧ (e0.payload.node != e1.payload.node)
∀e0: eTransfer ∀e1: eTransfer :: (e0.payload.node == e1.payload.node) -> (e0.payload.epoch == e1.payload.epoch) ∧ (indexof(e0) == indexof(e1)) ∧ (e0.payload.round == e1.payload.round)
∀e0: eTransfer ∀e1: eTransfer :: (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.node != e1.payload.node) ∧ (indexof(e0) < indexof(e1))
∀e0: eTransfer ∀e1: eTransfer :: (e0.payload.round == e1.payload.round) -> (e0.payload.epoch == e1.payload.epoch) ∧ (indexof(e0) == indexof(e1)) ∧ (e0.payload.node == e1.payload.node)
∀e0: eTransfer ∀e1: eTransfer :: (e0.payload.epoch == e1.payload.epoch) -> (indexof(e0) == indexof(e1)) ∧ (e0.payload.round == e1.payload.round) ∧ (e0.payload.node == e1.payload.node)
∀e0: eNodeState ∀e1: eNodeState :: (indexof(e0) < indexof(e1)) ∧ (e0.payload.node == e1.payload.node) -> (e0.payload.epoch <= e1.payload.epoch)
∀e0: eNodeState ∀e1: eNodeState :: (e0.payload.node == e1.payload.node) ∧ e0.payload.hasLock -> (e0.payload.epoch >= e1.payload.epoch)
∀e0: eNodeState ∀e1: eNodeState :: (indexof(e0) < indexof(e1)) ∧ e1.payload.hasLock -> (e0.payload.epoch < e1.payload.epoch)
∀e0: eNodeState ∀e1: eNodeState :: (indexof(e0) > indexof(e1)) ∧ e0.payload.hasLock -> (e0.payload.epoch > e1.payload.epoch)
∀e0: eNodeState ∀e1: eNodeState :: (e0.payload.node == e1.payload.node) ∧ e1.payload.hasLock -> (e0.payload.epoch <= e1.payload.epoch)
∀e0: eNodeState ∀e1: eNodeState :: (e0.payload.node == e1.payload.node) ∧ (e0.payload.round == e1.payload.round) -> (e0.payload.epoch == e1.payload.epoch) ∧ (indexof(e0) == indexof(e1))
∀e0: eNodeState ∀e1: eNodeState :: e1.payload.hasLock ∧ (e0.payload.epoch > e1.payload.epoch) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.node != e1.payload.node)
∀e0: eNodeState ∀e1: eNodeState :: e0.payload.hasLock ∧ (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.node != e1.payload.node) ∧ (indexof(e0) < indexof(e1))
∀e0: eNodeState ∀e1: eNodeState :: e0.payload.hasLock ∧ (e0.payload.epoch == e1.payload.epoch) -> (e0.payload.node == e1.payload.node)
∀e0: eNodeState ∀e1: eNodeState :: e1.payload.hasLock ∧ (e0.payload.epoch == e1.payload.epoch) -> (e0.payload.node == e1.payload.node)
∀e0: eNodeState ∀e1: eNodeState :: e0.payload.hasLock ∧ (e0.payload.round == e1.payload.round) -> (e0.payload.epoch >= e1.payload.epoch)
∀e0: eNodeState ∀e1: eNodeState :: e1.payload.hasLock ∧ (e0.payload.round == e1.payload.round) -> (e0.payload.epoch <= e1.payload.epoch)
∀e0: eHasLock ∀e1: eTransfer :: (indexof(e0) < indexof(e1)) -> (e0.payload.epoch < e1.payload.epoch) ∧ (e0.payload.node != e1.payload.node)
∀e0: eHasLock ∀e1: eTransfer :: (e0.payload.node == e1.payload.node) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.epoch == e1.payload.epoch) ∧ (e0.payload.round == e1.payload.round)
∀e0: eHasLock ∀e1: eTransfer :: (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.node != e1.payload.node) ∧ (indexof(e0) < indexof(e1))
∀e0: eHasLock ∀e1: eTransfer :: (e0.payload.epoch > e1.payload.epoch) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.node != e1.payload.node)
∀e0: eHasLock ∀e1: eTransfer :: (e0.payload.round == e1.payload.round) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.epoch == e1.payload.epoch) ∧ (e0.payload.node == e1.payload.node)
∀e0: eHasLock ∀e1: eTransfer :: (e0.payload.epoch == e1.payload.epoch) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.round == e1.payload.round) ∧ (e0.payload.node == e1.payload.node)
∀e0: eHasLock :: ∃e1: eTransfer :: (e0.payload.node == e1.payload.node) ∧ (e0.payload.round == e1.payload.round) ∧ (e0.payload.epoch == e1.payload.epoch) ∧ (indexof(e0) > indexof(e1))
∀e0: eHasLock ∀e1: eHasLock :: (indexof(e0) > indexof(e1)) -> (e0.payload.epoch > e1.payload.epoch) ∧ (e0.payload.node != e1.payload.node)
∀e0: eHasLock ∀e1: eHasLock :: (e0.payload.epoch > e1.payload.epoch) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.node != e1.payload.node)
∀e0: eHasLock ∀e1: eHasLock :: (e0.payload.epoch == e1.payload.epoch) -> (indexof(e0) == indexof(e1)) ∧ (e0.payload.round == e1.payload.round) ∧ (e0.payload.node == e1.payload.node)
∀e0: eHasLock ∀e1: eHasLock :: (e0.payload.node == e1.payload.node) -> (e0.payload.epoch == e1.payload.epoch) ∧ (indexof(e0) == indexof(e1)) ∧ (e0.payload.round == e1.payload.round)
∀e0: eHasLock ∀e1: eHasLock :: (e0.payload.round == e1.payload.round) -> (e0.payload.epoch == e1.payload.epoch) ∧ (indexof(e0) == indexof(e1)) ∧ (e0.payload.node == e1.payload.node)
∀e0: eNodeState ∀e1: eTransfer :: (e0.payload.epoch > e1.payload.epoch) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.node != e1.payload.node)
∀e0: eNodeState ∀e1: eTransfer :: (indexof(e0) < indexof(e1)) -> (e0.payload.epoch < e1.payload.epoch)
∀e0: eNodeState ∀e1: eTransfer :: (e0.payload.epoch == e1.payload.epoch) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.node == e1.payload.node)
∀e0: eNodeState ∀e1: eTransfer :: (e0.payload.round == e1.payload.round) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.epoch <= e1.payload.epoch)
∀e0: eNodeState ∀e1: eTransfer :: (indexof(e0) > indexof(e1)) ∧ e0.payload.hasLock -> (e0.payload.epoch >= e1.payload.epoch)
∀e0: eNodeState ∀e1: eTransfer :: (indexof(e0) < indexof(e1)) ∧ e0.payload.hasLock -> (e0.payload.node != e1.payload.node)
∀e0: eNodeState ∀e1: eTransfer :: (e0.payload.node == e1.payload.node) ∧ e0.payload.hasLock -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.epoch == e1.payload.epoch) ∧ (e0.payload.round == e1.payload.round)
∀e0: eNodeState ∀e1: eTransfer :: e0.payload.hasLock ∧ (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.node != e1.payload.node) ∧ (indexof(e0) < indexof(e1))
∀e0: eNodeState ∀e1: eTransfer :: e0.payload.hasLock ∧ (e0.payload.round == e1.payload.round) -> (e0.payload.epoch == e1.payload.epoch) ∧ (e0.payload.node == e1.payload.node)
∀e0: eNodeState ∀e1: eTransfer :: e0.payload.hasLock ∧ (e0.payload.epoch == e1.payload.epoch) -> (e0.payload.round == e1.payload.round)
∀e0: eNodeState ∀e1: eTransfer :: !(e0.payload.hasLock) ∧ (e0.payload.round == e1.payload.round) -> (e0.payload.epoch < e1.payload.epoch) ∧ (e0.payload.node != e1.payload.node)
∀e0: eNodeState :: ∃e1: eTransfer :: (e0.payload.round == e1.payload.round) ∧ (e1.payload.epoch >= e0.payload.epoch) ∧ (indexof(e0) > indexof(e1))
∀e0: eNodeState :: e0.payload.hasLock -> ∃e1: eTransfer :: (e0.payload.round == e1.payload.round) ∧ (e0.payload.epoch == e1.payload.epoch) ∧ (e0.payload.node == e1.payload.node) ∧ (indexof(e0) > indexof(e1))
∀e0: eNodeState :: !(e0.payload.hasLock) -> ∃e1: eTransfer :: (e0.payload.round == e1.payload.round) ∧ (e0.payload.epoch < e1.payload.epoch) ∧ (indexof(e0) > indexof(e1))
∀e0: eHasLock ∀e1: eNodeState :: (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.node != e1.payload.node) ∧ (indexof(e0) < indexof(e1))
∀e0: eHasLock ∀e1: eNodeState :: (indexof(e0) > indexof(e1)) -> (e0.payload.epoch > e1.payload.epoch)
∀e0: eHasLock ∀e1: eNodeState :: (e0.payload.epoch == e1.payload.epoch) -> (indexof(e0) < indexof(e1)) ∧ (e0.payload.node == e1.payload.node)
∀e0: eHasLock ∀e1: eNodeState :: (e0.payload.round == e1.payload.round) -> (e0.payload.epoch >= e1.payload.epoch) ∧ (indexof(e0) < indexof(e1))
∀e0: eHasLock ∀e1: eNodeState :: (e0.payload.node == e1.payload.node) ∧ e1.payload.hasLock -> (e0.payload.epoch == e1.payload.epoch) ∧ (e0.payload.round == e1.payload.round)
∀e0: eHasLock ∀e1: eNodeState :: (indexof(e0) > indexof(e1)) ∧ e1.payload.hasLock -> (e0.payload.node != e1.payload.node)
∀e0: eHasLock ∀e1: eNodeState :: (indexof(e0) < indexof(e1)) ∧ (e0.payload.node == e1.payload.node) -> (e0.payload.epoch == e1.payload.epoch)
∀e0: eHasLock ∀e1: eNodeState :: (indexof(e0) < indexof(e1)) ∧ e1.payload.hasLock -> (e0.payload.epoch <= e1.payload.epoch)
∀e0: eHasLock ∀e1: eNodeState :: e1.payload.hasLock ∧ (e0.payload.round == e1.payload.round) -> (e0.payload.epoch == e1.payload.epoch) ∧ (e0.payload.node == e1.payload.node)
∀e0: eHasLock ∀e1: eNodeState :: e1.payload.hasLock ∧ (e0.payload.epoch == e1.payload.epoch) -> (e0.payload.round == e1.payload.round)
∀e0: eHasLock ∀e1: eNodeState :: e1.payload.hasLock ∧ (e0.payload.epoch > e1.payload.epoch) -> (indexof(e0) > indexof(e1)) ∧ (e0.payload.node != e1.payload.node)
∀e0: eHasLock ∀e1: eNodeState :: !(e1.payload.hasLock) ∧ (e0.payload.round == e1.payload.round) -> (e0.payload.epoch > e1.payload.epoch) ∧ (e0.payload.node != e1.payload.node)
∀e0: eHasLock :: ∃e1: eNodeState :: (indexof(e0) < indexof(e1)) ∧ e1.payload.hasLock ∧ (e0.payload.epoch == e1.payload.epoch) ∧ (e0.payload.round == e1.payload.round) ∧ (e1.payload.epoch >= e0.payload.epoch) ∧ (e0.payload.node == e1.payload.node)
∀e0: eHasLock :: ∃e1: eNodeState :: !(e1.payload.hasLock) ∧ (e0.payload.round == e1.payload.round) ∧ (e0.payload.epoch > e1.payload.epoch) ∧ (indexof(e0) < indexof(e1))
∀e0: eNodeState ∀e1: eNodeState :: (indexof(e0) < indexof(e1)) ∧ (e0.payload.round == e1.payload.round) -> (e1.payload.hasLock == False) ∧ (e0.payload.node != e1.payload.node)
∀e0: eNodeState ∀e1: eNodeState :: (indexof(e0) < indexof(e1)) ∧ (e0.payload.epoch > e1.payload.epoch) -> (e1.payload.hasLock == False) ∧ (e0.payload.node != e1.payload.node)
∀e0: eNodeState ∀e1: eNodeState :: (e0.payload.node == e1.payload.node) ∧ (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.hasLock == False) ∧ (indexof(e0) < indexof(e1))
∀e0: eNodeState ∀e1: eNodeState :: (e0.payload.round == e1.payload.round) ∧ (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.hasLock == False) ∧ (e0.payload.node != e1.payload.node)
∀e0: eNodeState ∀e1: eTransfer :: (e0.payload.node == e1.payload.node) ∧ (e0.payload.round == e1.payload.round) -> (e0.payload.hasLock == True) ∧ (e0.payload.epoch == e1.payload.epoch)
∀e0: eNodeState ∀e1: eTransfer :: (e0.payload.round == e1.payload.round) ∧ (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.hasLock == False) ∧ (e0.payload.node != e1.payload.node)
∀e0: eHasLock ∀e1: eNodeState :: (indexof(e0) < indexof(e1)) ∧ (e0.payload.epoch > e1.payload.epoch) -> (e1.payload.hasLock == False) ∧ (e0.payload.node != e1.payload.node)
∀e0: eHasLock ∀e1: eNodeState :: (e0.payload.node == e1.payload.node) ∧ (e0.payload.round == e1.payload.round) -> (e1.payload.hasLock == True) ∧ (e0.payload.epoch == e1.payload.epoch)
∀e0: eHasLock ∀e1: eNodeState :: (e0.payload.node == e1.payload.node) ∧ (e0.payload.epoch > e1.payload.epoch) -> (e1.payload.hasLock == False) ∧ (indexof(e0) > indexof(e1))
∀e0: eHasLock ∀e1: eNodeState :: (e0.payload.round == e1.payload.round) ∧ (e0.payload.epoch > e1.payload.epoch) -> (e1.payload.hasLock == False) ∧ (e0.payload.node != e1.payload.node)
∀e0: eNodeState ∀e1: eNodeState :: (indexof(e0) < indexof(e1)) ∧ (e0.payload.epoch == e1.payload.epoch) -> (e1.payload.hasLock == False)
∀e0: eNodeState ∀e1: eTransfer :: (indexof(e0) < indexof(e1)) ∧ (e0.payload.node == e1.payload.node) -> (e0.payload.hasLock == False)
∀e0: eNodeState ∀e1: eTransfer :: (indexof(e0) > indexof(e1)) ∧ (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.hasLock == False)
∀e0: eNodeState ∀e1: eTransfer :: (e0.payload.node == e1.payload.node) ∧ (e0.payload.epoch < e1.payload.epoch) -> (e0.payload.hasLock == False)
∀e0: eNodeState ∀e1: eTransfer :: (e0.payload.round == e1.payload.round) ∧ (e0.payload.epoch == e1.payload.epoch) -> (e0.payload.hasLock == True)
∀e0: eHasLock ∀e1: eNodeState :: (indexof(e0) > indexof(e1)) ∧ (e0.payload.node == e1.payload.node) -> (e1.payload.hasLock == False)
∀e0: eHasLock ∀e1: eNodeState :: (e0.payload.round == e1.payload.round) ∧ (e0.payload.epoch == e1.payload.epoch) -> (e1.payload.hasLock == True)
