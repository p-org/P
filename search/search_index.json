{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Formal Modeling and Analysis of Distributed Systems <p>Challenge: Distributed systems are notoriously hard to get right. Programming these systems is challenging because of the need to reason about correctness in the presence of myriad possible interleaving of messages and failures. Unsurprisingly, it is common for service teams to uncover correctness bugs after deployment. Formal methods can play an important role in addressing this challenge!</p> <p>P Overview: P is a state machine based programming language for formally modeling and specifying complex distributed systems. P allows programmers to model their system design as a collection of communicating state machines. P supports several backend analysis engines (based on automated reasoning techniques like model checking and symbolic execution) to check that the distributed system modeled in P satisfy the desired correctness specifications.</p> <p>If you are wondering \"why do formal methods at all?\" or \"how is AWS using P to gain confidence in correctness of their services?\", the following re:Invent 2023 talk answers this question, provides an overview of P, and its impact inside AWS: (Re:Invent 2023 Talk) Gain confidence in system correctness &amp; resilience with Formal Methods (Finding Critical Bugs Early!!)</p> <p>Impact: P is currently being used extensively inside Amazon (AWS) for analysis of complex distributed systems. For example, Amazon S3 used P to formally reason about the core distributed protocols involved in its strong consistency launch. Teams across AWS are now using P for thinking and reasoning about their systems formally. P is also being used for programming safe robotics systems in Academia. P was first used to implement and validate the USB device driver stack that ships with Microsoft Windows 8 and Windows Phone.</p> <p>Experience and lessons learned: In our experience of using P inside AWS, Academia, and Microsoft. We have observed that P has helped developers in three critical ways: (1) P as a thinking tool: Writing formal specifications in P forces developers to think about their system design rigorously, and in turn helped in bridging gaps in their understanding of the system. A large fraction of the bugs can be eliminated in the process of writing specifications itself! (2) P as a bug finder: Model checking helped find corner case bugs in system design that were missed by stress and integration testing. (3) P helped boost developer velocity: After the initial overhead of creating the formal models, future updates and feature additions could be rolled out faster as these non-trivial changes are rigorously validated before implementation.</p> <p> Programming concurrent, distributed systems is fun but challenging, however, a pinch of programming language design with a dash of automated reasoning can go a long way in addressing the challenge and amplifying the fun!. </p>"},{"location":"#let-the-fun-begin","title":"Let the fun begin!","text":"<p>You can find most of the information about the P framework on this webpage: what is P?, getting started, tutorials, case studies and related research publications. If you have any further questions, please feel free to create an issue, ask on discussions, or email us</p> <p>Contributions</p> <p>P has always been a collaborative project between industry and academia (since 2013) . The P team welcomes contributions and suggestions from all of you!! .</p>"},{"location":"casestudies/","title":"Case Studies","text":""},{"location":"casestudies/#aws-amazon-s3-strong-consistency","title":"[AWS] Amazon S3 Strong Consistency","text":"<p>In Dec 2020, Amazon S3 launched Strong Consistency with guaranteed strong read-after-write consistency. The S3 team leveraged automated reasoning for ensuring the correctness of S3's Strong Consistency design. Werner had a detailed blog post about the challenges involved.</p> <p>Qoute from Werners blog: Diving Deep on S3 Consistency</p> <p>Common testing techniques like unit testing and integration testing are valuable, necessary tools in any production system. But they aren\u2019t enough when you need to build a system with such a high bar for correctness. We want a system that\u2019s \u201cprovably correct\u201d, not just \u201cprobably correct.\u201d So, for strong consistency, we utilized a variety of techniques for ensuring that what we built is correct, and continues to be correct as the system evolves. We employed integration tests, deductive proofs of our proposed cache coherence algorithm, model checking to formalize our consistency design and to demonstrate its correctness, and we expanded on our model checking to examine actual runnable code.</p> <p>P was used for creating formal models of all the core distributed protocols involved in S3's strong consistency and checking that the system model satisfies the desired correctness guarantees. Details about P and how it is being used by the S3 team can be found in the AWS Pi-Week Talk: Use of Automated Reasoning for S3 Strong Consistency Launch.</p>"},{"location":"casestudies/#aws-amazon-iot-devices-ota-protocol","title":"[AWS] Amazon IoT Devices: OTA Protocol","text":"<p>AWS FreeRTOS is a real-time operating system designed to run on IoT devices to enable them to interact easily and reliably with AWS services. The Over the Air (OTA) update functionality makes it possible to update a device with security fixes quickly and reliably. The OTA Library, a part of the overall OTA functionality that runs on the IoT devices, enables customers to learn of available updates, download the updates, check their cryptographic signatures, and apply them. The OTA system is a complex piece of software that performs firmware updates reliably and securely --- keeping all devices in a consistent state --- in the presence of arbitrary failures of devices and communication. The heart of the OTA system is an intricate distributed protocol, the OTA protocol, that co-ordinates the execution of the different agents involved.</p> <p>P was used for creating formal models of the OTA protocol and checking its correctness. During this process the team found 3 bugs in the model that pointed to potential issues in the actual implementation itself.</p> <p>Related Blog: Using Formal Methods to validate OTA Protocol</p>"},{"location":"casestudies/#uc-berkeley-programming-safe-robotics-systems","title":"[UC Berkeley] Programming Safe Robotics Systems","text":"<p>DRONA is a software framework for programming safe distributed mobile robotics systems. DRONA uses P language for implementing and model-checking the correctness of robotics software stack. The C code generated from P compiler can be deployed on Robot Operating System (ROS). More details about the DRONA framework and simulation videos are available here: https://drona-org.github.io/Drona/</p> <p>See the fun demo video using P to control a quadrocopter and make sense of the MavLink stream, all visualized in a live DGML diagram.</p>"},{"location":"casestudies/#uc-berkeley-programming-secure-distributed-systems","title":"[UC Berkeley] Programming Secure Distributed Systems","text":"<p>Programming secure distributed systems that have a formal guarantee of no information leakage is challenging. PSec framework extended the P language to enable programming secure distributed systems. PSec leverages Intel SGX enclaves to ensure that the security guarantees provided by the P language are enforced at runtime. By combining information flow control with hardware enclaves, PSec prevents programmers from inadvertently leaking sensitive information while sending data securely across machines. PSec was used to program several real-world examples, including a One Time Passcode application and a Secure Electronic Voting System. Details about the PSec framework can be found here.</p>"},{"location":"casestudies/#microsoft-windows-usb-30-device-drivers","title":"[Microsoft] Windows USB 3.0 Device Drivers","text":"<p>Event-driven asynchronous programs typically have layers of design, where the higher layers reason with how the various components (or machines) interact, and the protocol they follow, and where as lower layers manage more data-intensive computations, controlling local devices, etc. However, the programs often get written in traditional languages that offer no mechanisms to capture these abstractions, and hence over time leads to code where the individual layers are no longer discernible. High-level protocols, though often first designed on paper using clean graphical state-machine abstractions, eventually get lost in code, and hence verification tools for such programs face the daunting task of extracting these models from the programs. The natural solution to the above problem is to build a programming language for asynchronous event-driven programs that preserves the protocol abstractions in code. Apart from the difficulty in designing such a language, this task is plagued by the reluctance of programmers to adopt a new language of programming and the discipline that it brings. However, this precise solution was pioneered by the P programming framework, where, during the development of Windows 8, the team building the USB driver stack used P for modeling, implementing, and model-checking of the USB 3.0 device drivers (paper)</p> <p>Related Blog:</p> <ul> <li>Building robust USB 3.0 support</li> <li>P: A programming language designed for asynchrony, fault-tolerance and uncertainty</li> </ul>"},{"location":"manualoutline/","title":"P Program (Outline)","text":"<p>We recommend that you start with the Tutorials to get familiar with the P language and its tool chain.</p> P Top Level Declarations Grammar <pre><code>topDecl:                # Top-level P Program Declarations\n| typeDecl              # UserDefinedTypeDeclaration\n| enumTypeDecl          # EnumTypeDeclaration\n| eventDecl             # EventDeclaration\n| machineDecl           # MachineDeclaration\n| specDecl              # SpecDeclaration\n| funDecl               # GlobalFunctionDeclaration\n| moduleDecl            # ModuleDeclaration\n| testDecl              # TestCaseDeclaration\n;\n</code></pre> <p>A P program consists of a collection of following top-level declarations:</p> Top Level Declarations Description User Defined Types P supports users defined types as well as foreign types (types that are defined in external language) Enums P supports declaring enum values that can be used as int constants (update the link) Events Events are used by state machines to communicate with each other State Machines P state machines are used to model or implement the behavior of the system Specification Monitors P specification monitors are used to write the safety and liveness specifications the system must satisfy for correctness Global Functions P supports declaring global functions that can be shared across state machines and spec monitors Module System P supports a module system for implementing and testing the system modularly by dividing it into separate components Test Cases P test cases help programmers to write different finite scenarios under which they would like to check the correctness of their system <p>Models, Specifications, Model Checking Scenario</p> <p>A quick primer on what a model is, versus a specification, and model checking scenarios: (1) A specification says what the system should do (correctness properties). (2) A model captures the details of how the system does it. (3) A model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications.</p>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#p-language-and-backend-analysis","title":"P Language and Backend Analysis","text":"<ol> <li> <p>Compositional Programming and Testing of Dynamic Distributed Systems. Ankush Desai, Amar Phanishayee, Shaz Qadeer, and Sanjit Seshia   International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2018.</p> </li> <li> <p>Lasso detection using Partial State Caching. Rashmi Mudduluru, Pantazis Deligiannis, Ankush Desai, Akash Lal and Shaz Qadeer. Formal   Methods in Computer-Aided Design (FMCAD) - 2017</p> </li> <li> <p>Systematic Testing of Asynchronous Reactive Systems. Ankush Desai, Shaz Qadeer, and Sanjit A. Seshia.  Proceedings of the 2015 10th Joint   Meeting on Foundations of Software Engineering (ESEC/FSE 2015).</p> </li> <li> <p>Natural proofs for Asynchronous Programs using Almost-synchronous Invariants. Ankush Desai, Pranav Garg, and P. Madhusudan.  International Conference on Object-Oriented   Programming, Systems, Languages, and Applications (OOPSLA) - 2014</p> </li> <li> <p>P: Safe asynchronous event-driven programming. Ankush Desai, Vivek Gupta, Ethan Jackson, Shaz Qadeer, Sriram Rajamani, and Damien   Zufferey.  Proceedings of ACM SIGPLAN Conference on Programming Language Design and   Implementation (PLDI), 2013.</p> </li> <li> <p>Depth bounded explicit-state model checking. Abhishek Udupa, Ankush Desai and Sriram Rajamani.   International SPIN Symposium on Model Checking of Software (SPIN) - 2011</p> </li> </ol>"},{"location":"publications/#p-case-studies","title":"P Case Studies","text":"<ol> <li> <p>PSec: Programming Secure Distributed Systems using Enclaves. Shivendra Kushwah, Ankush Desai, Pramod Subramanyan, Sanjit A. Seshia.    Proceedings of the   2021 ACM Asia Conference on Computer and Communications Security (AsiaCCS) - 2021</p> </li> <li> <p>Programming Safe Robotics Systems: Challenges and Advances.   Ankush Desai, Shaz Qadeer and Sanjit Seshia. International Symposium On Leveraging   Applications of Formal Methods, Verification and Validation (ISoLA) - 2018</p> </li> <li> <p>DRONA: A Framework for Safe Distributed Mobile Robotics. Ankush Desai, Indranil Saha, Jianqiao Yang, Shaz Qadeer, and Sanjit A. Seshia.    Proceedings of the 8th ACM/IEEE International Conference on Cyber-Physical Systems   (ICCPS), 2017.</p> </li> <li> <p>Combining Model Checking and Runtime Verification for Safe Robotics. Ankush Desai, Tommaso Dreossi and Sanjit Seshia. The 17th International Conference on   Runtime Verification (RV) - 2017</p> </li> <li> <p>Approximate Synchrony: An Abstraction for Distributed Almost-synchronous Systems. Ankush Desai, Sanjit Seshia, Shaz Qadeer, David Broman, and John Eidson. International   Conference on Computer Aided Verification (CAV) - 2015</p> </li> <li> <p>Endlessly Circulating Messages in IEEE 1588-2008 Systems. David Broman, P Derler, Ankush Desai, John Eidson, and Sanjit Seshia. International   Symposium on Precision Clock Synchronization for Measurement, Control and Communication   (ISPCS) - 2014</p> </li> </ol>"},{"location":"publications/#phd-thesis","title":"PhD Thesis","text":"<ul> <li>Modular and Safe Event-Driven Programming. Ankush Desai University of California, Berkeley - 2019.</li> </ul>"},{"location":"tutsoutline/","title":"Outline","text":"<p>P Language Semantics</p> <p>Before we get started with the tutorials, please read this to get an informal overview of the P language semantics.</p> <p>In this tutorial, we use a series of examples along with exercise problems to help you get familiar with the P language and the associated tool chain.</p> <p>How to use this tutorial</p> <p>We recommend that you work through these examples one-by-one by solving the accompanying exercise problems before moving to the next example. If you have any doubts or questions, please feel free to ask them in discussions or create an issue.</p> <p>Also, we assume that you have cloned the P repository locally. <pre><code>git clone https://github.com/p-org/P.git\n</code></pre></p> <p>The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program.</p> <p>To know more about P language primitives used in the examples, please look them up in the language manual.</p>"},{"location":"tutsoutline/#example-1-client-server","title":"[Example 1] Client Server","text":"<p>We start with a simple client-server example consisting of clients interact with a bank server to withdraw money from their account. The bank server uses a backend database service to store the account balance for its clients. We will use this example to demonstrate how to implement such a system as a collection of P state machines and also check the correctness property that the bank always responds with the correct account balance for a client and a withdraw request always succeeds if there is enough balance in the account. We will also use P's capability to write multiple model checking scenarios and demonstrate how one can replace components in P with its abstraction.</p> <p>What will we learn through this example?</p> <p>We will learn about P state machines, writing simple safety and liveness specifications as P monitors, writing multiple model checking scenarios to check the correctness of a P program, and finally, replacing complex components in P with their abstractions using P's module system.</p> <p>Now that we understand the basic features of the P language, lets spice things up by looking at a well-known distributed protocol, and the obvious choice is to start with the textbook example of a two-phase commit protocol !</p>"},{"location":"tutsoutline/#example-2-two-phase-commit","title":"[Example 2] Two Phase Commit","text":"<p>We use a simplified version of the classic two phase commit protocol to model a transaction commit service. The protocol uses a (single) coordinator to achieve consensus for a transaction spanning across multiple participants. A transaction in our case is simply a <code>put</code> operation for a key-value data store where the data store is replicated across participants.</p> <p>Assumptions: Note that our transaction commit system is ridiculously simplified, for example, it is not fault tolerant to node failures, failure of either coordinator or any of the participants will block the progress forever. Also, we rely on P's send semantics to model the behavior of the underlying network.</p> <p>What will we learn through this example?</p> <p>We will use this example to dive deeper into: (1) modeling non-determinism in distributed systems, in particular, time-outs (2) writing complex safety properties like atomicity of transactions in P and finally, (3) modeling node failures in P using a failure injector state machine. We will also show how P allows invoking foreign code from the P programs. More details in P foreign interface.</p> <p>Wow! we have reached the middle of our tutorials   , its time to take a break and have an espresso coffee!  </p> <p>In the next example, instead of modeling a distributed protocol, we consider the fun example of modeling an espresso machine and see how we can use P state machines to model a reactive system that must respond correctly to various user inputs.</p>"},{"location":"tutsoutline/#example-3-espresso-machine","title":"[Example 3] Espresso Machine","text":"<p>P has been used in the past to implement device drivers and robotics systems (case studies and publications). One of the many challenges in implementing these systems is that they are reactive system and hence, must handle various streams of events (inputs) appropriately depending on their current mode of operation. In this example, we consider the example of an Espresso coffee machine where the user interacts with the coffee machine through its control panel. The control panel must correctly interprets inputs from the user and sends commands to the coffee maker. We use this example to demonstrate how using P state machine, one can capture the required reactive behavior of a coffee maker and define how it must handle different user inputs.</p> <p>What will we learn through this example?</p> <p>This is a just for fun example to demonstrate how to model a reactive system as a P state machine. We also show how using P monitors we can check that the system moves through the correct modes of operation.</p> <p>Energized with the Coffee , lets get back to distributed systems. After the two phase commit protocol, the next protocol that we will jump to is a simple broadcast-based failure detector! By this point in the tutorial, we have gotten familiar with the P language and most of its features. So, working through this example should be super fast!</p>"},{"location":"tutsoutline/#example-4-failure-detector","title":"[Example 4] Failure Detector","text":"<p>We use a broadcast based failure detector to show how to model lossy network and node failures in P. The failure detector basically broadcasts ping messages to all nodes in the system and uses a timer to wait for a pong response from all nodes. If certain node does not respond with a pong message after multiple attempts, the failure detector marks the node as down and notifies the clients. We check using a liveness specification that if the failure injecter shutsdown a particular node then the failure detector always eventually detects that node has failed and notifies the client.</p> <p>What will we learn through this example?</p> <p>In this example, we demonstrate how to use data nondeterminism to model message loss, unreliable sends, and node failures. We also discuss how to model other types of network nondeterminism. Finally, we give an example of a liveness specification that the failure detector must satisfy.</p>"},{"location":"tutsoutline/#common-timer-failure-injector-and-shared-memory","title":"[Common] Timer, Failure Injector, and Shared Memory","text":"<p>We have described how to model system's interaction with an OS Timer Timer, and how to model injecting node failures in the system Failure Injector. These models are used in the Two Phase Commit, Espresso Machine, and Failure Detector examples.</p> <p>P is a purely messaging passing based programming language and hence does not support primitives for modeling shared memory based concurrency. But one can always model shared memory concurrency using message passing. We have used this style of modeling when checking the correctness of single node file systems. Please check out Shared Memory example for how to model shared memory concurrency using P.</p> <p> Alright, alright, alright ... lets go! </p>"},{"location":"videos/","title":"Videos","text":""},{"location":"videos/#introductory-tutorial-on-p","title":"Introductory tutorial on P","text":"<p>Background and motivation behind P :: what worked and what didn't: Apple Podcast and Youtube Podcast.</p>"},{"location":"videos/#tech-talks-and-presentations","title":"Tech Talks and Presentations","text":"<ul> <li> <p>AWS Pi-Week Talk on \"Amazon S3 Strong Consisteny\"</p> </li> <li> <p>Compositional Programming and Testing of Distributed Systems (OOPSLA, 2018)</p> </li> <li> <p>Programming Safe Robotics Systems (BAIR Talk)</p> </li> </ul>"},{"location":"whatisP/","title":"What is P?","text":"<p>Distributed systems are notoriously hard to get right (i.e., guaranteeing correctness) as the programmer needs to reason about numerous control paths resulting from the myriad interleaving of events (or messages or failures). Unsurprisingly, programmers can easily introduce subtle errors when designing these systems. Moreover, it is extremely difficult to test distributed systems, as most control paths remain untested, and serious bugs lie dormant for months or even years after deployment.</p> <p>The P programming framework takes several steps towards addressing these challenges by providing a unified framework for modeling, specifying, implementing, testing, and verifying complex distributed systems.</p>"},{"location":"whatisP/#p-framework","title":"P Framework","text":"<p>The P framework can be divided into three important parts:</p>"},{"location":"whatisP/#p-language","title":"P Language","text":"<p>P provides a high-level state machine based programming language to formally model and specify distributed systems. The syntactic sugar of state machines allows programmers to capture their system design (or protocol logic) as communicating state machines, which is how programmers generally think about their system's design. P is more of a programming language than a mathematical modelling language and hence, making it easier for the programmers to both: (1) create formal models that are closer to the implementation (sufficiently detailed) and also (2) maintain these models as the system design evolves. P supports specifying and checking both safety as well as liveness specifications (global invariants). Programmers can easily write different scenarios under which they would like to check that the system satisfies the desired correctness specification. The P module system enables programmers to model their system modularly and perform compositional testing to scale the analysis to large distributed systems.</p> <p>Models, Specifications, Model Checking Scenario</p> <p>A quick primer on what a model is, versus a specification, and model checking scenarios: (1) a specification says what the system should do (correctness properties); (2) a model captures the details of how the system does it; (3) a model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications.</p> <p>The underlying model of computation for P programs is communicating state machines (or actors). The detailed formal semantics for P can be found here and an informal discussion here.</p>"},{"location":"whatisP/#backend-analysis-engines","title":"Backend Analysis Engines","text":"<p>P provides a backend analysis engine to systematically explore behaviors of the system model (resulting from interleaving of messages and failures) and check that the model satisfies the desired correctness specifications. To reason about complex distributed systems, the P checker needs to tackle the well-known problem of state space explosion. The P checker employs search prioritization heuristics to drive the exploration along different parts of the state space that are most likely to have concurrency related issues. The P checker is really efficient at uncovering deep bugs (i.e., bugs that require complex interleaving of events) in the system design that have a really low probability of occurrence in real-world. On finding a bug, the checker provides a reproducible error-trace which the programmer can use for debugging.</p> <p>Although the current P checker is great at finding deep-hard-to-find bugs (\"Heisenbugs\"), it cannot provide a proof of correctness. We are actively working on addressing this challenge and are building two new backends for P. First, a symbolic execution engine that can scale the P checker to models of large distributed systems and provide sound guarantees of exploring all possible behaviors. Second, a deductive verification engine to perform mathematical proof of correctness for P programs. Both these backends will be released publicly soon.</p>"},{"location":"whatisP/#code-generation","title":"Code Generation","text":"<p>The P compiler currently generates C# and C code. The generated code when combined with the P Runtime (that executes the P state machines) can be deployed on any target platform. The generated C code has been used to program device drivers and robotics systems. The generated C# code has been used to program distributed systems.</p> <p>We are currently working on adding support for a Java backend for P. We will also be adding support for generating runtime monitors for specifications that can be then used to check if the implementation conforms to the high-level P specifications.</p>"},{"location":"advanced/PProject/","title":"P Project File","text":"<p>The current project file interface is a simple mechanism to provide all the required inputs to the compiler in XML format.</p> <p>The P project file below is taken from the TwoPhaseCommit example in Tutorials.</p> <pre><code>&lt;!-- P project file for the Two Phase Commit example --&gt;\n&lt;Project&gt;\n&lt;ProjectName&gt;TwoPhaseCommit&lt;/ProjectName&gt;\n&lt;InputFiles&gt;\n    &lt;PFile&gt;./PSrc/&lt;/PFile&gt;\n    &lt;PFile&gt;./PSpec/&lt;/PFile&gt;\n    &lt;PFile&gt;./PTst/&lt;/PFile&gt;\n    &lt;PFile&gt;./PForeign/&lt;/PFile&gt;\n&lt;/InputFiles&gt;\n&lt;OutputDir&gt;./PGenerated/&lt;/OutputDir&gt;\n&lt;!-- Add the dependencies for the Timer machine --&gt;\n&lt;IncludeProject&gt;../Common/Timer/Timer.pproj&lt;/IncludeProject&gt;\n&lt;!-- Add the dependencies for the FailureInjector machine --&gt;\n&lt;IncludeProject&gt;../Common/FailureInjector/FailureInjector.pproj&lt;/IncludeProject&gt;\n&lt;/Project&gt;\n</code></pre> <p>The <code>&lt;InputFiles&gt;</code> block provides all the P files that must be compiled together for this project. In <code>&lt;PFile&gt;</code>, you can either specify the path to the P file or to a folder and the P compiler includes all the files in the folder during compilation. The <code>&lt;ProjectName&gt;</code> block provides the name for the project which is used as the output file name. The <code>&lt;OutputDir&gt;</code> block provides the output directory for the generated code. Finally, <code>&lt;IncludeProject&gt;</code> block provides path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects and compiles them together. This feature provides a way to split the P models for a large system into subprojects that can share models.</p>"},{"location":"advanced/debuggingerror/","title":"Debugging Error Traces (counter examples)","text":"<p>If you are using an older P version 1.x.x, please find the usage guide here</p> <p>As described in the using P compiler and checker section, running the following command for the ClientServer example finds an error.</p> <pre><code>p check -tc tcAbstractServer -s 100\n</code></pre> Expected Output <pre><code>$ p check -tc tcAbstractServer -s 100\n\n.. Searching for a P compiled file locally in the current folder\n.. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n.. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n.. Test case :: tcAbstractServer\n... Checker is using 'random' strategy (seed:3584517644).\n..... Schedule #1\nChecker found a bug.\n... Emitting traces:\n..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.txt\n..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.trace.json\n..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.dgml\n..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.schedule\n... Elapsed 0.2196562 sec.\n... Emitting coverage reports:\n..... Writing PCheckerOutput/BugFinding/ClientServer.dgml\n..... Writing PCheckerOutput/BugFinding/ClientServer.coverage.txt\n..... Writing PCheckerOutput/BugFinding/ClientServer.sci\n... Checking statistics:\n..... Found 1 bug.\n... Scheduling statistics:\n..... Explored 1 schedule\n..... Found 100.00% buggy schedules.\n..... Number of scheduling points in terminating schedules: 87 (min), 87 (avg), 87 (max).\n... Elapsed 0.4099731 sec.\n. Done\n~~ [PTool]: Thanks for using P! ~~\n</code></pre> <p>The P checker on finding a bug generates two artifacts (highlighted in the expected output above):</p> <ol> <li>A textual trace file (e.g., <code>ClientServer_0_0.txt</code>) that has the readable error trace representing the sequence of steps from the intial state to the error state.</li> <li>A schedule file (e.g., <code>ClientServer_0_0.schedule</code>) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging.</li> </ol>"},{"location":"advanced/debuggingerror/#error-trace","title":"Error Trace","text":"<p>The <code>*.txt</code> file contains a textual error trace representing the sequence of steps (i.e, messages sent, messages received, machines created) from the initial state to the final error state. In the end of the error trace is the final error message, for example, in the case of ClientServer example above, you must see the following in the end of the error trace.</p> <pre><code>&lt;ErrorLog&gt; Assertion Failed: PSpec/BankBalanceCorrect.p:76:9 Bank must accept the withdraw request for 1, bank balance is 11!\n</code></pre> <p>In most cases, you can ignore the stack trace and information below the <code>ErrorLog</code>.</p>"},{"location":"advanced/debuggingerror/#replaying-the-error-schedule","title":"Replaying the Error Schedule","text":"<p>One can also replay the error schedule using commandline and enabling verbose feature to dump out the error trace on the commandline.</p> <pre><code>p check --replay &lt;buggy&gt;.schedule -tc &lt;testcaseName&gt; -v\n</code></pre> <p>For example,</p> <pre><code>p check --replay PCheckerOutput/BugFinding/ClientServer_0_0.schedule \\\n -tc tcAbstractServer \\\n -v\n</code></pre>"},{"location":"advanced/importanceliveness/","title":"Importance of Liveness Specifications","text":"<p>When reasoning about the correctness of a distributed system, it is really important to specify both safety as well as liveness specifications.</p> <p>The examples in Tutorials show how to specify both safety and liveness specifications using P Monitors.</p> <p>Always specify both safety and liveness specifications</p> <p>Only specifying safety property for a system is not enough, this is mainly because, a system model may be incorrect and in the worst case drop all requests on to the ether and not perform any operation. Such a system trivially satisfies all correctness specifications! Hence, it becomes essential to combine that safety property with liveness properties to check that the system is making progress and servicing the requests. Running the checker on models that have both safety and liveness properties ensures that for all executions explored by the checker, requests are eventually serviced by the system (by sending responses potentially) and all the responses sent by the system satisfy the desired correctness safety specification. This helps ensure that your models are not doing something trivially incorrect like always doing nothing , in which case running the checker on such a model adds no value.</p> <p>For example, in the case of the client server example, the BankBalanceIsAlwaysCorrect safety property checks that the response sent by the bank server is always correct and combining it with the GuaranteedWithDrawProgress liveness property ensures that system will always eventually send a response which will be checked for correctness by the safety property.</p>"},{"location":"advanced/p2c/","title":"P2c","text":""},{"location":"advanced/p2c/#generating-c-program","title":"Generating C Program","text":"<p>P programs can be compiled to their C equivalents. Compilation to C can be performed by specifying the target language to the P compiler as follow.</p> <pre><code>pc -generate:C myProgram.p\n</code></pre> <p>Executing this command generates two files in the current directory: <code>myProgram.h</code> and <code>myProgram.c</code>, which are the C equivalent of the P program.</p>"},{"location":"advanced/p2c/#compiling-generated-c-program","title":"Compiling Generated C Program","text":"<p><code>myProgram.h</code> and <code>myProgram.c</code> only contain C representations of the constructs defined in the P program; therefore, a driver C program defining the main function and instantiating one of the machines is needed to start the execution. Below, an example driver program is presented.</p> <pre><code>#include \"myProgram.h\"\n#include \"Prt.h\"\n#include &lt;stdio.h&gt;\n\nPRT_PROCESS* MAIN_P_PROCESS;\nstatic PRT_BOOLEAN cooperative = PRT_TRUE;\nstatic int threads = 2;\nlong threadsRunning = 0;\npthread_mutex_t threadsRunning_mutex;\n\nstatic const char* parg = NULL;\n\nvoid ErrorHandler(PRT_STATUS status, PRT_MACHINEINST* ptr) {\n    if (status == PRT_STATUS_ASSERT) {\n        fprintf_s(stdout, \"exiting with PRT_STATUS_ASSERT (assertion failure)\\n\");\n        exit(1);\n    } else if (status == PRT_STATUS_EVENT_OVERFLOW) {\n        fprintf_s(stdout, \"exiting with PRT_STATUS_EVENT_OVERFLOW\\n\");\n        exit(1);\n    } else if (status == PRT_STATUS_EVENT_UNHANDLED) {\n        fprintf_s(stdout, \"exiting with PRT_STATUS_EVENT_UNHANDLED\\n\");\n        exit(1);\n    } else if (status == PRT_STATUS_QUEUE_OVERFLOW) {\n        fprintf_s(stdout, \"exiting with PRT_STATUS_QUEUE_OVERFLOW \\n\");\n        exit(1);\n    } else if (status == PRT_STATUS_ILLEGAL_SEND) {\n        fprintf_s(stdout, \"exiting with PRT_STATUS_ILLEGAL_SEND \\n\");\n        exit(1);\n    } else {\n        fprintf_s(stdout, \"unexpected PRT_STATUS in ErrorHandler: %d\\n\", status);\n        exit(2);\n    }\n}\n\nvoid Log(PRT_STEP step, PRT_MACHINESTATE *senderState, PRT_MACHINEINST *receiver, PRT_VALUE* event, PRT_VALUE* payload) {\n    PrtPrintStep(step, senderState, receiver, event, payload);\n}\n\nvoid decrement_threadsRunning() {\n    pthread_mutex_lock(&amp;threadsRunning_mutex);\n    threadsRunning = threadsRunning - 1;\n    pthread_mutex_unlock(&amp;threadsRunning_mutex);\n}\n\nlong get_threadsRunning() {\n    long c;\n    pthread_mutex_lock(&amp;threadsRunning_mutex);\n    c = threadsRunning;\n    pthread_mutex_unlock(&amp;threadsRunning_mutex);\n    return (c);\n}\n\nvoid PRT_CALL_CONV MyAssert(PRT_INT32 condition, PRT_CSTRING message) {\n    if (condition != 0) {\n        return;\n    } else if (message == NULL) {\n        fprintf_s(stderr, \"ASSERT\");\n    } else {\n        fprintf_s(stderr, \"ASSERT: %s\", message);\n    }\n    exit(1);\n}\n\nstatic void RunToIdle(void* process) {\n    // In the tester we run the state machines until there is no more work to do then we exit\n    // instead of blocking indefinitely.  This is then equivalent of the non-cooperative case\n    // where we PrtRunStateMachine once (inside PrtMkMachine).  So we do NOT call PrtWaitForWork.\n    // PrtWaitForWork((PRT_PROCESS*)process);\n    PRT_PROCESS_PRIV* privateProcess = (PRT_PROCESS_PRIV*)process;\n    while (privateProcess-&gt;terminating == PRT_FALSE) {\n        ;\n    }\n    decrement_threadsRunning();\n}\n\nint main(int argc, char *argv[]) {\n    PRT_DBG_START_MEM_BALANCED_REGION\n    {\n        PRT_GUID processGuid;\n        PRT_VALUE *payload;\n\n        processGuid.data1 = 1;\n        processGuid.data2 = 0;\n        processGuid.data3 = 0;\n        processGuid.data4 = 0;\n        MAIN_P_PROCESS = PrtStartProcess(processGuid, &amp;P_GEND_IMPL_DefaultImpl, ErrorHandler, Log);\n\n        if (cooperative) {\n            PrtSetSchedulingPolicy(MAIN_P_PROCESS, PRT_SCHEDULINGPOLICY_COOPERATIVE);\n        }\n        if (parg == NULL) {\n            payload = PrtMkNullValue();\n        } else {\n            int i = atoi(parg);\n            payload = PrtMkIntValue(i);\n        }\n\n        PrtUpdateAssertFn(MyAssert);\n        PRT_UINT32 machineId;\n        PRT_BOOLEAN foundMainMachine = PrtLookupMachineByName(\"myMachine\", &amp;machineId);\n\n        if (foundMainMachine == PRT_FALSE) {\n            printf(\"%s\\n\", \"FAILED TO FIND DroneMachine\");\n            exit(1);\n        }\n\n        PrtMkMachine(MAIN_P_PROCESS, machineId, 1, &amp;payload);\n\n        if (cooperative) {\n            typedef void *(*start_routine) (void *);\n            pthread_t tid[threads];\n            for (int i = 0; i &lt; threads; i++)\n            {\n                threadsRunning++;\n                pthread_create(&amp;tid[i], NULL, (start_routine)RunToIdle, (void*)MAIN_P_PROCESS);\n            }\n            while(get_threadsRunning() != 0);\n\n        }\n        PrtFreeValue(payload);\n        PrtStopProcess(MAIN_P_PROCESS);\n    }\n    PRT_DBG_END_MEM_BALANCED_REGION\n}\n</code></pre> <p>One needs to notice couple of details of the given C program.</p> <ul> <li>The program includes <code>myProgram.h</code> as it is calling constructs defined in the C equivalent of the program.</li> <li>Global variables defined at the begining of the program are parameters that are used for different configuration of the program.</li> <li><code>ErrorHandler</code> is a function defined to provide an interface for the runtime errors.</li> <li><code>Log</code> is a function defined to print the steps taken by the runtime backend.</li> <li><code>decrement_threadsRunning</code> and <code>get_threadsRunning</code> are helper functions used for multi-threaded execution.</li> <li><code>MyAssert</code> is  function defined to provide an interface for the runtime assertions.</li> <li><code>RunToIdle</code> is a function defined to run a given process until termination.</li> <li><code>main</code> starts the execution by using all the functions and parameters defined previously. First, it starts the main P process by calling <code>PrtStartProcess</code>, which returns a <code>PRT_PROCESS</code> pointer. Next, if the scheduling policy is set to cooperative by the corresponding global variable, then the main function sets the scheduling policy to cooperative. Then, by using the method <code>PrtLookupMachineByName</code>, we look for a machine defined in the program by its name and get its id. With the id we create the machine by calling <code>PrtMkMachine</code>. Notice that if cooperative scheduling is disabled, i.e., task neutral policy is selected, then the execution starts immediately after creating the machine. If cooperative scheduling is enabled, one can either call <code>PrtRunProcess</code> with <code>MAIN_P_PROCESS</code>, i.e., <code>PrtRunProcess(MAIN_P_PROCESS)</code>, which will run the program with cooperative scheduling using only one thread, or run the while loop given in the program. The while loop given in the program distributes the work among the specified number of worker threads. In this case, the program will not exit until all worker threads are done.</li> </ul> <p>Now that we have a driver C program, we need to compile the generated C program to an executable. To compile and execute the generated C program with respect to P semantics, we need to link P runtime backend with the C representation of the program and the driver C program during compilation. We recommend using CMake for this purpose, an example <code>CMakeLists.txt</code> is given below.</p> <pre><code>cmake_minimum_required (VERSION 3.1)\n\nproject (myProgram)\nset(projectName myProgram)\n\nfind_package (Threads)\n\ninclude_directories(\n    /path/to/P/Bld/Drops/Prt/include\n)\n\nadd_definitions( -DPRT_PLAT_LINUXUSER )\n\nadd_executable(myProgram\n    myProgram.h\n    myProgram.c\n    main.c\n    /path/to/P/Bld/Drops/Prt/include/ext_compat.h\n    /path/to/P/Bld/Drops/Prt/include/libhandler.h\n    /path/to/P/Bld/Drops/Prt/include/libhandler-internal.h\n    /path/to/P/Bld/Drops/Prt/include/Prt.h\n    /path/to/P/Bld/Drops/Prt/include/PrtConfig.h\n    /path/to/P/Bld/Drops/Prt/include/PrtExecution.h\n    /path/to/P/Bld/Drops/Prt/include/PrtLinuxUserConfig.h\n    /path/to/P/Bld/Drops/Prt/include/PrtProgram.h\n    /path/to/P/Bld/Drops/Prt/include/PrtTypes.h\n    /path/to/P/Bld/Drops/Prt/include/PrtValues.h\n    /path/to/P/Bld/Drops/Prt/include/sal.h\n)\n\ntarget_link_libraries(myProgram\n    /path/to/P/Bld/Drops/Prt/lib/libPrt_static.a\n    /path/to/P/Ext/libhandler/out/gcc-amd64-apple-darwin20.6.0/debug/libhandler.a # If you are not using MacOS, you need to change gcc-amd64-apple-darwin20.6.0 accordingly!\n)\n</code></pre> <p>This file links all necessary P runtime backend libraries with the project. To compile, run the following.</p> <pre><code>cmake CMakeLists.txt\nmake\n</code></pre> <p>After running these commands, the executable <code>myProgram</code> will be in the current directory, which can be executed simply as follows.</p> <pre><code>./myProgram\n</code></pre> <p>One can extend this project structure, and build more complicated applications.</p>"},{"location":"advanced/pex/","title":"PEx: Exhaustive Model Checking","text":"<p>PEx is an exhaustive model checker for P programs that performs a systematic search to verify correctness properties for small (finite) instances of the system. It explores all possible behaviors of the system by analyzing finite inputs and finite processes. </p>"},{"location":"advanced/pex/#architecture","title":"Architecture","text":"<p>PEx uses a multi-threaded, stateful search optimized to scale to billions of protocol states. The core architecture includes:</p> <ul> <li>State Tracking: Maintains record of all unexplored state transitions</li> <li>Dynamic Prioritization: Optimizes exploration order during search</li> <li>State Caching: Prevents redundant work by caching visited states  </li> <li>Parallel Execution: Leverages thread-level parallelism for performance</li> </ul>"},{"location":"advanced/pex/#prerequisites","title":"Prerequisites","text":"<p>PEx requires Java 17+ and Maven 3.7+ to be installed on your system.</p> MacOSUbuntuWindows <p><pre><code># Install Java 17\nbrew install openjdk@17\n\n# Install Maven\nbrew install maven\n</code></pre> Don't have Homebrew? Download Java and Maven directly.</p> <pre><code># Install Java 17\nsudo apt install openjdk-17-jdk\n\n# Install Maven\nsudo apt install maven\n</code></pre> <ul> <li>Download and install Java 17</li> <li>Follow the Maven installation guide</li> </ul> Verify installations <pre><code>java -version   # Should show version 17 or higher\nmvn -version    # Should show version 3.7 or higher\n</code></pre>"},{"location":"advanced/pex/#building-with-pex","title":"Building with PEx","text":"<p>To compile a P program for exhaustive model checking:</p> <pre><code>p compile --mode pex\n</code></pre>"},{"location":"advanced/pex/#running-pex","title":"Running PEx","text":"<p>Basic usage to run PEx on a test case with a 60-second timeout on tutorial #1 Client Server:</p> <pre><code>p check --mode pex -tc tcSingleClient --timeout 60\n</code></pre> Expected Output <pre><code>.. Searching for a P compiled file locally in folder ./PGenerated/\n.. Found a P compiled file: ./PGenerated/PEx/target/ClientServer-jar-with-dependencies.jar\n.. Checking ./PGenerated/PEx/target/ClientServer-jar-with-dependencies.jar\nWARNING: sun.reflect.Reflection.getCallerClass is not supported. This will impact performance.\n.. Test case :: tcSingleClient\n... Checker is using 'random' strategy with 1 threads (seed:1754700972405)\n--------------------\nTime     Memory    Tasks (run/fin/pen)    Schedules   Timelines     States   \n00:00:28   3.0 GB         0 / 1 / 0             10          1         90,000   \n\n--------------------\n... Checking statistics:\n..... Found 0 bugs.\n... Search statistics:\n..... Explored 90,000 distinct states over 1 timelines\n..... Explored 10 distinct schedules\n..... Finished 1 search tasks (0 pending)\n..... Number of steps explored: 0 (min), 9,000 (avg), 10,001 (max).\n... Elapsed 28 seconds and used 6.4 GB\n..  Result: correct up to step 10,001 \n. Done\n... Checker run finished.\n~~ [PTool]: Thanks for using P! ~~\n... Checker run terminated.\n</code></pre> <p>Key Metrics:</p> <p>Exploration Results: Explored 90,000 distinct states in a single timeline; Examined 10 different schedules; Reached maximum step limit of 10,001 steps; Found no bugs in explored state space</p> <p>Resource Usage: Runtime: 28 seconds; Memory: 6.4 GB peak usage; Threads: Single thread with random strategy</p> <p>Results: Completed normally (hit step limit); Verified correct up to step 10,001; All properties satisfied in explored states</p>"},{"location":"advanced/pex/#advanced-options","title":"Advanced Options","text":"Exploring PEx Runtime Options <p>View available runtime options: <pre><code># Print basic help menu\np check --mode pex --checker-args :--help\n\n# Print expert help menu with advanced options\np check --mode pex --checker-args :--help-all\n</code></pre></p>"},{"location":"advanced/pex/#parallel-execution","title":"Parallel Execution","text":"<p>PEx supports parallel execution to speed up the verification process. To run with multiple cores on tutorial #1 Client Server:</p> <pre><code>p check --mode pex -tc tcSingleClient --timeout 60 --checker-args :--nproc:32\n</code></pre> <p>This example uses 32 cores for parallel exploration of the state space.</p> <p>Performance Tips</p> <ul> <li>Start with a reasonable timeout value (e.g., 60 seconds) and adjust based on your system's complexity</li> <li>For large state spaces, use parallel execution with multiple cores</li> <li>Consider using abstractions to reduce the state space when possible</li> </ul>"},{"location":"advanced/psemantics/","title":"P Semantics","text":"<p>Before getting started with the tutorials, we provide a quick informal overview of the P language semantics so that the readers can keep it at the back of their mind as they walk through the tutorials and the language manual.</p> <p>P is a programming language. P is a state machine based programming language and hence, just like any other imperative programming language it supports basic data types, expressions, and statements that enable programmers to capture complex distributed systems protocol logic as a collection of event-handlers or functions (in P state machines).</p> <p>P State machines. The underlying model of computation for P state machines is similar to that of Gul Agha's Actor-model-of-computation (wiki). A P program is a collection of concurrently executing state machines that communicate with eachother by sending events (or messages) asynchronously. Each P state machine has an unbounded FIFO buffer associated with it. Sends are asynchronous, i.e., executing a send operation <code>send t,e,v;</code> adds event <code>e</code> with payload value <code>v</code> into the FIFO buffer of the target machine <code>t</code>. Each state in the P state machine has an entry function associated with it which gets executed when the state machine enters that state. After executing the entry function, the machine tries to dequeue an event from the input buffer or blocks if the buffer is empty. Upon dequeuing an event from the input queue of the machine, the attached handler is executed which might transition the machine to a different state. We will provide more details about the P state machines in tutorials as well as the language manual. For detailed formal semantics of P state machines, we refer the readers to the original P paper and the more recent paper with updated semantics.</p> <p>There are two main distinctions with actor model of computation: (1) P adds the syntactic sugar of state machines to actors, and (2) each state machine in P has an unbounded FIFO buffer associated with it instead of an unbounded bag in actors (semantic difference).</p> <p>[Important] Send semantics in P</p> <p>Sends are reliable, buffered, non-blocking, and directed (not broadcast). Sends are reliable i.e., executing a send operation in P adds an event into the target machines buffer. Hence, if one wants to model message loss it has to be modeled explicitly (discussed in the Failure Detector example in the tutorial). Similarly, as P state machine buffers are FIFO, events are dequeued at the state machine in the causal order in which they were sent. Note that events that are sent by two different concurrent machines will be interleaved by the checker and hence, will appear in different order at the target machine but the events sent by the same machine will always appear in the same order at the target state machine. So, just like message loss, arbitrary message re-ordering also has to be explicitly modeled in P (explained in the Paxos example in the tutorials). In general, we find that re-ordering messages/events coming from the same machine is not important and does not lead to any interesting behaviors. More interesting behaviors happen because of interleaving of messages across different state machines which the P checker explores automatically.</p> <p>Summary, by default, the communication between state machines using <code>send</code> operation follows the above semantics. If you would like to check your system correctness against an arbitrarily network then one would have to model the corresponding <code>send</code> semantics in P explicitly. One can then make the arbitrarily network behave as expected with message duplicates, loss, re-order, etc.</p> <p>If you have any further doubts related to this topic and modeling network semantics when reasoning using P, feel free to get in touch with Ankush Desai. We have several examples of such cases.</p> <p>[Important] New semantics in P</p> <p>State machines in P can be dynamically created during the execution of the Program using the <code>new</code> primitive. Creation of a state machine is also an asynchronous, non-blocking operation.</p> <p>P Monitors. Specifications in P are written as global runtime monitors. These global monitors observe the execution of the system and can assert any global safety or liveness invariants on the system. Note that the monitors are synchronously composed with the P state machines. Details are explained in the language manual and we provide examples in the tutorial.</p> <p>When reasoning about the correctness of a distributed system, it is really important to specify both safety as well as liveness specifications.</p> <p>Always specify both safety and liveness specifications</p> <p>Only specifying safety property for a system is not enough, this is mainly because, a system model may be incorrect and in the worst case drop all requests on to the ether and not perform any operation. Such a system trivially satisfies all correctness specifications! Hence, it becomes essentially to combine that safety property with liveness properties to check that the system is making progress and servicing the requests. Running the checker on models that have both safety and liveness properties ensure that for all executions explored by the checker, requests are eventually serviced by the system (by sending responses potentially) and all the responses sent by the system satisfy the desired correctness safety specification. This helps ensure that your models are not doing something trivially incorrect like always doing nothing , in which case running the checker on such a model adds no value.</p> <p>P Checker. The P Checker explores different possible behaviors of the P program arising out of: (1) concurrency: different interleavings of events from concurrently executing state machines as well as (2) data nondeterminism: different data input choices in the P program modeled using the <code>choose</code> (see) operation. The P checker explores different executions of the system that can happen because of these two forms of nondeterminism and asserts that for each of these executions the system satisfies the desired properties specified by the P Monitors.</p>"},{"location":"advanced/structureOfPProgram/","title":"Structure of a P Program","text":"<p>A P program is typically divided into four folders (or parts):</p> <ul> <li><code>PSrc</code>: contains all the state machines representing the implementation (model) of the   system or protocol to be verified or tested.</li> <li><code>PSpec</code>: contains all the specifications representing the correctness properties that   the system must satisfy.</li> <li> <p><code>PTst</code>: contains all the environment or test harness state machines that model the   non-deterministic scenarios under which we want to check that the system model in <code>PSrc</code>   satisfies the specifications in <code>PSpec</code>. P allows writing different model checking   scenarios as test-cases.</p> </li> <li> <p><code>PForeign</code>: P also supports interfacing with foreign languages like <code>Java</code>, <code>C#</code>, and   <code>C/C++</code>. P allows programmers to implement a part of their protocol logic in these   foreign languages and use them in a P program using the foreign types and functions interface (Foreign).   The <code>PForeign</code> folder contains   all the foreign code used in the P program.</p> </li> </ul> <p>Recommendation</p> <p>The folder structure described above is just a recommendation. The P compiler does not require any particular folder structure for a P project. The examples in the Tutorials use the same folder structure.</p> <p>Models, Specifications, Model Checking Scenario</p> <p>A quick primer on what a model is, versus a specification, and model checking scenarios: (1) A specification says what the system should do (correctness properties). (2) A model captures the details of how the system does it. (3) A model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications.</p>"},{"location":"advanced/PVerifierLanguageExtensions/announcement/","title":"Announcing the New Verification Backend for P","text":"<p>We are excited to announce the release of a new verification backend as part of the 3.0 release of the P programming language! This backend, which we call the P Verifier, allows you to prove that your systems behave correctly under all possible scenarios. The P Verifier is based on Mora et al. (OOPSLA '23) and uses UCLID5 (Polgreen et al., CAV '22).</p> <p>Before the P Verifier, P helped users catch design-level bugs early in the development process through explicit-state model checking (Brooker and Desai, Queue '25). Given a formal model, specification, and a test driver describing a system configuration, the model checking backend systematically explores the given model in search of an execution that violates the given specification for the given system configuration. See the Two-Phase Commit example tutorial for an example model, specification, and three test drivers corresponding to three different system configurations (e.g., a configuration with three participants, one coordinator, and one client). P was used in this way to help AWS migrate S3 (Simple Storage Service) from eventual to strong read-after-write consistency.</p> <p>The new verification backend allows users to prove that their system design is correct for all executions over all possible system configurations. Instead of using explicit-state model checking, the new backend supports proofs by induction. Users still provide a formal model and specification. But, instead of giving a test driver, users must provide assumptions about what is possible in the system and an inductive invariant that implies that the given model satisfies the given specification under the given assumptions. The main job of the backend is to check that that given invariant is indeed inductive (all possible events in the system preserve it) and that the given invariant does indeed imply the given specification. UCLID5 accomplishes this job by way of a satisfiability modulo theories (SMT) solver, like Z3 (de Moura and Bj\u00f8rner, TACAS '08).</p> <p>Formal verification is important to AWS\u2019s software correctness program (Brooker and Desai, Queue '25). Several formal tools have had successful applications within AWS in their respective domains. The new verification backend in P gives users the benefits of correctness proofs for the domain of distributed systems design, all while preserving the existing benefits of systematic testing.</p>"},{"location":"advanced/PVerifierLanguageExtensions/announcement/#getting-started-and-tutorial","title":"Getting Started and Tutorial","text":"<p>To start using the P Verifier, you must install P along with the verification dependencies (UCLID5 and an SMT solver like Z3). Detailed installation instructions are available here; simple usage instructions are available here.</p> <p>To help you get acquainted with the new verification features, we have prepared a comprehensive tutorial that walks you through the formal verification of a simplified two-phase commit (2PC) protocol. This tutorial covers the key concepts and steps of using the verification backend. You can find the tutorial here.</p>"},{"location":"advanced/PVerifierLanguageExtensions/announcement/#industrial-application-inside-amazon-web-services","title":"Industrial Application Inside Amazon Web Services","text":"<p>The two-phase commit protocol described in the tutorial is deliberately simplified to help new users get started. In that protocol, one coordinator works with a fixed set of participants to agree on a single boolean value. Industrial systems, however, call for a number of generalizations. </p> <p>We used the new verification backend to verify an industrial version of the two-phase commit protocol with the following generalizations. First, the protocol works for multiple rounds (think participants agreeing on sequences of boolean values instead of a single boolean value). Second, the participants agree on the state of a key-value store instead of boolean values. Third, the system works at the granularity of transactions (reads and writes) instead of individual values. Fourth, the key-value store is partitioned across sets of participants (\"shards\"). Finally, fifth, the safety property is a more general kind of consistency called Snapshot Isolation. We hope to release the internal details of this system and the corresponding proof of correctness at a later date.</p> <p>We look forward to your feedback. Happy verifying!</p>"},{"location":"advanced/PVerifierLanguageExtensions/init-condition/","title":"Initialization Conditions","text":"<p>Initialization conditions let us constrain the kinds of systems that we consider for formal verification. You can think of these as constraints that P test harnesses have to satisfy to be considered valid.</p> P Init Condition Declaration Grammar <pre><code>initConditionDecl :\n    | init-condition expression;     # P Init Condition Declaration\n</code></pre> <p><code>expression</code> is a boolean expression that should evaluate to true at initialization time.</p> <p>Syntax: <code>init-condition expression;</code></p> <p><code>expression</code> is a boolean expression that must be satisfied for the system to be considered valid. This is typically used with quantifiers to express constraints over sets of machines or values.</p> Init Condition Examples <pre><code>// Ensures that there's a unique machine of type coordinator\ninit-condition forall (m: machine) :: m == coordinator() &lt;==&gt; m is Coordinator;\n\n// Ensures that every machine in the participants set is a machine of type participant\ninit-condition forall (m: machine) :: m in participants() &lt;==&gt; m is Participant;\n\n// Ensures that all yesVotes tallies start empty\ninit-condition forall (c: Coordinator) :: c.yesVotes == default(set[machine]);\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/install-pverifier/","title":"Install Instructions for Amazon Linux","text":"<p>PVerifier requires several dependencies to be installed. Follow the steps below to set up your environment.</p> <p>After each step, please use the troubleshooting check to ensure that each installation step succeeded.</p>"},{"location":"advanced/PVerifierLanguageExtensions/install-pverifier/#step-1-install-java-11","title":"[Step 1] Install Java 11","text":"<pre><code>sudo rpm --import https://yum.corretto.aws/corretto.key\nsudo curl -L -o /etc/yum.repos.d/corretto.repo https://yum.corretto.aws/corretto.repo\nsudo yum install java-11-amazon-corretto-devel maven\n</code></pre> Troubleshoot: Confirm that java is correctly installed on your machine. <pre><code>java -version\n</code></pre> <p>If you get <code>java</code> command not found error, most likely, you need to add the path to <code>java</code> in your <code>PATH</code>.</p>"},{"location":"advanced/PVerifierLanguageExtensions/install-pverifier/#step-2-install-sbt","title":"[Step 2] Install SBT","text":"<pre><code>sudo rm -f /etc/yum.repos.d/bintray-rpm.repo || true\ncurl -L https://www.scala-sbt.org/sbt-rpm.repo &gt; sbt-rpm.repo\nsudo mv sbt-rpm.repo /etc/yum.repos.d/\nsudo yum install sbt\n</code></pre> Troubleshoot: Confirm that sbt is correctly installed on your machine. <pre><code>sbt --version\n</code></pre> <p>If you get <code>sbt</code> command not found error, most likely, you need to add the path to <code>sbt</code> in your <code>PATH</code>.</p>"},{"location":"advanced/PVerifierLanguageExtensions/install-pverifier/#step-3-install-net-80","title":"[Step 3] Install .NET 8.0","text":"<p>Install .NET 8.0 from Microsoft:</p> <pre><code>wget https://dotnet.microsoft.com/download/dotnet/scripts/v1/dotnet-install.sh\nbash ./dotnet-install.sh  -c 8.0 -i $HOME/.dotnet\n\nsudo mkdir /usr/share/dotnet/\nsudo cp -r $HOME/.dotnet/* /usr/share/dotnet/\n</code></pre> <p>Then add the following line to <code>.zshrc</code> and run <code>source .zshrc</code> (or <code>.bashrc</code> if using bash):</p> <pre><code>export PATH=$HOME/.dotnet:$HOME/.dotnet/tools:$PATH\n</code></pre> <p>The purpose of copying the .NET distribution into <code>/usr/share/dotnet</code> is to make standard dotnet packages available to dotnet.   If you are uncomfortable modifying a system directory, you can add the following line to your <code>.zshrc</code> or <code>.bashrc</code> instead:</p> <pre><code>export DOTNET_ROOT=$HOME/.dotnet\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/install-pverifier/#step-4-install-z3","title":"[Step 4] Install Z3","text":"<pre><code>cd ~\ngit clone https://github.com/Z3Prover/z3.git\ncd z3\npython scripts/mk_make.py --java\ncd build; make\n</code></pre> <p>Then add the following lines to your <code>.zshrc</code> and run <code>source ~/.zshrc</code> (or <code>.bashrc</code> if using bash):</p> <pre><code>export PATH=$PATH:$HOME/z3/build/\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/z3/build/\n</code></pre> Troubleshoot: Confirm that Z3 is correctly installed on your machine. <pre><code>z3 --version\n</code></pre> <p>If you get <code>z3</code> command not found error, most likely, you need to add the path to <code>z3</code> in your <code>PATH</code>.</p> <p>Note:</p> <ul> <li> <p>Python: Building Z3 requires Python 3, but Python 2 is the default on Amazon Linux 2.  If <code>python --version</code> displays version 2, try     <pre><code>sudo alternatives --set python `which python3`\n</code></pre>     or     <pre><code>alias python=python3\n</code></pre></p> </li> <li> <p>G++: Building Z3 requires G++ 8 or later with support for C++20, but G++ 7 is the default on Amazon Linux 2.  If <code>g++ --version</code> displays version 7, try</p> <pre><code>sudo yum install gcc10 gcc10-c++\n</code></pre> <p>to install gcc10-gcc and gcc10-g++ and replace the string <code>gcc</code> with <code>gcc10-</code> in <code>config.mk</code>.</p> </li> </ul>"},{"location":"advanced/PVerifierLanguageExtensions/install-pverifier/#step-5-install-uclid5","title":"[Step 5] Install UCLID5","text":"<pre><code>cd ~\ngit clone https://github.com/uclid-org/uclid.git\ncd uclid\nsbt update clean compile \"set fork:=true\" test # should fail some tests that use cvc5 and delphi\nsbt universal:packageBin\nunzip target/universal/uclid-0.9.5.zip\n</code></pre> <p>Then add the following line to your <code>.zshrc</code> (or <code>.bashrc</code> if using bash) and run <code>source ~/.zshrc</code>:</p> <pre><code>export PATH=$PATH:$HOME/uclid/uclid-0.9.5/bin/\n</code></pre> <p>Note: * Tests using cvc5 and delphi are likely to fail.  If you just cut and paste the build commands into your shell, this failure may inhibit running the last two commands, so just cut and paste the last two commands into your shell again.</p> Troubleshoot: Confirm that UCLID5 is correctly installed on your machine. <pre><code>uclid --help\n</code></pre> <p>If you get <code>uclid</code> command not found error, most likely, you need to add the path to <code>uclid</code> in your <code>PATH</code>.</p>"},{"location":"advanced/PVerifierLanguageExtensions/install-pverifier/#step-6-install-pverifier","title":"[Step 6] Install PVerifier","text":"<p>The following steps will build P with PVerifier by running the regular P build on the PVerifier branch of the repository.</p> <pre><code>cd ~\ngit clone https://github.com/p-org/P\ncd P\ngit checkout dev_p3.0/pverifier\nroot=$(pwd)\ncd $root/Bld\n./build.sh\ndotnet tool uninstall --global P\ncd $root/Src/PCompiler/PCommandLine\ndotnet pack PCommandLine.csproj --configuration Release --output ./publish -p:PackAsTool=true -p:ToolCommandName=P -p:Version=2.1.3\ndotnet tool install P --global --add-source ./publish\n</code></pre> Troubleshoot: Confirm that PVerifier is correctly installed on your machine. <pre><code>p --version\n</code></pre> <p>If you get <code>p</code> command not found error, most likely, you need to add the path to <code>p</code> in your <code>PATH</code>.</p>"},{"location":"advanced/PVerifierLanguageExtensions/outline/","title":"Outline","text":"<p>We recommend that you start with the Tutorials to get familiar with the P language and its tool chain.</p> PVerifier Extension Top Level Declarations Grammar <pre><code>topDecl:                # Top-level P Program Declarations\n| pureFunDecl           # PureFunctionDeclaration\n| initCondDecl          # InitConditionPredicateDeclaration\n| invariantDecl         # InvariantDeclaration\n| lemmaDecl             # LemmaDeclaration\n| proofScript           # ProofScript\n;\n</code></pre> <p>A PVerifier program consists P top-level declarations along with the following:</p> Top Level Declarations Description Pure Functions P supports declaring pure functions that do not have side effects Init Conditions P supports declaring initial condition predicates Invariants P supports declaring invariants that must hold true for the system Lemmas and Proofs P supports declaring lemmas and proof scripts to verify the correctness of the system"},{"location":"advanced/PVerifierLanguageExtensions/proof/","title":"Lemmas and Proof Scripts","text":"<p>Lemmas and proof scripts go hand in hand in the P Verifier. Lemmas allow you to decompose specifications and proof scripts allow you to relate lemmas to write larger proofs.</p>"},{"location":"advanced/PVerifierLanguageExtensions/proof/#lemmas","title":"Lemmas","text":"<p>Lemmas in P allow you to group related invariants together, which helps organize complex proofs, create smaller and more stable verification queries, and enable proof caching.</p> P Lemma Declaration Grammar <pre><code>lemmaDecl :\n    | Lemma iden { invariantsList }    # P Lemma Declaration\n\ninvariantsList :\n    | invariant iden: expression;\n    | invariantsList invariant iden: expression;\n</code></pre> <p><code>iden</code> is the name of the lemma or invariant, and <code>expression</code> is a boolean expression that should hold throughout system execution.</p> <p>Syntax: <code>Lemma lemmaName { invariant invName1: expr1; invariant invName2: expr2; ... }</code></p> <p><code>lemmaName</code> is the name of the lemma group, <code>invNameX</code> are the names of individual invariants, and <code>exprX</code> are the boolean expressions that should hold.</p> Lemma Declaration <pre><code>Lemma system_config {\n    invariant one_coordinator: forall (m: machine) :: m == coordinator() &lt;==&gt; m is Coordinator;\n    invariant participant_set: forall (m: machine) :: m in participants() &lt;==&gt; m is Participant;\n    invariant never_commit_to_coordinator: forall (e: event) :: e is eCommit &amp;&amp; e targets coordinator() ==&gt; !inflight e;\n    // More invariants...\n}\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/proof/#proofs","title":"Proofs","text":"<p>In P's verification framework, proofs provide a way to structure verification tasks by specifying what to verify and which lemmas to use. Proof scripts help decompose complex verification problems into smaller, more manageable parts and enable caching of intermediate results.</p> P Proof Declaration Grammar <pre><code>proofDecl :\n    | Proof { proofStmtList }    # P Proof Declaration\n\nproofStmtList :\n    | proofStmt;\n    | proofStmtList proofStmt;\n\nproofStmt :\n    | prove iden;                # Prove a lemma or invariant\n    | prove iden using iden;     # Prove using another lemma\n</code></pre> <p><code>iden</code> is the name of a lemma or invariant that should be verified.</p> <p>Syntax: <code>Proof { prove target1; prove target2 using helper; ... }</code></p> <p>Where <code>targetN</code> are the names of lemmas or invariants to verify, and <code>helper</code> is an optional lemma to use during verification.</p> Basic ProofComplex Proof With DependenciesUsing Default Keyword <pre><code>Proof {\n    prove system_config;         // Verify system_config lemma\n    prove default using system_config;  // Verify default P proof obligations using system_config\n}\n</code></pre> <pre><code>Proof {\n    prove system_config;         // First prove the system configuration lemma\n    prove kondo using system_config;  // Use system_config to prove kondo\n    prove safety using kondo;    // Use kondo to prove the safety property\n    prove default using system_config;  // Verify default P obligations\n}\n</code></pre> <pre><code>Proof {\n    prove lemma1;\n    prove lemma2;\n    // The special keyword \"default\" refers to P's built-in specifications\n    prove default using lemma1, lemma2;  // Verify using both lemmas\n}\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/proof/#benefits-of-proof-scripts","title":"Benefits of Proof Scripts","text":"<ol> <li>Organization: Break down complex proofs into manageable parts</li> <li>Verification Stability: They enable the verifier to construct smaller, more focused queries</li> <li>Caching: Results are cached per proof step, avoiding redundant verification across runs</li> </ol>"},{"location":"advanced/PVerifierLanguageExtensions/pure/","title":"Pure Functions","text":"P Pure Function Declaration Grammar <pre><code>pureFunctionDecl :\n    | pure iden (params)? : type;     # P Pure Function Declaration\n</code></pre> <p><code>iden</code> is the name of the pure function, <code>params</code> are the parameters of the function, and <code>type</code> is the return type of the function.</p> <p>Syntax: <code>pure functionName();</code> or <code>pure functionName(param1: type1, param2: type2) : returnType;</code></p> <p><code>functionName</code> is the name of the P pure function, <code>param1</code>, <code>param2</code>, etc. are the parameters of the function, and <code>returnType</code> is the type of the value returned by the function.</p> Pure Function Declarations <pre><code>// declaration of pure functions with no parameters\npure participants(): set[machine];\npure coordinator(): machine;\n\n// declaration of pure functions with parameters\npure preference(m: machine) : bool;\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/specification/","title":"Specifications","text":"<p>The P verifier adds three kinds of specifications: global invariants, loop invariants, and function contracts. We cover each type in its own subsection below.</p>"},{"location":"advanced/PVerifierLanguageExtensions/specification/#global-invariants","title":"Global Invariants","text":"<p>Global invariants are properties that should hold true throughout the execution of the system.</p> <p>Syntax: <code>invariant [name:] expression;</code></p> <p><code>name</code> is an optional name for the invariant, and <code>expression</code> is a boolean expression that should hold true in all reachable states.</p> Grammar <pre><code>invariant [name:] expression;    # Global Invariant Declaration\n</code></pre> Basic Invariants <pre><code>// Simple invariant that checks a coordinator property\ninvariant one_coordinator: forall (m: machine) :: m == coordinator() &lt;==&gt; m is Coordinator;\n\n// Invariant to ensure messages are directed to the right machines\ninvariant never_req_to_coordinator: forall (e: event) :: e is eVoteReq &amp;&amp; e targets coordinator() ==&gt; !inflight e;\n\n// Safety property invariant\ninvariant safety: forall (p1: Participant) :: p1 is Accepted ==&gt; (forall (p2: Participant) :: preference(p2));\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/specification/#loop-invariants","title":"Loop Invariants","text":"<p>Loop invariants are properties that should hold true during the execution of loops.</p> <p>Syntax: <code>invariant expression;</code></p> <p><code>expression</code> is a boolean expression that should hold true throughout the execution of the loop.</p> Grammar <pre><code>invariant expression;    # Loop Invariant\n</code></pre> Loop Invariants <pre><code>foreach (p in participants()) \n    invariant forall new (e: event) :: forall (m: machine) :: e targets m ==&gt; m in participants();\n    invariant forall new (e: event) :: e is eVoteReq;\n{\n    send p, eVoteReq;\n}\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/specification/#function-contracts","title":"Function Contracts","text":"<p>Function contracts specify preconditions, postconditions, and return value names for functions.</p> <p>Syntax: <code>requires expression;</code> and <code>ensures expression;</code> and <code>return (name: type);</code></p> <p><code>requires</code> specifies a precondition that must be true before the function is executed, <code>ensures</code> specifies a postcondition that must be true after the function is executed, and <code>return</code> binds the return value to name that you can write pre- and postconditions over.</p> Grammar <pre><code>requires expression;    # Function Precondition\nensures expression;     # Function Postcondition\nreturn (name: type);    # Function Return Binding\n</code></pre> Function Contracts <pre><code>fun RandomParticipant(s: set[machine]) \n    return (x: machine);\n    ensures x in s;\n    requires NotEmpty(s); // where NotEmpty is a helper function\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/specification/#special-predicates","title":"Special Predicates","text":"<p>P provides special predicates for specifying message state:</p> <ul> <li><code>inflight e</code>: True if message <code>e</code> has been sent but not yet received</li> <li><code>sent e</code>: True if message <code>e</code> has been sent (regardless of whether it has been received)</li> </ul>"},{"location":"advanced/PVerifierLanguageExtensions/specification/#quantifiers","title":"Quantifiers","text":"<p>P supports several quantifier expressions for specifying properties over collections:</p> <ul> <li><code>forall (x: type) :: expression</code>: True if the expression is true for all instances of the specified type</li> <li><code>exists (x: type) :: expression</code>: True if the expression is true for at least one instance of the specified type</li> <li><code>forall new (x: type) :: expression</code>: Similar to <code>forall</code>, but specifically quantifies over newly sent events in the body of a loop. Can only be used in loop invariants.</li> </ul> Quantifier Examples <pre><code>// Universal quantification\ninvariant all_participants_ready: forall (p: Participant) :: p.status == READY;\n\n// Existential quantification\ninvariant leader_exists: exists (p: Participant) :: p.isLeader;\n\n// Quantifying over new events in a loop\nforeach (p in participants()) \n    invariant forall new (e: event) :: e is eVoteReq;\n{\n    send p, eVoteReq;\n}\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/","title":"Introduction to Formal Verification in P","text":"<p>This tutorial describes the formal verification features of P through an example. We assume that the reader has P installed along with the verification dependencies (i,e., UCLID5 and Z3). Installation instructions are available here.</p> <p>When using P for formal verification, our goal is to show that no execution of any test driver will violate a specification. To do this, we will rely on proofs by induction---more on that later. This backend is different from P's explicit state model checker, which you are accustomed to using. These differences can influence the modeling decisions you make. </p> <p>To get a sense of these differences, and to cover the new features in P for verification, we will verify a simplified 2PC protocol. The P tutorial already describes a 2PC protocol, but we will make some different modeling choices that will make the verification process easier. In particular, we will follow the modeling decisions made by Zhang et al. in their running example.</p>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#2pc-model","title":"2PC Model","text":"<p>The 2PC protocol consists of two types of machines: coordinator and participant. There is a single coordinator, who receives requests from the outside world, and a set of participants, that must agree on whether to accept or reject the request. If any participant wants to reject the request, they must all agree to reject the request; if all participants want to accept the request, then they must all agree to accept the request. The job of the coordinator is to mediate this agreement. To accomplish this, the system executes the following steps:</p> <ol> <li>The coordinator sends a message to all participants which asks the participants to vote on the request in question.</li> <li>When a participant receives this vote request message, they reply with their vote.</li> <li>When the coordinator receives a \"no\" vote---indicating that a participant wants to reject the request---it will send a message to all participants telling them to abort the request.</li> <li>Otherwise, the coordinator tallies the \"yes\" vote. If all participants have voted \"yes,\" then the coordinator sends a message to all participants telling them to commit the request.</li> <li>When a participant receives either a commit or abort message from the coordinator, it store the decision locally.</li> </ol> <p>This system is extremely easy to model in P. Before defining the machines in the system, let's declare the five types of messages that are sent.</p> <pre><code>type tVoteResp = (source: machine); // we will keep track of who sent a vote\nevent eVoteReq;\nevent eYes: tVoteResp;\nevent eNo: tVoteResp;\nevent eAbort;\nevent eCommit;\n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#the-coordinator","title":"The Coordinator","text":"<p>The coordinator is a machine with a single variable that we will use to keep track of votes. This machine has four states: one to kickoff the voting process, one to collect the votes; and two to indicate if the voting process resulted in a commit or an abort.</p> <pre><code>machine Coordinator\n{\n    var yesVotes: set[machine]; // set of machines that have voted yes\n\n    start state Init {...}\n    state WaitForResponses {...}\n    state Committed {ignore eYes, eNo;}\n    state Aborted {ignore eYes, eNo;}\n}\n</code></pre> <p>In the above code we omitted the internal details of states. Now let's go through these details one by one. First, the start state, called Init, contains a single for-loop that sends a vote request message to all the participants in the system. We use a function called \"participants\" to get the set of active participants.</p> <pre><code>    start state Init {\n        entry {\n            var p: machine;\n            foreach (p in participants())\n            {\n                send p, eVoteReq; // broadcast vote request to all participants\n            }\n            goto WaitForResponses; // move to WaitForResponses state\n        }\n    }\n</code></pre> <p>Second, the <code>WaitForResponses</code> state has two event handlers, one for each type of vote that participants can cast.</p> <pre><code>state WaitForResponses {\n    on eYes do (resp: tVoteResp) {...}\n    on eNo do (resp: tVoteResp) {...}\n}\n</code></pre> <p>The details of when the coordinator receives \"no\" votes is simpler, so lets begin there. When the coordinator receives a \"no\" vote, it sends an abort message to all participants.</p> <pre><code>on eNo do (resp: tVoteResp) {\n    var p: machine;\n    foreach (p in participants())\n    {\n        send p, eAbort; // broadcast abort to all participants\n    }\n    goto Aborted;\n}\n</code></pre> <p>When a coordinator receives a \"yes\" vote, it will tally the vote and only broadcast a commit message to all participants if all participants have voted yes.</p> <pre><code>on eYes do (resp: tVoteResp) {\n    var p: machine;\n    yesVotes += (resp.source);   \n    if (yesVotes == participants()) { // if everyone voted \"yes\"\n        foreach (p in participants())\n        {\n            send p, eCommit; // broadcast commit message\n        }\n        goto Committed; // move to committed state: request was accepted\n    }\n}\n</code></pre> <p>The final two states, <code>Committed</code> and <code>Aborted</code> will remain empty for now: we just want to use them to indicate the state of a request.</p>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#participants","title":"Participants","text":"<p>Participants are slightly simpler. They consist of two states: one that does all the work, and two that we use to indicate that a request has been committed or aborted, just like we did for the coordinator.</p> <pre><code>machine Participant {\n    start state Undecided {...}\n    state Accepted {ignore eVoteReq, eCommit, eAbort;}\n    state Rejected {ignore eVoteReq, eCommit, eAbort;}\n}\n</code></pre> <p>The main state, called \"Undecided,\" has three event handlers: one for responding to vote requests, and two simpler ones for handling commit and abort messages.</p> <pre><code>on eVoteReq do {\n    // vote based on your preference!\n    if (preference(this)) {\n        send coordinator(), eYes, (source = this,);\n    } else {\n        send coordinator(), eNo, (source = this,);\n    }\n}\n\non eCommit do {goto Accepted;}\non eAbort do {goto Rejected;}\n</code></pre> <p>We use a function called \"preference\" to decide whether to vote yes or no on a transaction. We also use a function, \"coordinator,\" to get the address of the coordinator machine.</p>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#pure-functions","title":"Pure Functions","text":"<p>The 2PC model described above uses three special functions, <code>participants</code>, <code>coordinator</code>, and <code>preference</code>, that capture the set of participants, the coordinator in charge, and the preference of individual participants for the given request. In this simple system, there is always one coordinator and a fixed set of participants, but we want the proof to work for any function that satisfies those conditions. In P, we can use the new concept of \"pure\" functions to model this (what SMT-LIB calls functions). Specifically, we can declare the three special functions as follows.</p> <pre><code>pure participants(): set[machine];\npure coordinator(): machine;\npure preference(m: machine) : bool;\n</code></pre> <p>The participants function is a pure function with no body that takes no argument and returns a set of machines. The coordinator function is similar but only returns a single machine. The preference function, which also has no body, takes a machine and returns a preference. We call these functions \"pure\" because they can have no side-effects and behave like mathematical functions (e.g., calling the same pure function twice with the same arguments must give the same result). When pure functions do not have bodies, they are like foreign functions that we can guarantee don't have side-effects. When pure functions do have bodies, the bodies must be side-effect-free expressions.</p>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#initialization-conditions","title":"Initialization Conditions","text":"<p>We want our model to capture many different system configurations (e.g., number of participants) but not all configurations are valid. For example, we want to constrain the <code>participants</code> function to only point to participant machines. Initialization conditions let us constrain the kinds of systems that we consider. You can think of these as constraints that P test harnesses have to satisfy to be considered valid.</p> <p>In our 2PC model, for example, we can state that, at initialization, there is a unique machine of type coordinator, and the <code>coordinator</code> function points to that machine; and every machine in the participants set is a machine of type participant.</p> <pre><code>init-condition forall (m: machine) :: m == coordinator() == m is Coordinator;\ninit-condition forall (m: machine) :: m in participants() == m is Participant;\n</code></pre> <p>We can also state that all <code>yesVotes</code> tallies start empty.</p> <pre><code>init-condition forall (c: Coordinator) :: c.yesVotes == default(set[machine]);\n</code></pre> <p>When we write a proof of correctness later in this tutorial, we will be restricting the systems that we consider to those that satisfy the initialization conditions listed above.</p>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#quantifiers-and-machine-types","title":"Quantifiers and Machine Types","text":"<p>Our initialization conditions contain two new P features: the <code>init</code> keyword, and quantified expressions (<code>forall</code> and <code>exists</code>). Even more interesting, one quantifier above is over a machine subtype (<code>coordinator</code>). </p> <p>In P, the only way to dereference a machine variable inside of a specification (like the <code>init-condition</code>s above) is by specifically quantifying over that machine type. In other words, <code>forall (c: Coordinator) :: c.yesVotes == default(set[machine])</code> is legal but <code>forall (c: machine) :: c.yesVotes == default(set[machine])</code> is not, even though they might appear to be similar. The reason for this is that selecting (using the <code>.</code> operator) on an incorrect subtype (e.g., trying to get <code>yesVotes</code> from a participant machine) is undefined. Undefined behavior in formal verification can lead to surprising results that can be really hard to debug, so in P we syntactically disallow this kind of undefined behavior altogether.</p>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#ps-builtin-specifications-and-our-first-proof-attempt","title":"P's Builtin Specifications And Our First Proof Attempt","text":"<p>Using the code described above, and by setting the target to <code>PVerifier</code> in the <code>.pproj</code> file, you can now run the verification engine for the first time (execute <code>p compile</code>). This run will result in a large list of failures, containing items like <code>\u274c  Failed to verify that Coordinator never receives eVoteReq in Init</code>. These failures represent P's builtin requirements that all events are handled. They also give us a glimpse into how verification by induction works.</p> <p>Proofs by induction consist of a base case check and an inductive step check. The inductive step is more interesting and so we will focus our attention there. The high level idea is that you assume you are in a good state of the system (I will describe what I mean by good in the next section), and then you check if taking any step of the system will again land you in a good state. in P, taking a step of the system means executing any event handler in any machine.</p> <p>When we ran our verification engine it reported that it failed to prove that all of P's builtin specifications were satisfied. Specifically, the verification engine gave us a list of all the builtin specifications that it failed to prove, like <code>\u274c  Failed to verify that Coordinator never receives eVoteReq in Init</code>.</p> <p>The verification engine is unable to prove these properties not because the system is incorrect, but rather because it needs help from the user to complete it's proof: it needs the user to define the good states. More formally, it needs the user to define an inductive invariant that implies that no builtin P specification is violated.</p>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#invariants-and-our-first-proof","title":"Invariants And Our First Proof","text":"<p>Users can provide invariants to P using the <code>invariant</code> keyword. The goal is to find a set of invariants whose conjunction is inductive and implies the desired property. For now, the desired property is that no builtin P specification is violated.</p> <p>In the 2PC model, the following 10 invariants are sufficient to prove that no builtin P specification is violated.</p> <pre><code>invariant one_coordinator: forall (m: machine) :: m == coordinator() == m is Coordinator;\ninvariant participant_set: forall (m: machine) :: m in participants() == m is Participant;\n\ninvariant never_commit_to_coordinator: forall (e: event) :: e is eCommit &amp;&amp; e targets coordinator() ==&gt; !inflight e;\ninvariant never_abort_to_coordinator: forall (e: event) :: e is eAbort &amp;&amp; e targets coordinator() ==&gt; !inflight e;\ninvariant never_req_to_coordinator: forall (e: event) :: e is eVoteReq &amp;&amp; e targets coordinator() ==&gt; !inflight e;\ninvariant never_yes_to_participant: forall (e: event, p: Participant) :: e is eYes &amp;&amp; e targets p ==&gt; !inflight e;\ninvariant never_yes_to_init: forall (e: event, c: Coordinator) :: e is eYes &amp;&amp; e targets c &amp;&amp; c is Init ==&gt; !inflight e;\ninvariant never_no_to_participant: forall (e: event, p: Participant) :: e is eNo &amp;&amp; e targets p ==&gt; !inflight e;\ninvariant never_no_to_init: forall (e: event, c: Coordinator) :: e is eNo &amp;&amp; e targets c &amp;&amp; c is Init ==&gt; !inflight e;\ninvariant req_implies_not_init: forall (e: event, c: Coordinator) :: e is eVoteReq &amp;&amp; c is Init ==&gt; !inflight e;\n</code></pre> <p>The first two invariants state that, over the run of the system, our assumptions about the <code>coordinator</code> and <code>participants</code> functions remain satisfied. The next eight invariants ensure that messages target the correct kind of machine. For example, the invariant called <code>never_req_to_coordinator</code> says that there is never a vote request message going to a coordinator. These invariants use the special predicate <code>inflight</code> which is true iff the argument message has been sent but not received. P also supports a similar predicate called <code>sent</code> which is true iff the argument message has been sent.</p> <p>After adding these invariants, we can re-run the verification engine to get the following output.</p> <pre><code>\ud83c\udf89 Verified 10 invariants!\n\u2705 one_coordinator\n\u2705 participant_set\n\u2705 never_commit_to_coordinator\n\u2705 never_abort_to_coordinator\n\u2705 never_req_to_coordinator\n\u2705 never_yes_to_participant\n\u2705 never_yes_to_init\n\u2705 never_no_to_participant\n\u2705 never_no_to_init\n\u2705 req_implies_not_init\n\u274c Failed to verify 30 properties!\n\u2753  Failed to verify invariant never_commit_to_coordinator at PSrc/System.p:13:5 \n...\n\u2753  Failed to verify invariant never_no_to_participant at PSrc/System.p:40:12 \n</code></pre> <p>What went wrong? Well, loops are tricky to reason about, so P requires users to provide loop invariants. You can think of these as summaries of what the loop does. P uses these summaries to prove other properties and checks that the loops actually abide by the given summaries. For example, we can add loop invariants to the first broadcast loop that we wrote---the one that sends out vote requests---as follows.</p> <pre><code>foreach (p in participants()) \n    invariant forall new (e: event) :: forall (m: machine) :: e targets m ==&gt; m in participants();\n    invariant forall new (e: event) :: e is eVoteReq;\n{\n    send p, eVoteReq;\n}\n</code></pre> <p>After adding similar loop invariants to all three loops in the model, we can re-run the verification engine to get the following output.</p> <pre><code>\ud83c\udf89 Verified 10 invariants!\n\u2705 one_coordinator\n\u2705 participant_set\n\u2705 never_commit_to_coordinator\n\u2705 never_abort_to_coordinator\n\u2705 never_req_to_coordinator\n\u2705 never_yes_to_participant\n\u2705 never_yes_to_init\n\u2705 never_no_to_participant\n\u2705 never_no_to_init\n\u2705 req_implies_not_init\n\u2705 default P proof obligations\n</code></pre> <p>Notice that our initial model uses <code>ignore</code> statements that we did not describe when introducing the model. If we remove these statements, the verification engine will not be able to prove that no builtin P specification is violated. In some cases, that is because the ignore statements are necessary. For example, it is possible for the coordinator to receive a \"yes\" or \"no\" vote when it is in the <code>Aborted</code> state. The <code>ignore</code> keyword lets us tell the verifier that we have thought of these cases.</p>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#invariant-groups-proof-scripts-and-proof-caching","title":"Invariant Groups, Proof Scripts, and Proof Caching","text":"<p>When writing larger proofs, it will become useful to group invariants into lemmas, and then to tell the verifier how to use these lemmas for its proof checking. This helps the user organize their proofs; it helps the verifier construct smaller, more stable queries; and it helps avoid checking the same queries over and over, through caching.</p> <p>For example, we will write more complex specifications for the 2PC protocol but we will continue to verify that the builtin P specifications are satisfied. Instead of having to execute the verifier over and over to check these builtin properties as we build our larger proofs, we want to cache these results. Futhermore, we don't want any new specifications to interfere with these proof results---unless the model changes there really is no reason to look for a different proof of these same properties.</p> <p>P allows users to define invariant groups, like the following.</p> <pre><code>Lemma system_config {\n    invariant one_coordinator: forall (m: machine) :: m == coordinator() == m is Coordinator;\n    invariant participant_set: forall (m: machine) :: m in participants() == m is Participant;\n    invariant never_commit_to_coordinator: forall (e: event) :: e is eCommit &amp;&amp; e targets coordinator() ==&gt; !inflight e;\n    invariant never_abort_to_coordinator: forall (e: event) :: e is eAbort &amp;&amp; e targets coordinator() ==&gt; !inflight e;\n    invariant never_req_to_coordinator: forall (e: event) :: e is eVoteReq &amp;&amp; e targets coordinator() ==&gt; !inflight e;\n    invariant never_yes_to_participant: forall (e: event, p: Participant) :: e is eYes &amp;&amp; e targets p ==&gt; !inflight e;\n    invariant never_yes_to_init: forall (e: event, c: Coordinator) :: e is eYes &amp;&amp; e targets c &amp;&amp; c is Init ==&gt; !inflight e;\n    invariant never_no_to_participant: forall (e: event, p: Participant) :: e is eNo &amp;&amp; e targets p ==&gt; !inflight e;\n    invariant never_no_to_init: forall (e: event, c: Coordinator) :: e is eNo &amp;&amp; e targets c &amp;&amp; c is Init ==&gt; !inflight e;\n    invariant req_implies_not_init: forall (e: event, c: Coordinator) :: e is eVoteReq &amp;&amp; c is Init ==&gt; !inflight e;\n}\n</code></pre> <p>These are all the same invariants we used above but now grouped inside a lemma called <code>system_config</code>. We can then use this lemma to decompose our proof using a proof script.</p> <pre><code>Proof {\n    prove system_config;\n    prove default using system_config;\n}\n</code></pre> <p>This proof script has two steps. First it says that we need to prove that the lemma always holds (that the conjunction of the invariants are inductive for this model). Second we prove that P's default specifications always hold and tell the solver to use the <code>system_config</code> lemma to do so. When we run the verification engine again, we will get the following output.</p> <pre><code>\ud83c\udf89 Verified 10 invariants!\n\u2705 system_config: one_coordinator\n\u2705 system_config: participant_set\n\u2705 system_config: never_commit_to_coordinator\n\u2705 system_config: never_abort_to_coordinator\n\u2705 system_config: never_req_to_coordinator\n\u2705 system_config: never_yes_to_participant\n\u2705 system_config: never_yes_to_init\n\u2705 system_config: never_no_to_participant\n\u2705 system_config: never_no_to_init\n\u2705 system_config: req_implies_not_init\n\u2705 default P proof obligations\n</code></pre> <p>Notice that the first time you run this verification it will take much longer than the second time. That is because the proof is cached and the solver is not executed the second time. If we don't change our model or our lemma, these queries will never be executed again.</p>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#first-2pc-specification-and-proof","title":"First 2PC Specification and Proof","text":"<p>Proving that the builtin P specifications are satisfied is all well and good, but it isn't exactly the most interesting property. Zhang et al. provide a more exciting specification that we can verify (\"2PC-Safety\"). Translated into P, their specification looks like the following invariant.</p> <pre><code>invariant safety: forall (p1: Participant) :: p1 is Accepted ==&gt; (forall (p2: Participant) :: preference(p2));\n</code></pre> <p>This invariant says that if any participant is in the accepted state, then every participant must have wanted to accept the request. Zhang et al. also provide a set of inductive invariants that help prove the safety property above (Fig. 5 in their paper). For our model in P, this set of invariants looks like the following.</p> <pre><code>Lemma kondo {\n    invariant a1a: forall (e: eYes) :: inflight e ==&gt; e.source in participants();\n    invariant a1b: forall (e: eNo)  :: inflight e ==&gt; e.source in participants();\n    invariant a2a: forall (e: eYes) :: inflight e ==&gt; preference(e.source);\n    invariant a2b: forall (e: eNo)  :: inflight e ==&gt; !preference(e.source);\n    invariant a3b: forall (e: eAbort)  :: inflight e ==&gt; coordinator() is Aborted;\n    invariant a3a: forall (e: eCommit) :: inflight e ==&gt; coordinator() is Committed;\n    invariant  a4: forall (p: Participant) :: p is Accepted ==&gt; coordinator() is Committed;\n    invariant  a5: forall (p: Participant, c: Coordinator) :: p in c.yesVotes ==&gt; preference(p);\n    invariant  a6: coordinator() is Committed ==&gt; (forall (p: Participant) :: p in participants() ==&gt; preference(p));\n}\n</code></pre> <p>Given the desired safety property that we want to prove and the set of invariants that helps us prove it, we can write the following proof script in P that checks that the proof by induction passes.</p> <pre><code>Proof {\n    prove system_config;\n    prove kondo using system_config;\n    prove safety using kondo;\n    prove default using system_config;\n}\n</code></pre> <p>Running the verification engine on this file will produce the following.</p> <pre><code>\ud83c\udf89 Verified 20 invariants!\n\u2705 safety\n\u2705 system_config: one_coordinator\n\u2705 system_config: participant_set\n\u2705 system_config: never_commit_to_coordinator\n\u2705 system_config: never_abort_to_coordinator\n\u2705 system_config: never_req_to_coordinator\n\u2705 system_config: never_yes_to_participant\n\u2705 system_config: never_yes_to_init\n\u2705 system_config: never_no_to_participant\n\u2705 system_config: never_no_to_init\n\u2705 system_config: req_implies_not_init\n\u2705 kondo: a1a\n\u2705 kondo: a1b\n\u2705 kondo: a2a\n\u2705 kondo: a2b\n\u2705 kondo: a3b\n\u2705 kondo: a3a\n\u2705 kondo: a4\n\u2705 kondo: a5\n\u2705 kondo: a6\n\u2705 default P proof obligations\n</code></pre> <p>Showing that the verification passes. Notice that if you remove any of the invariants from the lemmas, like say <code>a5</code> in <code>kondo</code>, the proof will fail with the following output.</p> <pre><code>\u274c Failed to verify 1 properties!\n\u2753 Failed to verify invariant kondo: a6 at PSrc/System.p:27:12 \n</code></pre>"},{"location":"advanced/PVerifierLanguageExtensions/twophasecommitverification/#recap-and-next-steps","title":"Recap and Next Steps","text":"<p>In this tutorial, we formally verified a simplified 2PC protocol in P. The full, final code for the verification is available here.</p> <p>Our proof followed the running example of Zhang et al. but also included the verification of builtin P specifications. Along the way, we introduced the following new P keywords and concepts.</p> <ol> <li><code>pure</code> functions;</li> <li><code>init-condition</code> predicates;</li> <li>quantifiers;</li> <li>proofs by induction;</li> <li><code>invariant</code>s;</li> <li><code>inflight</code> and <code>sent</code>;</li> <li>loop invariants;</li> <li><code>lemma</code>s as invariant groups;</li> <li><code>proof</code> scripts; and</li> <li>proof caching.</li> </ol> <p>In a future tutorial, we will expand on this simple 2PC protocol by introducing a key-value store and a monitor specification.</p>"},{"location":"advanced/PVerifierLanguageExtensions/using-pverifier/","title":"Using PVerifier","text":"<p>Before moving forward, we assume that you have successfully installed the PVerifier.</p> <p>In this section, we provide an overview of the steps involved in verifying a P program using the two-phase commit example in Tutorials.</p> Get the Two-Phase Commit Example Locally <p>We will use the TwoPhaseCommit example from Tutorial folder in P repository to describe the process of verifying a P program. Please clone the P repo and navigate to the TwoPhaseCommit example in Tutorial.</p> <p>Clone P Repo locally: <pre><code>git clone https://github.com/p-org/P.git\n</code></pre> Navigate to the TwoPhaseCommit examples folder: <pre><code>cd &lt;P cloned folder&gt;/Tutorial/2_TwoPhaseCommit\n</code></pre></p>"},{"location":"advanced/PVerifierLanguageExtensions/using-pverifier/#verifying-a-p-program","title":"Verifying a P program","text":"<p>To verify a P program using the PVerifier, you need to:</p> <ol> <li>Configure your project to use PVerifier as the target in your <code>.pproj</code> file</li> <li>Compile the project using the P compiler</li> </ol> <p>This process follows the same workflow described in Using P, except that we specify <code>PVerifier</code> as the backend instead of other targets like <code>CSharp</code> or <code>Java</code>.</p>"},{"location":"advanced/PVerifierLanguageExtensions/using-pverifier/#executing-the-verification","title":"Executing the verification","text":"<p>After setting the target to <code>PVerifier</code> in your project file, run the P compiler with the following command:</p> <pre><code>p compile\n</code></pre> <p>The compiler will generate verification code and automatically invoke the PVerifier to check your model against the specifications defined in your P program. The verification results will be displayed in the terminal, showing whether the properties are satisfied or if there are any violations along with counterexample traces.</p> <p>Running the verification engine on the Two-Phase Commit example will produce the following.</p> <pre><code>\ud83c\udf89 Verified 20 invariants!\n\u2705 system_config_one_coordinator\n\u2705 system_config_participant_set\n\u2705 system_config_never_commit_to_coordinator\n\u2705 system_config_never_abort_to_coordinator\n\u2705 system_config_never_req_to_coordinator\n\u2705 system_config_never_yes_to_participant\n\u2705 system_config_never_yes_to_init\n\u2705 system_config_never_no_to_participant\n\u2705 system_config_never_no_to_init\n\u2705 system_config_req_implies_not_init\n\u2705 kondo_a1a\n\u2705 kondo_a1b\n\u2705 kondo_a2a\n\u2705 kondo_a2b\n\u2705 kondo_a3b\n\u2705 kondo_a3a\n\u2705 kondo_a4\n\u2705 kondo_a5\n\u2705 kondo_a6\n\u2705 safety\n\u2705 default P proof obligations\n</code></pre>"},{"location":"advanced/psym/install/","title":"Install","text":"<p>PSym is built to be cross-platform and can be used on MacOS, Linux, and Windows.</p>"},{"location":"advanced/psym/install/#steps-1-to-5-install-p","title":"[Steps 1 to 5] Install P","text":"<p>Follow the instructions on installing P from Installing P (at least up to and including Step 3)</p>"},{"location":"advanced/psym/install/#step-6-install-maven","title":"[Step 6] Install Maven","text":"<p>If you already have Maven 3.3+ installed , ignore this step. To install Maven use:</p> MacOSUbuntuAmazon LinuxWindows <p>Installing Maven on MacOS using Homebrew (details)</p> <pre><code>brew install maven\n</code></pre> <p>Dont have Homebrew? Directly use installer.</p> <p>Installing Maven on Ubuntu (details)</p> <pre><code>sudo apt install maven\n</code></pre> <p>Visit the Maven releases page</p> <p>Identify the latest release or the release you wish to use.</p> <p>Steps for installing Maven 3.8.6 on Amazon Linux (you can use any version of Maven 3.3+):</p> <pre><code>wget https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.tar.gz\ntar xfv apache-maven-3.8.6-bin.tar.gz\n</code></pre> <p>You might do this in your home directory, yielding a folder like <code>/home/$USER/apache-maven-3.8.6</code></p> <p>Next, install the software into your environment by adding it to your path, and by defining Maven's environment variables:</p> <pre><code>export M2_HOME=/home/$USER/apache-maven-3.6.3\nexport M2=$M2_HOME/bin\nexport PATH=$M2:$PATH\n</code></pre> <p>Installing Maven on Windows (details)</p> Troubleshoot: Confirm that Maven is correctly installed on your machine. <p><code>mvn -version</code></p> <p>If you get <code>mvn</code> command not found error, mostly likely, you need to add the path to <code>$M2_HOME/bin</code> in your <code>PATH</code>.</p> <p>Great ! You are all set to check your P program with PSym !</p>"},{"location":"advanced/psym/usingPSym/","title":"usingPSym","text":"<p>Before moving forward, we assume that you have successfully installed PSym  .</p> <p>In this section, we provide an overview of the steps involved in compiling and checking a P program with PSym using the client server example in Tutorials.</p> Get the Client Server Example Locally <p>We will use the ClientServer example from Tutorial folder in P repository to describe the process of compiling and checking a P program with PSym. Please clone the P repo and navigate to the ClientServer example in Tutorial.</p> <p>Clone P Repo locally: <pre><code>git clone https://github.com/p-org/P.git\n</code></pre> Navigate to the ClientServer examples folder: <pre><code>cd &lt;P cloned folder&gt;/Tutorial/1_ClientServer\n</code></pre></p>"},{"location":"advanced/psym/usingPSym/#compiling-a-p-program-for-psym","title":"Compiling a P program for PSym","text":"<p>Simply pass the commandline argument <code>-generate:PSym</code> when running the P compiler <code>pc</code>.</p> Alternative way: Set <code>&lt;Target&gt;</code> as <code>PSym</code> in <code>*.pproj</code> <p>Set the <code>&lt;Target&gt;</code> field as <code>PSym</code> in the P project file (<code>*.pproj</code>)</p> <p>Example:</p> <pre><code>&lt;!-- P Project file for the Client Server example --&gt;\n&lt;Project&gt;\n&lt;ProjectName&gt;ClientServer&lt;/ProjectName&gt;\n&lt;InputFiles&gt;\n   &lt;PFile&gt;./PSrc/&lt;/PFile&gt;\n   &lt;PFile&gt;./PSpec/&lt;/PFile&gt;\n   &lt;PFile&gt;./PTst/&lt;/PFile&gt;\n&lt;/InputFiles&gt;\n&lt;OutputDir&gt;./PGenerated/&lt;/OutputDir&gt;\n&lt;Target&gt;PSym&lt;/Target&gt;\n&lt;/Project&gt;\n</code></pre> <p>Recommendation</p> <p>We recommend using the P project file <code>*.pproj</code> along with passing <code>-generate:PSym</code> as commandline argument to the compiler to compile a P program for PSym. Commandline argument <code>-generate:XXX</code> takes priority over <code>&lt;Target&gt;YYY&lt;/Target&gt;</code> in <code>*.pproj</code> file.</p> Compiling the ClientServer project for PSym <pre><code>pc -proj:ClientServer.pproj -generate:PSym\n</code></pre> Expected Output <pre><code>$ pc -proj:ClientServer.pproj -generate:PSym\n----------------------------------------\n==== Loading project file: ClientServer.pproj\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p\n....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p\n....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p\n....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p\n----------------------------------------\n----------------------------------------\nParsing ...\nType checking ...\nCode generation ...\nGenerated clientserver.java.\n----------------------------------------\nCompiling ClientServer...\n  ClientServer -&gt; target/ClientServer-jar-with-dependencies.jar\nBuild succeeded.\n----------------------------------------\n</code></pre>"},{"location":"advanced/psym/usingPSym/#checking-a-p-program-with-psym","title":"Checking a P program with PSym","text":"<p>Compiling the ClientServer program generates a <code>ClientServer-jar-with-dependencies.jar</code>. This <code>.jar</code> is the symbolically-instrumented intermediate representation of the P program in Java, along with a packaged PSym runtime. Running this <code>.jar</code> file executes PSym to systematically explore behaviors of the program for the specified test case.</p> <p>The <code>.jar</code> is present in the <code>target/</code> folder, also printed in the compiler output: <code>ClientServer -&gt; target/ClientServer-jar-with-dependencies.jar</code></p> <p>You can get the list of test cases defined in the P program by running the generated <code>.jar</code>:</p> <pre><code>java -jar target/ClientServer-jar-with-dependencies.jar\n</code></pre> Expected Output <pre><code>java -jar target/ClientServer-jar-with-dependencies.jar\n\nPicked up JAVA_TOOL_OPTIONS: -Dlog4j2.formatMsgNoLookups=true\nWARNING: sun.reflect.Reflection.getCallerClass is not supported. This will impact performance.\nReflections took 100 ms to scan 1 urls, producing 38 keys and 168 values\nLoading:: /Volumes/workplace/psym/src/PSymTest/exp/Examples/Tutorial/1_ClientServer/target/ClientServer-jar-with-dependencies.jar\nSetting solver engine to BDD + Bdd\nReflections took 63 ms to scan 1 urls, producing 38 keys and 168 values\nProvide /method or -m flag to qualify the test method name you wish to use.\nPossible options are::\ntcSingleClient\ntcMultipleClients\n</code></pre> <p>There are three test cases defined in the ClientServer P project, and you can specify which test case to run by using the <code>-m</code> or <code>--method</code> parameter along with, say, a <code>--time-limit &lt;seconds&gt;</code> parameter to specify a time limit for the run in seconds. By default, PSym explores as many schedules as it can within a time limit of 60 seconds.</p> <p>So to run the <code>tcSingleClient</code> test case for 10 seconds, we can use the following command:</p> <pre><code>java -jar target/ClientServer-jar-with-dependencies.jar \\\n    -m tcSingleClient \\\n    --time-limit 10\n</code></pre> Expected Output <pre><code>Picked up JAVA_TOOL_OPTIONS: -Dlog4j2.formatMsgNoLookups=true\nWARNING: sun.reflect.Reflection.getCallerClass is not supported. This will impact performance.\nReflections took 93 ms to scan 1 urls, producing 38 keys and 172 values\n. Checking /Users/goelaman/work/ws/version/github/P/Tutorial/1_ClientServer/target/ClientServer-jar-with-dependencies.jar\nReflections took 45 ms to scan 1 urls, producing 38 keys and 172 values\n... Method tcSingleClient\n... Project clientserver is using 'default' strategy (seed:0)\n--------------------\n  Time       Memory        Coverage      Schedule         Remaining          Depth      States\n00:00:10     0.2 GB     1.4246418994 %      140        1820 (100 % data)        1         8043\n--------------------\nEstimated Coverage:: 1.4246418994 %\nDistinct States Explored:: 8043\n--------------------\nExplored 140 single executions\nTook 10 seconds and 0.2 GB\nResult: partially safe with 1820 backtracks remaining\n--------------------\njava.lang.Exception: TIMEOUT\nat psym.commandline.EntryPoint.process(EntryPoint.java:97)\nat psym.commandline.EntryPoint.run(EntryPoint.java:138)\nat psym.commandline.PSym.main(PSym.java:73)\n</code></pre> <p>Here, PSym explores 140 schedules, checking 8043 distinct states, and achieving an estimated coverage of ~ 1.4 %.</p> <p>Check file <code>output/coverage-clientserver.log</code> for a detailed Coverage Report.</p> <p>Check file <code>output/stats-clientserver.log</code> for a detailed Statistics Report.</p>"},{"location":"advanced/psym/usingPSym/#coverage","title":"Coverage","text":"<p>At the end of a run, PSym reports a coverage metric as an estimated percentage of the execution tree that is explored during the run. Assuming a uniform probability for each scheduling/data choice, this metric reports the probability of a randomly-sampled schedule to be bug free.</p> Continuous Feedback <p>During the run, PSym prints useful metrics that summarizes the current status of the run.</p> <p>For example, for the ClientServer run above, PSym prints:</p> <pre><code>  Time       Memory        Coverage      Schedule         Remaining          Depth      States\n00:00:10     0.2 GB     1.4246418994 %      140        1820 (100 % data)        1         8043\n</code></pre> <p>that summarizes:</p> Label Description Time Elapsed runtime in <code>hh:mm:ss</code> format Memory Memory usage in gigabytes Coverage Estimated Coverage Schedule Schedule number Remaining Number of unexplored backtracks/choices remaining (as well as % of data choices) Depth Current depth of the exploration States Number of distinct states explored <p>[Important] Is the coverage reported exactly measures the % of state-space covered?</p> <p>Sadly, No !</p> <p>PSym's coverage metric is not a perfect state-space coverage metric. This metric gives more weightage to shorter schedules, or more precisely, schedules with fewer schedule/data choices at shallower search depths. Therefore, a PSym run can quickly reach a high estimated coverage (&gt; 99 %) due to exploring shorter schedules first, after which gaining the remaining left-over percentage can become increasingly (and exponentially) difficult.</p> <p>Our recommendation is to target achieving coverage up to 11 nines, i.e., 99.999999999 % to be sufficiently confident of the absence of bug. Additionally, check PSym's Coverage Report (<code>output/coverage-*.log</code>) to understand the state-space covered during the run, as well as the number of distinct states explored.</p> <p>At the end of a run, PSym also prints a coverage report in <code>output/coverage-*.log</code> that tabulates, for each exploration step/depth, the number of schedule/data choices explored during the run, along with the number of choices remaining as unexplored backtracks. For example, coverage report corresponding to the previous ClientServer run can be found in <code>output/coverage-clientserver.log</code></p> Example <p>Here is a snippet of the ClientServer coverage report: <code>output/coverage-clientserver.log</code></p> <pre><code>-----------------\nCoverage Report::\n-----------------\nCovered choices:    8239 scheduling,  1962 data\nRemaining choices:     0 scheduling, 30292 data\n-------------------------------------\nDepth   Covered       Remaining\n      sch    data     sch    data\n-------------------------------------\n 0            100\n 1    100\n 2    100     134            5806\n 3    135\n 4    134\n 5    134\n 6    134\n 7    134      50            1162\n 8    134      77            2659\n 9    127\n10    127\n11    127      36             559\n12    127      48            1045\n13    124      36            1149\n14    120\n15    120      23             296\n16    120      36             621\n17    114      34             766\n18    111      18             468\n19    111      19             203\n20    112      24             374\n21    109      31             582\n22    106      25             494\n23    106      20             250\n24    104      19             256\n25    102      22             326\n26     98      26             365\n27     97      23             319\n28     96      19             222\n29     95      20             268\n30     95      23             298\n31     93      23             279\n32     91      19             233\n33     91      20             243\n34     89      18             232\n35     88      22             263\n36     85      17             181\n37     83      15             176\n38     79      16             198\n39     76      19             221\n40     73      20             199\n41     73      15             176\n42     71      10             123\n43     70      20             225\n44     68      20             208\n45     68      16             187\n46     66      10             123\n47     66      17             190\n48     66      18             187\n49     64      16             186\n50     62      10             114\n            .\n            .\n            .\n</code></pre> Improving Coverage for ClientServer <p>Looks like the ClientServer example is quite data heavy, since there are lots of unexplored data choices at different steps (check the rightmost column of <code>output/coverage-clientserver.log</code>). A good idea is to reduce the amount of data non-determinism by reducing the number of choices in the <code>choose(*)</code> expressions, such as the number of data choices in setting the initial bank balances in expression <code>choose(100)</code> here.</p> Remaining choices in Coverage Report <p>Note that the coverage report can be incomplete, since it tabulates the remaining choices as of by the end of a run. Each remaining choice, say at a step N, when explored by PSym can discover many more choices at steps &gt;= N+1.</p>"},{"location":"advanced/psym/usingPSym/#cli-options","title":"CLI Options","text":"<p>Here is a list of frequently-used commandline options that can be passed to the <code>.jar</code>:</p> CLI Option Description Default <code>--method &lt;string&gt;</code> Name of the test method to execute <code>auto</code> <code>--time-limit &lt;sec&gt;</code> Time limit in seconds (use 0 for no limit) <code>60</code> <code>--memory-limit &lt;MB&gt;</code> Memory limit in megabytes (use 0 for no limit) <code>auto</code> <code>--schedules &lt;int&gt;</code> Number of schedules to explore (use 0 for no limit) <code>0</code> <code>--max-steps &lt;int&gt;</code> Max scheduling steps to be explored per schedule <code>1000</code> <code>--seed &lt;int&gt;</code> Random seed to use for the exploration <code>0</code> <code>--verbose &lt;int&gt;</code> Level of verbosity in the log output <code>0</code> <code>--mode &lt;string&gt;</code> Preconfigured exploration mode to use (<code>default</code>, <code>bmc</code>, <code>fuzz</code>) <code>default</code> <p>For a complete list of options, pass the argument <code>--help</code>.</p> Exploration Techniques <p>PSym implements a collection of configurable techniques summarized as follows:</p> Technique Description Search Strategy Configure the order in which search is performed: <code>astar</code>, <code>random</code>, <code>dfs</code>, <code>learn</code> Choice Selection Configure how a scheduling or data choice is selected: <code>random</code>, <code>learn</code> Never Repeat States Track distinct states to avoid state revisits Stateful Backtracking Backtrack directly without replay BMC Run PSym as a bounded model checker <p>Preconfigured Modes</p> <p>For ease of usage, PSym provides a set of preconfigured exploration modes as follows:</p> Mode Description <code>default</code> Explore single execution at a time  Search Strategy = <code>astar</code>  Choice Selection = <code>random</code>  Never Repeat States = <code>ON</code>  Stateful Backtracking = <code>ON</code>  BMC = <code>OFF</code> <code>bmc</code> Explore all executions together symbolically as a bounded model checker  Search Strategy = <code>N/A</code>  Choice Selection = <code>N/A</code>  Never Repeat States = <code>OFF</code>  Stateful Backtracking = <code>N/A</code>  BMC = <code>ON</code> <code>fuzz</code> Explore like a random fuzzer (but never repeat an execution!)  Search Strategy = <code>random</code>  Choice Selection = <code>random</code>  Never Repeat States = <code>OFF</code>  Stateful Backtracking = <code>OFF</code>  BMC = <code>OFF</code> <code>dfs</code> Explore single executions at a time in depth-first manner  Search Strategy = <code>dfs</code>  Choice Selection = <code>random</code>  Never Repeat States = <code>ON</code>  Stateful Backtracking = <code>ON</code>  BMC = <code>OFF</code> <code>learn</code> Explore single execution at a time with learning  Search Strategy = <code>learn</code>  Choice Selection = <code>learn</code>  Never Repeat States = <code>ON</code>  Stateful Backtracking = <code>ON</code>  BMC = <code>OFF</code> <p>Pass the CLI argument <code>--mode &lt;option&gt;</code> to set the exploration mode.</p> <p>You are now a pro ! Give PSym a try on your P model and shared your feedback with us.</p>"},{"location":"advanced/psym/whatisPSym/","title":"whatisPSym","text":"<p>PSym is a new checker for P models developed to complement the default P checker with the primary objective to avoid repetition during state-space exploration. PSym guarantees to never repeat an already-explored execution, and hence, can exhaustively explore all possible executions. PSym also has an inbuilt coverage tracker that reports estimated coverage to give measurable and continuous feedback (even when no bug is found during exploration).</p> <p>Recommendation</p> <p>Exhaustively exploring all possible executions is generally not possible for large models due to time/memory constraints. We recommend always trying PSym with easier tests first, such as ones with only a small number of replica machines and <code>choose(*)</code> expressions with fewer choices.</p> <p>P compiler has a dedicated backend for PSym, which compiles the P model into a symbolically-instrumented intermediate representation in Java, packed as a single <code>.jar</code> file. Executing the <code>.jar</code> file runs PSym runtime. Commandline arguments can be passed when running the <code>.jar</code> file to configure the exploration strategy. At the end of a run, PSym reports the result (safe / buggy / partially-safe), an error trace (if found a bug), along with a coverage and statistics report.</p> <pre><code>graph LR\n  Pmodel(P Model &lt;br/&gt; *.p) --&gt; Pcompiler[P Compiler]--&gt; IR(Symbolic IR in Java &lt;br/&gt; *.jar) --&gt; Psym[PSym Runtime];\n  Psym[PSym Runtime] --&gt; Result[Result &lt;br/&gt; Coverage &lt;br/&gt; Statistics];\n\n  style Pcompiler fill:#FFEFD5,stroke:#FFEFD5,stroke-width:2px\n  style Psym fill:#FFEFD5,stroke:#FFEFD5,stroke-width:2px\n  style Result fill:#CCFF66,stroke:#CCFF66,stroke-width:2px</code></pre>"},{"location":"getstarted/PeasyIDE/","title":"Peasy - IDE for P","text":""},{"location":"getstarted/PeasyIDE/#peasy-an-easy-to-use-development-environment-for-p","title":"Peasy: An easy-to-use development environment for P","text":"<p> Peasy is a step towards making application of P in practice easy-peasy</p> <p>Peasy offers an intuitive development environment tailored specifically for the P programming language, making it easier for developers to edit, compile, test, debug, and visualize their P programs.</p> <p>Peasy provides syntax highlighting for code clarity and code snippets to reduce development time, automated compilation and testing for hassle-free program development. Moreover, Peasy's trace and state machine visualization tools provide rich analysis to gain insights into your projects and simplifies error debugging process.</p> <p>Download Peasy for VS Code</p> <p>[Recommended] Checkout Peasy's Github page for more information, getting started, and demo videos on the IDE!</p>"},{"location":"getstarted/build/","title":"Building from Source","text":"<p>If you plan to contribute a Pull Request to P then you need to build the source code and run the tests. Please make sure that you have followed the steps in the installation guide to install P dependencies.</p>"},{"location":"getstarted/build/#building-the-p-project","title":"Building the P project","text":"<p>Clone the P repo and run the following <code>build</code> script.</p> on MacOS or LinuxOn Windows <pre><code>cd Bld\n./build.sh\n</code></pre> <pre><code>cd Bld\n./build.ps1\n</code></pre>"},{"location":"getstarted/build/#running-the-tests","title":"Running the tests","text":"<p>You can run the following command to build and run the test regressions for P Compiler. Make sure you are in the root directory of the clone repo that has the <code>P.sln</code>.</p> <pre><code>dotnet build --configuration Release\ndotnet test --configuration Release\n</code></pre>"},{"location":"getstarted/build/#using-a-local-build","title":"Using a local build","text":"<p>P is distributed as a dotnet tool. To test changes locally you can:</p> <ol> <li>run <code>dotnet tool uninstall --global P</code></li> <li>navigate to <code>/Src/PCompiler/PCommandLine</code></li> <li>run   <pre><code>dotnet pack PCommandLine.csproj --configuration Release --output ./publish\n    -p:PackAsTool=true\n    -p:ToolCommandName=P\n    -p:Version=&lt;pick a version&gt;\n</code></pre></li> <li>run <code>dotnet tool install P --global --add-source ./publish</code></li> </ol>"},{"location":"getstarted/install/","title":"Installing P","text":"<p>If you want to use older P version 1.x.x, please use the installation steps here</p> <p>P is built to be cross-platform and can be used on MacOS, Linux, and Windows. We provide a step-by-step guide for installing P along with the required dependencies.</p> <p>After each step, please use the troubleshooting check to ensure that each installation step succeeded.</p>"},{"location":"getstarted/install/#step-1-install-net-core-sdk","title":"[Step 1] Install .Net Core SDK","text":"<p>The P compiler is implemented in C# and hence the tool chain requires <code>dotnet</code>. P currently uses the specific version of .Net SDK 8.0.</p> MacOSUbuntuAmazon LinuxWindows <p>Installing .Net SDK on MacOS using Homebrew (details)</p> <pre><code>brew tap isen-ng/dotnet-sdk-versions\nbrew install --cask dotnet-sdk8-0-200\n</code></pre> <p>Dont have Homebrew?  Install manually using the installer for x64 or Arm64.</p> <p>Installing .Net SDK on Ubuntu (details)</p> <pre><code>wget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\nrm packages-microsoft-prod.deb\n</code></pre> <pre><code>sudo apt update &amp;&amp; sudo apt install -y dotnet-sdk-8.0\n</code></pre> <p>Installing .Net SDK on Amazon Linux 2 (details)</p> <pre><code>wget https://dotnet.microsoft.com/download/dotnet/scripts/v1/dotnet-install.sh\nchmod +x dotnet-install.sh\n./dotnet-install.sh  -c 8.0 -i ~/.dotnet\n\n# If using a bash shell, replace .zshrc with .bashrc in the below commands\necho 'PATH=$HOME/.dotnet:$HOME/.dotnet/tools:$PATH' &gt;&gt; ~/.zshrc\necho 'export PATH' &gt;&gt; ~/.zshrc\nsource ~/.zshrc\n\nsudo mkdir /usr/share/dotnet/\nsudo cp -r ~/.dotnet/* /usr/share/dotnet/\n</code></pre> <p>Installing .Net SDK on Windows using the installer for x64 or Arm64</p> Troubleshoot: Confirm that dotnet is correctly installed on your machine. <pre><code>dotnet --list-sdks\n</code></pre> <p>You must see an SDK with <code>8.0.*</code> dotnet version installed. If you get <code>dotnet</code> command not found error, mostly likely, you need to add the path to dotnet in your <code>PATH</code>.</p> <p>Useful resources:</p> <ul> <li>For Ubuntu: fxr does not exist</li> </ul>"},{"location":"getstarted/install/#step-2-install-java-runtime","title":"[Step 2] Install Java Runtime","text":"<p>The P compiler also requires Java (<code>java</code> version 11 or higher).</p> MacOSUbuntuAmazon LinuxWindows <p>Installing Java on MacOS using Homebrew (details) <pre><code>brew install java\n</code></pre> Dont have Homebrew? Directly use installer.</p> <p>Installing Java on Ubuntu (details)</p> <pre><code>sudo apt install -y default-jre\n</code></pre> <p>Installing Java 17 on Amazon Linux (you can use any version of java &gt;= 11)</p> <pre><code>sudo yum install -y java-17-amazon-corretto\n</code></pre> <p>Installing Java on Windows (details)</p> Troubleshoot: Confirm that java is correctly installed on your machine. <pre><code>java -version\n</code></pre> <p>If you get <code>java</code> command not found error, mostly likely, you need to add the path to <code>java</code> in your <code>PATH</code>.</p>"},{"location":"getstarted/install/#step-3-install-p-tool","title":"[Step 3] Install P tool","text":"<p>Finally, let's install the P tool as a <code>dotnet tool</code> using the following command:</p> <pre><code>dotnet tool install --global P\n</code></pre> Troubleshoot: Confirm that <code>p</code> is correctly installed on your machine <p>After installation, run <code>which p</code> and it should show: <pre><code>which p\n/Users/&lt;user&gt;/.dotnet/tools/p\n</code></pre> If not, add <code>$HOME/.dotnet/tools</code> to <code>$PATH</code> in your <code>.bash_profile</code> (or equivalent) and try again after restarting the shell. If you are getting the error that the <code>p</code> command is not found, it is most likely that <code>$HOME/.dotnet/tools</code> is not in your <code>PATH</code>.</p> Updating P Compiler <p>You can update the version of <code>P</code> compiler by running the following command:</p> <pre><code>dotnet tool update --global P\n</code></pre>"},{"location":"getstarted/install/#step-4-recommended-ide-optional","title":"[Step 4] Recommended IDE (Optional)","text":"<ul> <li> <p>For developing P programs, we recommend using Peasy.</p> </li> <li> <p>For debugging generated C# code, we recommend using Rider for Mac/Linux or Visual Studio 2019 for Windows.</p> </li> <li> <p>For debugging generated Java code, we recommend using IntelliJ IDEA</p> </li> </ul> <p>Great ! You are all set to compile and check your first P program !</p>"},{"location":"getstarted/usingP/","title":"Using P Compiler and Checker","text":"<p>If you are using an older P version 1.x.x, please find the usage guide here</p> <p>Before moving forward, we assume that you have successfully installed P and the Peasy extension .</p> <p>We introduce the P language syntax and semantics in details in the Tutorials and Language Manual. In this section, we provide an overview of the steps involved in compiling and checking a P program using the client server example in Tutorials.</p> Get the Client Server Example Locally <p>We will use the ClientServer example from Tutorial folder in P repository to describe the process of compiling and checking a P program. Please clone the P repo and navigate to the ClientServer example in Tutorial.</p> <p>Clone P Repo locally: <pre><code>git clone https://github.com/p-org/P.git\n</code></pre> Navigate to the ClientServer examples folder: <pre><code>cd &lt;P cloned folder&gt;/Tutorial/1_ClientServer\n</code></pre></p>"},{"location":"getstarted/usingP/#compiling-a-p-program","title":"Compiling a P program","text":"<p>There are two ways of compiling a P program:</p> <ol> <li>Using a P project file (<code>*.pproj</code>) to provide all the required inputs to the compiler or</li> <li>Passing all the P files (<code>*.p</code>) along with other options as commandline arguments to the compiler.</li> </ol> <p>Recommendation</p> <p>We recommend using the P project files to compile a P program.</p> P Compiler commandline options <p>The P compiler provides the following commandline options:</p> <pre><code>-----------------------------------------------\nusage: p compile [--help] [--pproj string] [--pfiles string] [--projname string] [--outdir string]\n\nThe P compiler compiles all the P files in the project together and generates the executable that\ncan be checked for correctness by the P checker.\n\nCompiling using `.pproj` file:\n------------------------------\n-pp, --pproj string         : P project file to compile (*.pproj). If this option is not passed,\nthe compiler searches for a *.pproj in the current folder\n\nCompiling P files directly through commandline:\n-----------------------------------------------\n-pf, --pfiles string        : List of P files to compile\n-pn, --projname string      : Project name for the compiled output\n-o, --outdir string         : Dump output to directory (absolute or relative path)\n\nOptional Arguments:\n-------------------\n-h, --help                  Show this help menu\n-----------------------------------------------\n</code></pre> Compile using the P ProjectCompile P files directly <p>Compiling the ClientServer project using the P Project file:</p> <pre><code>p compile\n</code></pre> Expected Output <pre><code>$ p compile\n\n.. Searching for a P project file *.pproj locally in the current folder\n.. Found P project file: P/Tutorial/1_ClientServer/ClientServer.pproj\n----------------------------------------\n==== Loading project file: P/Tutorial/1_ClientServer/ClientServer.pproj\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p\n....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p\n....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p\n....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p\n----------------------------------------\nParsing ...\nType checking ...\nCode generation ...\nGenerated ClientServer.cs.\n----------------------------------------\nCompiling ClientServer...\nMSBuild version 17.3.1+2badb37d1 for .NET\nDetermining projects to restore...\nRestored P/Tutorial/1_ClientServer/PGenerated/CSharp/ClientServer.csproj (in 102 ms).\nClientServer -&gt; P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n\nBuild succeeded.\n0 Warning(s)\n0 Error(s)\n\nTime Elapsed 00:00:02.25\n\n\n----------------------------------------\n~~ [PTool]: Thanks for using P! ~~\n</code></pre> <p><code>p compile</code> command searches for the <code>*.pproj</code> file in the current directory.</p> <p>If you are running <code>p compile</code> from outside the P project directory, use the <code>-pp &lt;path to *.pproj&gt;</code> option instead.</p> P Project File Details <p>The P compiler does not support advanced project management features like separate compilation and dependency analysis (coming soon). The current project file interface is a simple mechanism to provide all the required inputs to the compiler in an XML format (ClientServer.pproj). <pre><code>&lt;!-- P Project file for the Client Server example --&gt;\n&lt;Project&gt;\n&lt;ProjectName&gt;ClientServer&lt;/ProjectName&gt;\n&lt;InputFiles&gt;\n    &lt;PFile&gt;./PSrc/&lt;/PFile&gt;\n    &lt;PFile&gt;./PSpec/&lt;/PFile&gt;\n    &lt;PFile&gt;./PTst/&lt;/PFile&gt;\n&lt;/InputFiles&gt;\n&lt;OutputDir&gt;./PGenerated/&lt;/OutputDir&gt;\n&lt;/Project&gt;\n</code></pre> The <code>&lt;InputFiles&gt;</code> block provides all the P files that must be compiled together for this project. In <code>&lt;PFile&gt;</code> one can either specify the path to a P file or to a folder and the P compiler includes all the <code>*.p</code> files in the folder during compilation. The <code>&lt;ProjectName&gt;</code> block provides the name for the project which is used as the output file name for the generated code. The <code>&lt;OutputDir&gt;</code> block provides the output directory for the generated code. Finally, the <code>&lt;IncludeProject&gt;</code> block provides a path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects (transitively including all P files in dependent projects) and compiles them together. This feature provides a way to split the P models for a large system into sub projects that can share models.</p> <p>Compiling the ClientServer program by passing all the required inputs as commandline arguments:</p> <pre><code>p compile -pf PSpec/*.p PSrc/*.p PTst/*.p -pn ClientServer -o PGenerated\n</code></pre> Expected Output <pre><code>$ p compile -pf PSpec/*.p PSrc/*.p PTst/*.p -pn ClientServer -o PGenerated\n\nParsing ...\nType checking ...\nCode generation ...\nGenerated ClientServer.cs.\n----------------------------------------\nCompiling ClientServer...\nMSBuild version 17.3.1+2badb37d1 for .NET\nDetermining projects to restore...\nRestored P/Tutorial/1_ClientServer/PGenerated/CSharp/ClientServer.csproj (in 115 ms).\nClientServer -&gt; P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n\nBuild succeeded.\n0 Warning(s)\n0 Error(s)\n\nTime Elapsed 00:00:05.74\n\n\n----------------------------------------\n~~ [PTool]: Thanks for using P! ~~\n</code></pre>"},{"location":"getstarted/usingP/#checking-a-p-program","title":"Checking a P program","text":"<p>Compiling the ClientServer program generates a <code>ClientServer.dll</code>, this <code>dll</code> is the C# representation of the P program. The P Checker takes as input this <code>dll</code> and systematically explores behaviors of the program for the specified test case.</p> <p>The path to the <code>dll</code> is present in the generated compilation output, check for line: <code>ClientServer -&gt; &lt;Path&gt;/ClientServer.dll</code></p> <p>You can get the list of test cases defined in the P program by running the P Checker:</p> <pre><code>p check\n</code></pre> <p>Expected Output</p> <pre><code>$ p check\n\n.. Searching for a P compiled file locally in the current folder\n.. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n.. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\nError: We found '3' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc).\nPossible options are:\ntcSingleClient\ntcMultipleClients\ntcAbstractServer\n\n~~ [PTool]: Thanks for using P! ~~\n</code></pre> <p><code>p check</code> command searches for the <code>*.dll</code> file in the current directory.</p> <p>If you are running <code>p check</code> from outside the directory where <code>*.dll</code> is compiled to, run <code>p check &lt;path to *.dll&gt;</code> instead.</p> <p>There are three test cases defined in the ClientServer P project, and you can specify which test case to run by using the <code>-tc</code> or <code>--testcase</code> parameter along with the <code>-s</code> parameter to specify how many different schedules to explore when running this test case (by default the checker explores a single schedule). For complex systems, running for 100,000 schedules typically finds most of the easy to find bugs before running the checker on a distributed cluster to explore billions of schedules and rule out deep bugs in the system.</p> <p>So to run the <code>tcSingleClient</code> test case for 100 schedules, we can use the following command:</p> <pre><code>p check -tc tcSingleClient -s 100\n</code></pre> Expected Output <pre><code>$ p check -tc tcSingleClient -s 100\n\n.. Searching for a P compiled file locally in the current folder\n.. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n.. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n.. Test case :: tcSingleClient\n... Checker is using 'random' strategy (seed:2510398613).\n..... Schedule #1\n..... Schedule #2\n..... Schedule #3\n..... Schedule #4\n..... Schedule #5\n..... Schedule #6\n..... Schedule #7\n..... Schedule #8\n..... Schedule #9\n..... Schedule #10\n..... Schedule #20\n..... Schedule #30\n..... Schedule #40\n..... Schedule #50\n..... Schedule #60\n..... Schedule #70\n..... Schedule #80\n..... Schedule #90\n..... Schedule #100\n... Emitting coverage reports:\n..... Writing PCheckerOutput/BugFinding/ClientServer.dgml\n..... Writing PCheckerOutput/BugFinding/ClientServer.coverage.txt\n..... Writing PCheckerOutput/BugFinding/ClientServer.sci\n... Checking statistics:\n..... Found 0 bugs.\n... Scheduling statistics:\n..... Explored 100 schedules\n..... Number of scheduling points in terminating schedules: 22 (min), 139 (avg), 585 (max).\n... Elapsed 1.4774908 sec.\n. Done\n~~ [PTool]: Thanks for using P! ~~\n</code></pre> <p>There is a known bug in the ClientServer example (explained in the Tutorials) which is caught by the <code>tcAbstractServer</code> test case. Run command: <pre><code>p check -tc tcAbstractServer -s 100\n</code></pre></p> Expected Output <pre><code>$ p check -tc tcAbstractServer -s 100\n\n.. Searching for a P compiled file locally in the current folder\n.. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n.. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n.. Test case :: tcAbstractServer\n... Checker is using 'random' strategy (seed:490949683).\n..... Schedule #1\nChecker found a bug.\n... Emitting traces:\n..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.txt\n..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.trace.json\n..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.dgml\n..... Writing PCheckerOutput/BugFinding/ClientServer_0_0.schedule\n... Elapsed 0.2264114 sec.\n... Emitting coverage reports:\n..... Writing PCheckerOutput/BugFinding/ClientServer.dgml\n..... Writing PCheckerOutput/BugFinding/ClientServer.coverage.txt\n..... Writing PCheckerOutput/BugFinding/ClientServer.sci\n... Checking statistics:\n..... Found 1 bug.\n... Scheduling statistics:\n..... Explored 1 schedule\n..... Found 100.00% buggy schedules.\n..... Number of scheduling points in terminating schedules: 97 (min), 97 (avg), 97 (max).\n... Elapsed 0.4172069 sec.\n. Done\n~~ [PTool]: Thanks for using P! ~~\n</code></pre> <p>The P checker on finding a bug generates two artifacts (highlighted in the expected output above):</p> <ol> <li>A textual trace file (e.g., <code>ClientServer_0_0.txt</code>) that has the readable error trace representing the sequence of steps from the initial state to the error state;</li> <li>A schedule file (e.g., <code>ClientServer_0_0.schedule</code>) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging (more details about debugging P error traces: here).</li> </ol>"},{"location":"manual/datatypes/","title":"P DataTypes","text":"<p>P Supports the following data types:</p> P Types Description Primitive <code>int</code>, <code>bool</code>, <code>float</code>, <code>string</code>, <code>enum</code>, <code>machine</code>, and <code>event</code>. Record <code>tuple</code> and <code>named tuple</code> Collection <code>map</code>, <code>seq</code>, and <code>set</code> Foreign These are types that are not defined in P but in an external language (e.g., C# or Java) and can be used in the P program. User Defined These are user defined types that are constructed using any of the P types listed above Universal Supertypes <code>any</code> and <code>data</code> P Types Grammar <p>Data types in P:</p> <pre><code>type :\n | bool                         # PrimitiveType\n | int                          # PrimitiveType\n | float                        # PrimitiveType\n | string                       # PrimitiveType\n | event                        # PrimitiveType\n | machine                      # PrimitiveType\n\n | (type (, type)*)             # TupleType\n | (iden: type (, iden: type)*) # NamedTupleType\n\n | seq[type]                    # SeqType\n | set[type]                    # SetType\n | map[type, type]              # MapType\n\n | data                         # UniversalType\n | any                          # UniversalType\n\n | iden                         # UserDefinedType\n ;\n</code></pre> <p>Declaring user defined types and foreign types: <pre><code>typeDecl :\n | type iden ;                  # ForeignTypeDeclaration\n | type iden = type ;           # UserDefinedTypeDeclaration\n ;\n</code></pre></p> <p>Declaring enum types:</p> <pre><code>enumTypeDecl :\n | enum iden { enumElemList }\n | enum iden { numberedEnumElemList }\n ;\nenumElemList : enumElem (, enumElem)* ;\nenumElem : iden ;\nnumberedEnumElemList : numberedEnumElem (, numberedEnumElem)* ;\nnumberedEnumElem : iden = IntLiteral ;\n</code></pre> <p>Operations on P data types</p> <p>Details for the operations that can be performed on P datatypes are described in the expressions and statements.</p>"},{"location":"manual/datatypes/#primitive","title":"Primitive","text":"<p>P supports the common primitive datatypes like <code>int</code>, <code>bool</code>, <code>float</code>, and <code>string</code>. Two additional primitive data types that are specific to the P language are <code>event</code> and <code>machine</code>. <code>event</code> type represents the set of all P events. Similarly, <code>machine</code> type represents the set of all machine references.</p> Primitive Data types <pre><code>...\nevent eRequest: bool;\n...\n\n// some function body in the P program\n{\n    var i: int;\n    var j: float;\n    var k: string;\n    var l: bool;\n    var ev: event;\n    var client: machine;\n\n    ev = eRequest;\n    client = new Client();\n    i = 10; j = 10.0; k = \"Failure!!\";\n    l = (i == (j to int));\n    assert l, k;\n\n    send client, ev, l;\n}\n</code></pre>"},{"location":"manual/datatypes/#enum","title":"Enum","text":"<p>P supports enums, enum values in P are considered as global constants and must have unique name. Enums by default are given integer values starting from 0 (if no values are assigned to the elements). Enums in P can be coerced to <code>int</code>. Please refer to the grammar above for the syntax for declaring enums.</p> Enum DeclarationEnum Declaration with Values <pre><code>enum tResponseStatus { ERROR, SUCCESS, TIMEOUT }\n\n// usage of enums\nvar status: tResponseStatus;\n\nstatus = ERROR;\n\n// you can coerce an enum to int\nassert (ERROR to int) == 0;\n</code></pre> <pre><code>enum tResponseStatus { ERROR = 500, SUCCESS = 200,\nTIMEOUT = 400; }\n\n// usage of enums\nvar status: tResponseStatus;\n\nstatus = ERROR;\n\n// you can coerce an enum to int\nassert (ERROR to int) == 500;\n</code></pre>"},{"location":"manual/datatypes/#record","title":"Record","text":"<p>P supports two types of records: tuples and named tuples. The fields of a tuple can be accessed by using the <code>.</code> operation followed by the field index.</p> <pre><code>// tuple with three fields\nvar tupleEx: (int, bool, int);\n\n// constructing a value of tuple type.\ntupleEx = (20, false, 21);\n\n// accessing the first and third element of the tupleEx\ntupleEx.0 = tupleEx.0 + tupleEx.2;\n</code></pre> <p>Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the <code>.</code> operation followed by the field name.</p> <pre><code>// named tuple with three fields\nvar namedTupleEx: (x1: int, x2: bool, x3: int);\n\n// constructing a value of named tuple type.\nnamedTupleEx = (x1 = 20, x2 = false, x3 = 21);\n\n// accessing the first and third element of the namedTupleEx\nnamedTupleEx.x1 = namedTupleEx.x1 + namedTupleEx.x3;\n</code></pre> <p>Note</p> <p>Tuple and Named tuple types are disjoint, i.e., a tuple of type <code>(int, bool, int)</code> cannot be assigned to a variable of tuple <code>(x1: int, x2: bool, x3: int)</code> though the elements of the tuple have same types (and vice versa). And similarly, a named tuple of type <code>(x1: int, x2: bool, x3: int)</code> cannot be assigned to a variable of tuple <code>(y1: int, y2: bool, y3: int)</code> they are two distinct types.</p>"},{"location":"manual/datatypes/#collection","title":"Collection","text":"<p>P supports three collection types: map, sequence (lists), and set. The operations to mutate the collection types like insert, update, and remove elements are described in the statements section. One can use the <code>while</code> loop to iterate over these collection types. Other operations like <code>sizeof</code>, <code>in</code> (to check containment), <code>choose</code> (pick a value nondeterministically), <code>keys</code>, and <code>values</code> on these collection types are defined in the expressions section.</p> <p>Syntax:</p> <ul> <li><code>map[K, V]</code> represents a <code>map</code> type with keys of type <code>K</code> and values of type <code>V</code>.</li> <li><code>seq[T]</code> represents a sequence type with elements of type <code>T</code>.</li> <li><code>set[T]</code> represents a set type with elements of type <code>T</code>.</li> </ul>"},{"location":"manual/datatypes/#foreign","title":"Foreign","text":"<p>P allows programmers to define (or implement) types in the external languages. We refer to these types as foreign types, they are declared in P but are implemented in an external language. They can be used inside P programs just like any other types.</p> <p>Syntax:: <code>type tName;</code></p> <p><code>tName</code> is the name of the foreign type.</p> <p>Note that foreign types are disjoint from all other types in P. They are subtype of the <code>any</code> type. Details about how to define/implement foreign types in P is described here.</p>"},{"location":"manual/datatypes/#user-defined","title":"User Defined","text":"<p>P supports assigning names to type i.e., creating <code>typedef</code>. Note that these typedefs are simply assigning names to P types and does not effect the sub-typing relation.</p> <p>Syntax::  <code>type iden = type ;</code></p> User Defined Type Declaration <p><pre><code>// defining a type tLookUpRequest\ntype tLookUpRequest = (client: machine, requestId: int, key: string);\n// defining a type tLookUpRequestX\ntype tLookUpRequestX = (client: machine, requestId: int, key: string);\n</code></pre> The programmers can use type <code>tLookUpRequest</code> as a short hand for referring to the type <code>(client: machine, requestId: int, key: string)</code> Note that the types <code>tLookUpRequest</code> and <code>tLookUpRequestX</code> are same, the compiler does not distinguish between the two types.</p>"},{"location":"manual/datatypes/#universal-supertypes","title":"Universal Supertypes","text":"<p>P supports two universal supertypes (<code>any</code> and <code>data</code>), type that are supertypes of all types in the language.</p> <ul> <li><code>any</code> type in P is the supertype of all types. Also, note that in P, <code>seq[any]</code> is a super type of <code>seq[int]</code> and similarly for other collection types.</li> <li><code>data</code> type in P is the supertype of all types in P that do not have a <code>machine</code> type   embedded in it. This type is mainly used to represent values in P that do not have a   machine reference embedded in them i.e., the value is purely \"data\" and has no machine   \"references\" in it. For example, <code>data</code> is a supertype of <code>(key: string, value: int)</code>   but not <code>(key: string, client: machine)</code>.</li> </ul>"},{"location":"manual/datatypes/#default-values-for-p-data-types","title":"Default values for P data types","text":"<p>The <code>default</code> feature in P (checkout details in expressions) can be used to obtain the default value of any P type. P variables on declaration are automatically initialized to their default values.</p> <code>default</code> values of P types <p>P variables on declaration are automatically initialized to their default values. For example:</p> <pre><code>var s : set[int];\n// by default a set type is initialized to an empty set\nassert sizeof(s) == 0;\n\ns += (100);\nassert sizeof(s) == 1;\n\n// reset the variable to an empty set\ns = default(set[int]);\n</code></pre> <p>Similarly,</p> <pre><code>type tRequest = (client: machine, requestId: int);\ntype tResponse = (values: map[int, int]);\n\n...\n// initializes x to (client = null, requestId = 0);\nx = default(tRequest);\n// initializes y to (values = {}), empty map.\ny = default(tResponse);\n\nassert x.client == default(machine);\nassert sizeof(y.values) == 0;\n</code></pre> P Types Default Value int 0 float 0.0 bool false string \"\" event null machine null enum Element of the enum with lowest (int) value Record (tuple or named tuple) Each field in the record type is initialized to its default value. Collection (set, seq, and map) Empty collection Foreign null <code>any</code> and <code>data</code> null"},{"location":"manual/events/","title":"P Events","text":"<p>A P program is a collection of state machines communicating with each other by exchanging events. An event in P has two parts: an event name and a payload value (optional) that can be sent along with the event.</p> P Event Declaration Grammar <pre><code>eventDecl :\n    | event iden (: type)?;     # P Event Declaration\n</code></pre> <p><code>iden</code> is the name of the event and <code>type</code> is any P data type (described here).</p> <p>Syntax: <code>event eName;</code> or <code>event eName : payloadType;</code></p> <p><code>eName</code> is the name of the P event and <code>payloadType</code> is the type of payload values that can be sent along with this event.</p> Event Declarations <pre><code>// declarations of events with no payloads\nevent ePing;\nevent ePong;\n\n// declaration of events that have payloads\ntype tRequest = (client: Client, key: string, value: int, requestId: int);\n// eRequest event with payload of type tRequest\nevent eRequest: tRequest;\n// eResponse event that can have a payload of type (requestId: int, status: bool)\nevent eResponse: (requestId: int, status: bool);\n</code></pre>"},{"location":"manual/expressions/","title":"P Expressions","text":"<p>A Function in P can be arbitrary piece of imperative code which enables programmers to capture complex protocol logic in their state machines. P supports the common imperative programming language expressions (just like in Java).</p> P Expressions Grammar <pre><code>    expr :\n    | (expr)                        # ParenExpr\n    | primitiveExpr                 # PrimitiveExpr\n    | formatedString                # FormatStringExpr\n    | (tupleBody)                   # TupleExpr\n    | (namedTupleBody)              # NamedTupleExpr\n    | expr.int                      # TupleAccessExpr\n    | expr.iden                     # NamedTupleAccessExpr\n    | expr[expr]                    # AccessExpr\n    | keys(expr)                    # KeysExpr\n    | values(expr)                  # ValuesExpr\n    | sizeof(expr)                  # SizeofExpr\n    | expr in expr                  # ContainsExpr\n    | default(type)                 # DefaultExpr\n    | new iden ( rvalueList? )      # NewExpr\n    | iden ( rvalueList? )          # FunCallExpr\n    | (- | !) expr                  # UnaryExpr\n    | expr (* | / | + | -) expr     # ArithBinExpr\n    | expr (== | !=) expr           # EqualityBinExpr\n    | expr (&amp;&amp; | ||) expr           # LogicalBinExpr\n    | expr (&lt; | &gt; | &gt;= | &lt;= ) expr  # CompBinExpr\n    | expr as type                  # CastExpr\n    | expr to type                  # CoerceExpr\n    | choose ( expr? )              # ChooseExpr\n    ;\n\n    # Formated strings for creating strings\n    formatedString\n    | format ( StringLiteral (, rvalueList)? )\n    ;\n\n    primitiveExpr\n    : iden                          # Identifier\n    | FloatLiteral                  # FloatConstant\n    | BoolLiteral                   # BooleanConstant\n    | IntLiteral                    # IntConstant\n    | NullLiteral                   # Null\n    | StringLiteral                 # StringConstant\n    | $                             # BooleanNonDeterministicChoice\n    | halt                          # HaltEvent\n    | this                          # SelfMachineReference\n    ;\n\n    # Body of a tuple\n    tupleBody :\n    | rvalue ,\n    | rvalue (, rvalue)+\n    ;\n\n    # Body of a named tuple\n    namedTupleBody:\n    | iden = rvalue ,\n    | iden = rvalue (, iden = rvalue)+\n    ;\n\n    # r-value is an expression that can\u2019t have a value assigned to it which\n    # means r-value can appear on right but not on left hand side of an assignment operator(=)\n    rvalue : expr ;\n    # rvalueList is a comma separated list of rvalue.\n</code></pre>"},{"location":"manual/expressions/#primitives","title":"Primitives","text":"<p>P allows the common primitive expressions like literal-constants for integers, floats, strings, booleans, and the null value. There are three unique primitive expressions in P:</p>"},{"location":"manual/expressions/#_1","title":"$","text":"<p><code>$</code> represents a nondeterministic boolean choice. It is a short hand for <code>choose()</code> which randomly returns a boolean value and the P Checker explores the behavior of the system for both the possibilities i.e., both when <code>$</code> evaluates to <code>true</code> or <code>false</code>.</p>"},{"location":"manual/expressions/#halt","title":"Halt","text":"<p><code>halt</code> is a special event in P used for destroying an instance of a P machine. The semantics of an <code>halt</code> event is that whenever a P machine throws an <code>unhandled event</code> exception because of a <code>halt</code> event then the machine is automatically destroyed or halted and all events sent to that machine instance there after are equivalent to being dropped to ether. There are two ways of using the <code>halt</code> event: (1) self-halt by doing <code>raise halt;</code> raising a <code>halt</code> event which is not handled in the state machine will lead to that machine being halted or (2) by sending the <code>halt</code> event to a machine, and that machine on dequeueing <code>halt</code>, would halt itself. Please checkout the FailureDetector example in tutorials to know more about halt event</p>"},{"location":"manual/expressions/#this","title":"This","text":"<p><code>this</code> represents the <code>self</code> machine reference of the current machine. It can be used to send self reference to other machines in the program so that they can send messages to this machine.</p>"},{"location":"manual/expressions/#formatted-string","title":"Formatted String","text":"<p>P allows creating formatted strings.</p> <p>Syntax:: <code>format ( formatString (, rvalueList)? )</code></p> <p><code>formatString</code> is the format string and <code>rvalueList</code> is a comma separated list of arguments for the formatted string.</p> Formatted StringPrint Formatted String <pre><code>var hw, h, w: string;\nvar tup: (string, int);\n\nh = \"Hello\"; w = \"World\";\ntup = (\"tup value\", 100);\nhw = format(\"{0} {1}, and {2} is {3}!\",\n        h, w, tup.0, tup.1);\n// hw value is \"Hello World, and tup value is 100!\"\n</code></pre> <p>Formatted strings are most useful for printing logs. Checkout <code>print</code> statement.</p> <pre><code>var hw, h, w: string;\nvar tup: (string, int);\n\nh = \"Hello\"; w = \"World\";\ntup = (\"tup value\", 100);\nprint format(\"{0} {1}, and {2} is {3}!\",\n        h, w, tup.0, tup.1);\n// prints \"Hello World, and tup value is 100!\"\n</code></pre>"},{"location":"manual/expressions/#tuple-and-named-tuple-values","title":"Tuple and Named Tuple Values","text":"<p>A tuple or named tuple value can be created using the following expressions:</p> <p>Syntax (tuple value):: <code>(rvalue ,)</code> for a single field tuple value or <code>(rvalue (, rvalue)+)</code> for tuple with multiple fields.</p> <pre><code>// tuple value of type (int,)\n(10,)\n// tuple value of type (string, (string, string))\n(\"Hello\", (\"World\", \"!\"))\n// assume x: int and y: string\n// tuple value of type (int, string)\n(x, y)\n</code></pre> <p>Syntax (named tuple value):: <code>(iden = rvalue ,)</code> for a single field named tuple value or <code>(iden = rvalue (, iden = rvalue)+)</code> for named tuple with multiple fields.</p> <pre><code>// named tuple value of type (reqId: int,)\n(reqId = 10,)\n// named tuple value of type (h: string, (w: string, a: string))\n(h = \"Hello\", (w = \"World\", a = \"!\"))\n// assume x: int and y: string\n// named tuple value of type (a:int, b:string)\n(a = x, b = y)\n</code></pre>"},{"location":"manual/expressions/#access-field-of-tuple-and-named-tuple","title":"Access Field of Tuple and Named Tuple","text":"<p>The fields of a tuple can be accessed by using the <code>.</code> operation followed by the field index.</p> <p>Syntax (tuple value): <code>expr.int</code> where <code>expr</code> is the tuple value and <code>int</code> is the field index.</p> <pre><code>// tuple with three fields\nvar tupleEx: (int, bool, int);\ntupleEx = (20, false, 21);\n\n// accessing the first and third element of the tupleEx\ntupleEx.0 = tupleEx.0 + tupleEx.2;\n</code></pre> <p>Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the <code>.</code> operation followed by the field name.</p> <p>Syntax (named tuple value): <code>expr.iden</code> where <code>expr</code> is the named tuple value and <code>iden</code> is the field name.</p> <pre><code>// named tuple with three fields\nvar namedTupleEx: (x1: int, x2: bool, x3: int);\nnamedTupleEx = (x1 = 20, x2 = false, x3 = 21);\n\n// accessing the first and third element of the namedTupleEx\nnamedTupleEx.x1 = namedTupleEx.x1 + namedTupleEx.x3;\n</code></pre>"},{"location":"manual/expressions/#indexing-into-a-collection","title":"Indexing into a Collection","text":"<p>P supports three collection types: <code>map</code>, <code>seq</code>, and <code>set</code>. We can index into these collection types to access its elements.</p> <p>Syntax: <code>expr_c[expr_i]</code></p> <p>If <code>expr_c</code> is a value of sequence type then <code>expr_i</code> must be an integer expression and <code>expr_c[expr_i]</code> represents the element at index <code>expr_i</code>. Similarly, If <code>expr_c</code> is a value of set type then <code>expr_i</code> must be an integer expression and <code>expr_c[expr_i]</code> represents the element at index <code>expr_i</code> but note that for a set there is no guarantee for the order in which elements are stored in the set. Finally, if <code>expr_c</code> is a value of map type then <code>expr_i</code> represents the key to look up and <code>expr_c[expr_i]</code> represents the value for the key <code>expr_i</code>.</p>"},{"location":"manual/expressions/#operations-on-collections","title":"Operations on Collections","text":"<p>P supports four other operations on collection types:</p>"},{"location":"manual/expressions/#sizeof","title":"sizeof","text":"<p>Syntax:: <code>sizeof(expr)</code>, where <code>expr</code> is a value of type <code>set</code>, <code>seq</code> or <code>map</code>, returns an integer value representing the size or length of the collection.</p> <pre><code>var sq: seq[int];\nwhile (i &lt; sizeof(sq)) {\n    ...\n    i = i + 1;\n}\n</code></pre>"},{"location":"manual/expressions/#keys-and-values","title":"keys and values","text":"<p>Programmers can use <code>keys</code> and <code>values</code> functions to get access to a sequence of all the keys or values in map respectively.</p> <p>Syntax:: <code>keys(expr)</code> or <code>values(expr)</code></p> <p><code>expr</code> must be a map value, if <code>expr : map[K, V]</code> then <code>keys(expr)</code> returns a sequence of all keys in the map (of type <code>seq[K]</code>) and similarly, <code>values(expr)</code> returns a sequence of all values in the map (of type <code>seq[V]</code>).</p> <p>Primarily, <code>keys</code> and <code>values</code> are used to get contents of the map and then operate over it.</p>"},{"location":"manual/expressions/#contains-or-in","title":"contains (or <code>in</code>)","text":"<p>To check if an element (or key in the case of a map) belongs to a collection, P provides the <code>in</code> operation.</p> <p>Syntax: <code>expr_e in expr_c</code></p> <p><code>expr_e</code> is the element (or key in the case of map) and <code>expr_c</code> is the collection value. The <code>in</code> expression evaluates to <code>true</code> if the element belongs to the collection and <code>false</code> otherwise.</p> <pre><code>var sq: seq[tRequest];\nvar mp: map[int, tRequest];\nvar rr: tRequest; var i: int;\n...\nif(rr in sq &amp;&amp; rr in values(mp) &amp;&amp; i in mp) { ... }\n</code></pre>"},{"location":"manual/expressions/#default-value-for-a-type","title":"Default value for a type","text":"<p>The <code>default</code> primitive in P can be used to obtain the default value for any type.</p> <p>Syntax: <code>default(type)</code></p> <p><code>type</code> is any P type and <code>default(type)</code> represents the default value for the <code>type</code>. The default values for all P types is provided here.</p>"},{"location":"manual/expressions/#new","title":"New","text":"<p>New expression is used to create an instance of a machine, <code>new</code> returns a machine reference to the newly created instance of the machine.</p> <p>Syntax: <code>new iden (rvalue?) ;</code></p> <p><code>iden</code> is the name of the machine to be created and <code>rvalue</code> is the optional constructor parameter that becomes the input parameter of the entry function of the start state of the machine.</p> Create a machine <p><pre><code>new Client((id = 1, server = this));\n</code></pre> Creates a dynamic instance of a Client machine and passes the constructor parameter <code>(id = 1, server = this)</code> which is delivered as a payload to the entry function of the start state of the created Client machine.</p>"},{"location":"manual/expressions/#function-call","title":"Function Call","text":"<p>Function calls in P are similar to any other imperative programming languages.</p> <p>Note that the parameters passed to the functions and the return values are pass-by-value!</p> <p>Syntax: <code>iden ( rvalueList? ) ;</code></p> <p><code>iden</code> is the name of the function and <code>rvalueList</code> is the comma separated list of function arguments.</p> Function call <pre><code>x = Foo();\ny = Bar(10, \"haha\");\n</code></pre>"},{"location":"manual/expressions/#negation-and-not","title":"Negation and Not","text":"<p>P supports two unary operations: <code>-</code> on integers and floats values (i.e., negation) and <code>!</code> on boolean values (i.e., logical not).</p>"},{"location":"manual/expressions/#arithmetic","title":"Arithmetic","text":"<p>P supports the following arithmetic binary operations on integers or floats: <code>+</code> (i.e., addition), <code>-</code> (i.e., subtraction), <code>*</code> (i.e., multiplication), <code>%</code> (i.e., modulo), and <code>/</code> (i.e., division).</p>"},{"location":"manual/expressions/#comparison","title":"Comparison","text":"<p>P supports the following comparison binary operations on integers or floats: <code>&lt;</code> (i.e., less-than), <code>&lt;=</code> (i.e., less-than-equal), <code>&gt;</code> (i.e., greater-than), and <code>&gt;=</code> (i.e., greater-than-equal).</p>"},{"location":"manual/expressions/#cast","title":"Cast","text":"<p>P supports two super types <code>any</code> and <code>data</code> (more details). To cast values from these supertypes to the actual types, P supports the <code>as</code> cast expression.</p> <p>Syntax: <code>expr as T</code></p> <p><code>expr</code> expression is cast to type <code>T</code> and if the cast is not valid then it leads to dynamic type-cast error.</p> <pre><code>type tRecord = (key: int, val: any);\n...\nvar st: set[tRecord];\nvar x: any;\nvar x_i: string;\nvar st_i: set[(key: int, val: string)];\n\nx_i = x as string;\nst += ((key = 1, val = \"hello\"));\nst_i = st as set[(key: int, val: string)];\n...\n</code></pre>"},{"location":"manual/expressions/#coerce","title":"Coerce","text":"<p>P supports coercing of any value of type <code>float</code> to <code>int</code> and also any <code>enum</code> element to <code>int</code>.</p> <p>Syntax: <code>expr to T</code></p> <p><code>expr</code> expression is coerced to type <code>T</code>. We currently support only coercing of type <code>float</code> to <code>int</code> and also any <code>enum</code> element to <code>int</code>.</p> <pre><code>enum Status {\n    ERROR = 101,\n    SUCCESS = 102\n}\n...\nvar x_f : float;\nvar x_i: int;\n\nx_f = 101.0;\nx_i = x_f to int;\nassert x_i == ERROR to int;\n</code></pre>"},{"location":"manual/expressions/#choose","title":"Choose","text":"<p>P provides the <code>choose</code> primitive to model data nondeterminism in P programs. The P checker then explores the behavior of the program for all possible values that can be returned by the <code>choose</code> operation.</p> <p>Syntax: <code>choose()</code> or <code>choose(expr)</code></p> <p><code>expr</code> can either be a <code>int</code> value or a collection. For <code>choose(x)</code>, when <code>x</code> is an integer, <code>choose(x)</code> returns a random value between <code>0 to x</code> (excluding x), when <code>x</code> is a collection then <code>choose(x)</code> returns a random element from the collection.</p> <pre><code>choose() // returns true or false, is equivalent to $\nchoose(10) // returns an integer x, 0 &lt;= x &lt; 10\nchoose(x) // if x is set or seq then returns a value from that collection\n</code></pre> <p>The choose operation can be used to model nondeterministic environment machines that generate random inputs for the system. Another use case could be to model nondeterministic behavior within the system itself where the system can randomly choose to <code>timeout</code> or <code>fail</code> or <code>drop messages</code>.</p> <p>Performing a <code>choose</code> over an empty collection leads to an error. Also, <code>choose</code> from a <code>map</code> value returns a random key from the map.</p> <p>Note that the maximum number of choices allowed in a <code>choose(expr)</code> is 10,000. Performing a <code>choose</code> with an <code>int</code> value greater than 10000 or over a collection with more than 10000 elements leads to an error.</p> <pre><code>choose(10001) // throws a compile-time error\nchoose(x)     // throws a runtime error if x is of integer type and has value greater than 10000\nchoose(x)     // throws a runtime error if x is of seq/set/map type and has size greater than 10000 elements\n</code></pre>"},{"location":"manual/foriegntypesfunctions/","title":"P Foreign Interface","text":"<p>Foreign Types</p> <p>Foreign types in P are types that are declared in P but defined or implemented in the foreign language (foreign type).</p> <p>Foreign Functions</p> <p>Foreign functions in P are local or global functions that are declared in P but defined or implemented in the foreign language (foreign functions).</p> <p>Recommendation: Using Foreign Types and Functions</p> <p>Programmers can consider implementing a particular type as Foreign type in P if it's a complicated data structure and implementing them using P types is either not possible or too cumbersome. For example, P does not support declaring recursive data types, and hence, implementing a linked-list or a tree like data-structure in P is hard. Hence, we recommend programmers to implement such types as foreign types.</p> <p>When modeling complex systems, many times programmers need to implement complicated logic/functions that manipulate or iterate over data-structures. Such functions can be easily implemented in foreign languages like Java and C# as compared to P. For example, sorting a list is easier in Java and C# through standard library functions and verbose in P. Also, functions that manipulate foreign types are implemented as foreign functions.</p> <p>The Two Phase Commit example had introduced the foreign function feature. We will now use a simple PriorityQueue example to go into the details of foreign interface in P.</p>"},{"location":"manual/foriegntypesfunctions/#priorityqueue","title":"PriorityQueue","text":"<p>The PriorityQueue project presents an example where a <code>Client</code> uses a priority queue implemented as foreign types and functions.</p>"},{"location":"manual/foriegntypesfunctions/#p-source","title":"P Source","text":"<p>The PriorityQueue.p file declares (1) a foreign type <code>tPriorityQueue</code> and uses (2) global foreign functions to operate or interact with the priority queue.</p> <p>P has Value Semantics (no Pass by Reference!!)</p> <p>Note that P does not support pass by references, everything in P is always pass by value. Hence, the functions above must return a priority queue after adding the element into the queue (mutated queue).</p>"},{"location":"manual/foriegntypesfunctions/#p-test","title":"P Test","text":"<p>The Client.p file presents a <code>Client</code> state machine that uses the priority queue and performs operations on it by calling the foreign function. The <code>Client</code> machine also declares a local foreign function to add an element into the queue.</p>"},{"location":"manual/foriegntypesfunctions/#p-foreign-code","title":"P Foreign Code","text":"<p>The implementation of the <code>tPriorityQueue</code> is available in PriorityQueue.cs</p> <p>If you want to pretty print the foreign type value, you can also override the ToString() function in their implementation.</p> <p>The implementation of the global functions in PriorityQueue.p is available in PriorityQueueFunctions.cs. Finally, the implementation of the local function in the Client machine is available in ClientFunctions.cs.</p>"},{"location":"manual/foriegntypesfunctions/#compiling-priorityqueue","title":"Compiling PriorityQueue","text":"<p>Navigate to the PriorityQueue folder and run the following command to compile the PriorityQueue project:</p> <pre><code>p compile\n</code></pre> Expected Output <pre><code>$ p compile\n\n.. Searching for a P project file *.pproj locally in the current folder\n.. Found P project file: P/Tutorial/PriorityQueue/PriorityQueue.pproj\n----------------------------------------\n==== Loading project file: P/Tutorial/PriorityQueue/PriorityQueue.pproj\n....... includes p file: P/Tutorial/PriorityQueue/PSrc/PriorityQueue.p\n....... includes p file: P/Tutorial/PriorityQueue/PTst/Client.p\n....... includes p file: P/Tutorial/PriorityQueue/PTst/TestScripts.p\n....... includes foreign file: P/Tutorial/PriorityQueue/PForeign/PriorityQueue.cs\n....... includes foreign file: P/Tutorial/PriorityQueue/PForeign/PriorityQueueFunctions.cs\n....... includes foreign file: P/Tutorial/PriorityQueue/PForeign/ClientFunctions.cs\n----------------------------------------\n----------------------------------------\nParsing ...\nType checking ...\nCode generation ...\nGenerated PriorityQueue.cs.\n----------------------------------------\nCompiling PriorityQueue...\nMSBuild version 17.3.1+2badb37d1 for .NET\nDetermining projects to restore...\nRestored P/Tutorial/PriorityQueue/PGenerated/CSharp/PriorityQueue.csproj (in 392 ms).\nPriorityQueue -&gt; P/Tutorial/PriorityQueue/PGenerated/CSharp/net6.0/PriorityQueue.dll\n\nBuild succeeded.\n0 Warning(s)\n0 Error(s)\n\nTime Elapsed 00:00:04.08\n\n\n----------------------------------------\n[PTool]: Thanks for using P!\n</code></pre>"},{"location":"manual/foriegntypesfunctions/#checking-priorityqueue","title":"Checking PriorityQueue","text":"<p>Run the following command to run the test case <code>tcCheckPriorityQueue</code> in verbose mode:</p> <pre><code>p check -v\n</code></pre> Expected Output <pre><code>$ p check -v\n\n.. Searching for a P compiled file locally in the current folder\n.. Found a P compiled file: P/Tutorial/PriorityQueue/PGenerated/CSharp/net6.0/PriorityQueue.dll\n.. Checking P/Tutorial/PriorityQueue/PGenerated/CSharp/net6.0/PriorityQueue.dll\n.. Test case :: tcCheckPriorityQueue\n... Checker is using 'random' strategy (seed:1636311106).\n..... Schedule #1\n&lt;TestLog&gt; Running test 'tcCheckPriorityQueue'.\n&lt;CreateLog&gt; Plang.CSharpRuntime._GodMachine(1) was created by task '2'.\n&lt;CreateLog&gt; PImplementation.Client(2) was created by Plang.CSharpRuntime._GodMachine(1).\n&lt;StateLog&gt; PImplementation.Client(2) enters state 'Init'.\n&lt;PrintLog&gt; Creating Priority Queue!\n&lt;PrintLog&gt; Adding Element in the Priority Queue!\n&lt;PrintLog&gt; Adding Element in the Priority Queue!\n&lt;PrintLog&gt; Adding Element in the Priority Queue!\n&lt;PrintLog&gt; Choosing element at location: 1\n&lt;PrintLog&gt; --------------\n&lt;PrintLog&gt; Hello\n&lt;PrintLog&gt; World\n&lt;PrintLog&gt; !!\n&lt;PrintLog&gt; 123\n&lt;PrintLog&gt; --------------\n... ### Process 0 is terminating\n... Emitting coverage reports:\n..... Writing PCheckerOutput/BugFinding/PriorityQueue.dgml\n..... Writing PCheckerOutput/BugFinding/PriorityQueue.coverage.txt\n..... Writing PCheckerOutput/BugFinding/PriorityQueue.sci\n... Checking statistics:\n..... Found 0 bugs.\n... Scheduling statistics:\n..... Explored 1 schedule: 1 fair and 0 unfair.\n..... Number of scheduling points in fair terminating schedules: 5 (min), 5 (avg), 5 (max).\n... Elapsed 0.3070145 sec.\n. Done\n[PTool]: Thanks for using P!\n</code></pre> <p>Hope you exploit the P Foreign interface to implement and check complex systems. If you have any questions, please feel free to post them in the discussions or issues.</p>"},{"location":"manual/functions/","title":"P Functions","text":"<p>There are two types of functions in P: (1) anonymous functions, and (2) named functions.</p> <ul> <li>Anonymous functions are unnamed functions that can appear as an entry functions or exit functions or as event-handlers.</li> <li>Named functions can either be declared inside a state machine or globally as a top-level declaration. The named functions declared within a state machine are local to that machine and hence can access the local-variables of the machine. Global named functions are shared across state machines. Note that the purpose of having named functions is to enable code reuse. Named functions can be also be used as entry/exit functions and also as event handlers.</li> </ul> <p>Please look at P state machine for more details about the declaration of these functions.</p> P Functions Grammar <pre><code>  anonFunction : (funParam?) functionBody                         # AnonymousFunDecl\n\n  funDecl :\n    | fun name (funParamList?) (: returnType)? ;                  # ForeignFunDecl\n    | fun name (funParamList?) (: returnType)? functionBody       # FunDecl\n    ;\n\n  functionBody : { varDecl* statement* }                          # FunctionBody\n\n  varDecl : var iden : type; ;                                    # VariableDecl\n\n  funParamList : funParam (, funParam)* ;                         # FunParameterList\n  funParam : iden : type                                          # FunParameter\n</code></pre>"},{"location":"manual/functions/#anonymous-functions","title":"Anonymous Functions","text":"<p>Anonymous functions are unnamed functions that appear as entry or exit or event-handler functions.</p> <p>Syntax: <code>(funParam?) functionBody</code></p> <p><code>funParam</code> is the optional single parameter allowed with the annonymous functions. To know more about the places annonymous functions can be used, please checkout the grammar of p state machines and receive statements.</p>"},{"location":"manual/functions/#named-functions","title":"Named Functions","text":"<p>Named functions in P can be declared within P state machines as local functions that can access the local variables of the state machine. Named functions that are declared as top-level declarations are global functions that can be used across state machines.</p> <p>Check out the grammar of P state machines for local functions declarations and top-level declarations grammar for the global function declarations.</p> <p>Example of a local functions: here and an example of a global function that is shared across all machines: here</p> <p>Syntax: <code>fun name (funParamList?) (: returnType)? functionBody</code></p> <p><code>name</code> is the name of the named function, <code>funParamList</code> is the optional function parameters, and <code>returnType</code> is the optional return type of the function.</p>"},{"location":"manual/functions/#foreign-functions","title":"Foreign Functions","text":"<p>P named function declarations without any function body are referred to as foreign functions. Foreign functions are functions that are declared in P and can be used in the P program just like any other function but the implementation of these functions is provided in the foreign language.</p> <p>Syntax: <code>fun name (funParamList?) (: returnType)? ;</code></p> <p><code>name</code> is the name of the named function, <code>funParamList</code> is the optional function parameters, and <code>returnType</code> is the optional return type of the function.</p> <p>To know more about the foreign interface and functions, please look at the PriorityQueue example.</p>"},{"location":"manual/functions/#function-body","title":"Function Body","text":"<p>Function body in P is similar to other programming languages with a restriction that P function-local variables uses C style local variable declarations. Declaration of local variables in a function must come before any other statement in the function body. So, the body of a function in P is a sequence of variable declarations followed by a sequence of statements.</p> <pre><code>functionBody : { varDecl* statement* }\n</code></pre>"},{"location":"manual/modulesystem/","title":"P Module System","text":"<p>The P module system allows programmers to decompose their complex system into modules to implement and test the system compositionally. More details about the underlying theory for the P module system (assume-guarantee style compositional reasoning) is described in the paper</p> <p>In its simplest form, a module in P is a collection of state machines. The P module system allows constructing larger modules by composing or unioning modules together. Hence, a distributed system under test which is a composition of multiple components can be constructed by composing (or unioning) modules corresponding to those components. The P test cases takes as input a module that represents the closed<sup>1</sup> system to be validated which in turn is the union or composition of all the component modules.</p> P Modules Grammar <pre><code>modExpr :\n| ( modExpr )                               # AnnonymousModuleExpr\n| { bindExpr (, bindExpr)* }                # PrimitiveModuleExpr\n| union modExpr (, modExpr)+                # UnionModuleExpr\n| assert idenList in modExpr                # AssertModuleExpr\n| iden                                      # NamedModule\n;\n\n# Bind a machine to an interface\n\nbindExpr : (iden | iden -&gt; iden) ;          # MachineBindExpr\n\n# Create a named module i.e., assign a name to a module\n\nnamedModuleDecl : module iden = modExpr ;   # Named module declaration\n</code></pre>"},{"location":"manual/modulesystem/#named-module","title":"Named Module","text":"<p>A named module declaration simply assigns a name to a module expression.</p> <p>Syntax: <code>module mName = modExpr;</code></p> <p><code>mName</code> is the assiged name for the module <code>modExpr</code> where <code>modExpr</code> is any of the modules described below.</p> Named Module <p><code>module serverModule = { Server, Timer };</code></p> <p>The above line assigns the name <code>serverModule</code> to a primitive module consisting of machines <code>Server</code> and <code>Timer</code>.</p>"},{"location":"manual/modulesystem/#primitive-module","title":"Primitive Module","text":"<p>A primitive module is a (annonymous) collection of state machines.</p> <p>Syntax: <code>{ bindExpr (, bindExpr)* }</code></p> <p>where <code>bindExpr</code> is a binding expression which could either be just the name of a machine <code>iden</code> or a mapping <code>mName -&gt; replaceName</code> that maps a machine <code>mName</code> to a machine name <code>replaceName</code> that we want to replace. The binding enforces that whenever a machine <code>replaceName</code> is created in the module (i.e., <code>new replaceName(..)</code>) it leads to the creation of machine <code>mName</code>. The indirection using this binding is helpful in cases where we would like to replace a machine with another machine (e.g., implementation by its abstraction). This usecase is explained in the ClientServer example.</p> <p>In most cases, a primitive module is simply a list of state machines that together implement that component.</p> Primitive ModulePrimitive Module with Bindings <p><pre><code>// Lets say there are three machines in the P program: Client, Server, and Timer\nmodule client = { Client };\nmodule server = { Server, Timer };\n</code></pre> <code>client</code> is a primitive module consisting of the <code>Client</code> machine and the <code>server</code> module is a primitive module consistency of machines <code>Server</code> and <code>Timer</code>.</p> <p><pre><code>// Lets say there are four machines in the P program: Client, Server, AbstractServer and Timer\nmodule client = { Client };\nmodule server = { Server, Timer };\nmodule serverAbs = {AbstractServer -&gt; Server, Timer};\n</code></pre> <code>client</code> is a primitive module consisting of the <code>Client</code> machine and the <code>server</code> module is a primitive module consisting of machines <code>Server</code> and <code>Timer</code>. The module <code>serverAbs</code> represents a primitive module consisting of machines <code>AbstractServer</code> and <code>Timer</code> machines with the difference that wherever the <code>serverAbs</code> module is used the creation of machine <code>Server</code> will in turn lead to creation of the <code>AbstractServer</code> machine.</p>"},{"location":"manual/modulesystem/#union-module","title":"Union Module","text":"<p>P supports unioning multiple modules together to create larger, more complex modules. The idea is to implement the distributed system as a collection of components (modules), test and verify these components in isolation using the abstractions of other components, and also potentially union them together to validate the entire system together as well.</p> <p>Syntax:: <code>union modExpr (, modExpr)+</code></p> <p><code>modExpr</code> is any P module. The union of two modules is simply a creation of a new module which is a union of the machines of the component modules.</p> <p><code>module system = (union client, server);</code></p> <p><code>system</code> is a module which is a union of the modules <code>client</code> and <code>server</code>.</p> <p><code>module systemAbs = (union client, serverAbs);</code></p> <p><code>systemAbs</code> is a module which is a union of the module <code>client</code> and the <code>serverAbs</code> where the <code>Client</code> machine interacts with the <code>AbstractServer</code> machine instead of the <code>Server</code> machine in the <code>system</code> module.</p>"},{"location":"manual/modulesystem/#assert-monitors-module","title":"Assert Monitors Module","text":"<p>P allows attaching monitors (or specifications) to modules. When attaching monitors to a module, the events observed by the monitors must be sent by <code>some</code> machine in the module.</p> <p>The way to think about assert monitors module is that: `attaching these monitors to the module asserts (during P checker exploration) that each execution of the module satisfies the global properties specified by the monitors._</p> <p>Syntax: <code>assert idenList in modExpr</code></p> <p><code>idenList</code> is a comma separated list of monitor (spec machine) names that are being asserted on the executions of the module <code>modExpr</code>.</p> <p><code>assert AtomicitySpec, EventualResponse in TwoPhaseCommit</code></p> <p>The above module asserts that the executions of the module <code>TwoPhaseCommit</code> satisfy the properties specified by the monitors <code>AtomicitySpec</code> and <code>EventualResponse</code>.</p> <p>More module constructors</p> <p>P supports more complex module constructors like <code>compose</code>, <code>hide</code>, and <code>rename</code>. The description for these will be added later, they are mostly used for more advanced compositional reasoning.</p> <ol> <li> <p>A closed system is a system where all the machines or interfaces that are created are defined or implemented in the unioned modules.\u00a0\u21a9</p> </li> </ol>"},{"location":"manual/monitors/","title":"P Monitors","text":"<p>Programmers can write safety and liveness specifications in P as monitors or <code>spec</code> machines. <code>spec</code> machines are monitor state machines or observer state machines that observe a set of events during the execution of the system and assert the desired correctness specifications based on these observations.</p> <p>Machines vs Spec Machine</p> <p>Syntactically, machines and spec machines in P are very similar in terms of the state machine structure. But, they have some key differences:</p> <ul> <li><code>spec</code> machines in P are observer machines (imagine runtime monitors), they observe a set of events in the execution of the system and based on these observed events (may keep track on local state) assert the desired global safety and liveness specifications.</li> <li>Since <code>spec</code> machines are observer machines, they cannot have any side effects on the system behavior and hence, <code>spec</code> machines cannot perform <code>send</code>, <code>receive</code>, <code>new</code>, and <code>annouce</code>.</li> <li><code>spec</code> machines are global machines, in other words, there is only a single instance of each monitor created at the start of the execution of the system. We currently do not support dynamic creation of monitors. Hence, <code>spec</code> machines cannot use <code>this</code> expression.</li> <li><code>spec</code> machines are synchronously composed with the system that it is monitored. The way this is achieved is: each time there is a <code>send</code> or <code>announce</code> of an event during the execution of a system, all the monitors or specifications that are observing that event are executed synchronously at that point. Another way to imagine this is: just before <code>send</code> or <code>annouce</code> of an event, we deliver this event to all the monitors that are observing the event and synchronously execute the monitor at that point.</li> <li>Finally, <code>spec</code> machines can have <code>hot</code> and <code>cold</code> annotations on their states to model liveness specifications.</li> </ul> P Spec Machine Grammar <p><code>specMachineDecl : spec iden observes eventsList statemachineBody ;</code></p> <p>As mentioned above, syntactically, the P <code>spec</code> machines are very similar to the P state machines. The main difference being the <code>observes</code> annotation that specifies the list of events being observed (monitored) and also the <code>hot</code> and <code>cold</code> annotations on the states of a liveness specification.</p> <p>Syntax: <code>spec iden observes eventsList statemachineBody ;</code></p> <p><code>iden</code> is the name of the spec machine, <code>eventsList</code> is the comma separated list of events observed by the spec machine and the <code>statemachineBody</code> is the implementation of the specification and its grammar is similar to the P state machine.</p>"},{"location":"manual/monitors/#safety-specification","title":"Safety specification","text":"<pre><code>/*******************************************************************\nReqIdsAreMonotonicallyIncreasing observes the eRequest event and\nchecks that the payload (Id) associated with the requests sent\nby all concurrent clients in the system is always globally\nmonotonically increasing by 1\n*******************************************************************/\nspec ReqIdsAreMonotonicallyIncreasing observes eRequest {\n    // keep track of the Id in the previous request\n    var previousId : int;\n    start state Init {\n        on eRequest do (req: tRequest) {\n            assert req.rId &gt; previousId,\n            format (\"Request Ids not monotonically increasing, got {0},\n            previously seen Id was {1}\", req.rId, previousId);\n            previousId = req.rId;\n        }\n    }\n}\n</code></pre> <p>The above specification checks a very simple global invariant that all <code>eRequest</code> events that are being sent by clients in the system have a globally monotonically increasing <code>rId</code>.</p>"},{"location":"manual/monitors/#liveness-specification","title":"Liveness specification","text":"<pre><code>/**************************************************************************\nGuaranteedProgress observes the eRequest and eResponse events,\nit asserts that every request is always responded by a successful response.\n***************************************************************************/\nspec GuaranteedProgress observes eRequest, eResponse {\n    // keep track of the pending requests\n    var pendingReqs: set[int];\n    start state NopendingRequests {\n        on eRequest goto PendingReqs with (req: tRequest){\n            pendingReqs += (req.rId);\n        }\n    }\n    hot state PendingReqs {\n        on eResponse do (resp: tResponse) {\n            assert resp.rId in pendingReqs,\n                format (\"unexpected rId: {0} received, expected one of {1}\", resp.rId, pendingReqs);\n            if(resp.status == SUCCESS)\n            {\n                pendingReqs -= (resp.rId);\n                if(sizeof(pendingReqs) == 0) // requests already responded\n                    goto NopendingRequests;\n            }\n        }\n        on eRequest goto PendingReqs with (req: tRequest){\n            pendingReqs += (req.rId);\n        }\n    }\n}\n</code></pre> <p>The above specification checks the global liveness property that every event <code>eRequest</code> is eventually followed by a corresponding successful <code>eResponse</code> event. The key idea is that the system satisfies a liveness specification if at the end of the execution the monitor is not in a hot state (line 13). The programmers can use <code>hot</code> annotation on states to mark them as intermediate or error states. Hence, properties like <code>eventually something holds</code> or <code>every event X is eventually followed by Y</code> or <code>eventually the system enters a convergence state</code>, all such properties can be specified by marking the intermediate state as <code>hot</code> states and the checker checks that all the executions of the system eventually end in a non-hot state. If there exists an execution that fails to come out of a hot state eventually then it is flagged as a potential liveness violation.</p> <p>Details about the importance of liveness specifications is described here. For several examples of liveness properties, please check the specifications in the tutorial examples.</p>"},{"location":"manual/statemachines/","title":"P State Machines","text":"<p>A P program is a collection of concurrently executing state machines that communicate with each other by sending events (or messages) asynchronously.</p> <p>P State Machine Semantics</p> <p>The underlying model of computation is similar to that of Gul Agha's Actor-model-of-computation (wiki). Here is a summary of important semantic details:</p> <ul> <li>Each P state machine has an unbounded FIFO buffer associated with it.</li> <li>Sends are asynchronous, i.e., executing a send operation <code>send t,e,v;</code> adds event <code>e</code> with payload value <code>v</code> into the FIFO buffer of the target machine <code>t</code>.</li> <li>Variables and functions declared within a machine are local, i.e., they are accessible only from within that machine.</li> <li>Each state in a machine has an entry and an exit function associated with it. The entry function gets executed when the machine enters that state, and similarly, the exit function gets executed when the machine exits that state on an outgoing transition.</li> <li>After executing the entry function, a machine tries to dequeue an event from its input buffer or blocks if the buffer is empty. Upon dequeuing an event from its input queue, a machine executes the attached event handler which might transition the machine to a different state.</li> </ul> <p>For detailed formal semantics of P state machines, we refer the readers to the original P paper and the more recent paper with updated semantics.</p> P State Machine Grammar <pre><code># State Machine in P\nmachineDecl : machine name machineBody\n\n# State Machine Body\nmachineBody : LBRACE machineEntry* RBRACE;\nmachineEntry\n  | varDecl\n  | funDecl\n  | stateDecl\n  ;\n\n# Variable Decl\nvarDecl : var iden : type ;\n\n# State Declaration in P\nstateDecl : start? (hot | cold)? state name { stateBody* }\n\n# State Body\nstateBody:\n  | entry anonFunction                # StateEntryFunAnon\n  | entry funName ;                   # StateEntryFunNamed\n  | exit noParamAnonFunction          # StateExitFunAnon\n  | exit funName;                     # StateExitFunNamed\n\n  ## Transition or Event Handlers in each state\n  | defer eventList ;                               # StateDeferHandler\n  | ignore eventList ;                              # StateIgnoreHandler\n  | on eventList do anonFunction                    # OnEventDoNamedHandler\n  | on eventList do funName ;                       # OnEventDoAnonHandler\n  | on eventList goto stateName ;                   # OnEventGotoState\n  | on eventList goto stateName with anonFunction   # OnEventGotoStateWithAnonHandler\n  | on eventList goto stateName with funName ;      # OnEventGotoStateWithNamedHandler\n  ;\n</code></pre>"},{"location":"manual/statemachines/#variables","title":"Variables","text":"<p>A machine can define a set of local variables that are accessible only from within that machine.</p> <p>Syntax: <code>var iden : type ;</code></p> <p><code>iden</code> is the name of the variable and <code>type</code> is the variable datatype. To know more about different datatypes supported, please checkout P DataTypes.</p>"},{"location":"manual/statemachines/#functions","title":"Functions","text":"<p>A machine can have a set of local named functions that are accessible only from within that machine. Please checkout Named Functions for a detailed description.</p>"},{"location":"manual/statemachines/#state","title":"State","text":"<p>A state can be declared in a machine with a <code>name</code> and a <code>stateBody</code>.</p> <p>Syntax: <code>start? (hot | cold)? state name { stateBody* }</code></p> <p>A single state in each machine should be marked as the <code>start</code> state to identify this state as the starting state on machine creation. Additionally, a state declared inside a P Monitor can also be marked as <code>hot</code> or <code>cold</code>.</p>"},{"location":"manual/statemachines/#state-body","title":"State Body","text":"<p>The state body for a state defines its entry/exit functions and attached event handlers supported by that state. Additionally, the state body can mark certain events as deferred or ignored in the state.</p>"},{"location":"manual/statemachines/#entry-function","title":"Entry Function","text":"<p>The entry function gets executed when a machine enters that state. If the corresponding state is marked as the <code>start</code> state, the entry function gets executed at machine creation.</p> <p>Syntax: <code>entry (anonFunction | funName ;)</code></p> Entry functionEntry function with input parameters <pre><code>entry {\n    print format (\"Entering state\");\n}\n</code></pre> <pre><code>entry (payload : (id : int, msg : string)) {\n    print format (\"Entering state with id {0} and message {1}\", payload.id, payload.msg);\n}\n</code></pre> <p>Defining the entry function for a state is optional. By default, the entry function is defined as a no-op function, i.e., <code>{ // nothing }</code>.</p>"},{"location":"manual/statemachines/#exit-function","title":"Exit Function","text":"<p>The exit function gets executed when a machine exits that state to transition to another state.</p> <p>Syntax: <code>exit (noParamAnonFunction | funName ;)</code></p> Exit function <pre><code>exit {\n    print format (\"Exiting state\");\n}\n</code></pre> <p>Defining the exit function for a state is optional. By default, the exit function is defined as a no-op function, i.e., <code>{ // nothing }</code>.</p>"},{"location":"manual/statemachines/#event-handler","title":"Event Handler","text":"<p>An event handler defined for event <code>E</code> in state <code>S</code> describes what statements are executed when a machine dequeues event <code>E</code> in state <code>S</code>.</p> <p>Syntax: <code>on eventList do (anonFunction | funName ;)</code></p> Event handlerEvent handler with input parameters <pre><code>on eWarmUpReq do {\n    send controller, eWarmUpCompleted;\n}\n</code></pre> <pre><code>on eWithDrawReq do (req: tWithDrawReq) {\n  assert req.accountId in bankBalance,\n    format (\"Unknown accountId {0} in the withdraw request. Valid accountIds = {1}\",\n      req.accountId, keys(bankBalance));\n  pendingWithDraws[req.rId] = req;\n}\n</code></pre>"},{"location":"manual/statemachines/#event-handler-with-goto","title":"Event Handler with Goto","text":"<p>An event handler can be further combined with a Goto statement. After the attached event handler statements are executed, the machine transitions to the <code>goto</code> state.</p> <p>Syntax: <code>on eventList goto stateName (; | with anonFunction | with funName ;)</code></p> Event handler with goto onlyEvent handler with gotoEvent handler with goto and input parameters <pre><code>on eWarmUpCompleted goto CoffeeMakerReady;\n</code></pre> <pre><code>on eTimeOut goto WaitForTransactions with { DoGlobalAbort(TIMEOUT); }\n</code></pre> <pre><code>on eSpec_BankBalanceIsAlwaysCorrect_Init goto WaitForWithDrawReqAndResp with (balance: map[int, int]) {\n  bankBalance = balance;\n}\n</code></pre>"},{"location":"manual/statemachines/#defer","title":"Defer","text":"<p>An event can be deferred in a state. Defer basically defers the dequeue of the event <code>E</code> in state <code>S</code> until the machine transitions to a non-deferred state, i.e., a state that does not defer the event <code>E</code>. The position of the event <code>E</code> that is deferred in state <code>S</code> does not change the FIFO buffer of the machine.</p> <p>Syntax: <code>defer eventList ;</code></p> <p>Dequeuing of an event</p> <p>Whenever a machine encounters a dequeue event, the machine goes over its unbounded FIFO buffer from the front and removes the first event that is not deferred in its current state, keeping rest of the buffer unchanged.</p>"},{"location":"manual/statemachines/#ignore","title":"Ignore","text":"<p>An event <code>E</code> can be ignored in a state, which basically drops the event <code>E</code>.</p> <p>Syntax: <code>ignore eventList ;</code></p> <p>Think of ignore as a short hand for <code>on E do { // nothing };</code>.</p>"},{"location":"manual/statements/","title":"P Statements","text":"<p>A Function in P can be arbitrary piece of imperative code which enables programmers to capture complex protocol logic in their state machines. P supports common imperative programming language statement constructs like while-loops, function calls, and conditionals.</p> P Statements Grammar <pre><code>statement : { statement* }                          # CompoundStmt\n| assert expr (, expr)? ;                           # AssertStmt\n| print expr ;                                      # PrintStmt\n| foreach (iden in expr) statement                  # ForeachStmt\n| while ( expr )  statement                         # WhileStmt\n| if ( expr ) statement (else statement)?           # IfThenElseStmt\n| break ;                                           # BreakStmt\n| continue ;                                        # ContinueStmt\n| return expr? ;                                    # ReturnStmt\n| lvalue = rvalue ;                                 # AssignStmt\n| lvalue += ( expr, rvalue ) ;                      # InsertStmt\n| lvalue += ( rvalue ) ;                            # AddStmt\n| lvalue -= rvalue ;                                # RemoveStmt\n| new iden (rvalue?) ;                              # CtorStmt\n| iden ( rvalueList? ) ;                            # FunCallStmt\n| raise expr (, rvalue)? ;                          # RaiseStmt\n| send expr, expr (, rvalue)? ;                     # SendStmt\n| annouce expr (, rvalue)? ;                        # AnnounceStmt\n| goto iden (, rvalue)? ;                           # GotoStmt\n| receive { recvCase+ }                             # ReceiveStmt\n;\n\n/** l-value may appear as left hand of an assignment operator(=) **/\nlvalue : name=iden        # VarLvalue\n| lvalue . field=iden     # NamedTupleFieldAccess\n| lvalue . int            # TupleFieldAccess\n| lvalue [ expr ]         # CollectionLookUp\n;\n\n/* A r-value is an expression that can\u2019t have a value assigned to it which\nmeans r-value can appear on right but not on left hand side of an assignment operator(=)*/\nrvalue : expr ;\n# rvalueList is a comma separated list of rvalue.\n\n/* case block inside a receive statement */\nrecvCase : case eventList : anonFunction\n</code></pre> <p>The <code>expr</code> is any expression in P defined by the grammar desbribed in P Expressions</p>"},{"location":"manual/statements/#assert","title":"Assert","text":"<p>P allows writing local assertions using the  <code>assert</code> statement. If the program violates the assertion then a counter example is generated by the P checker.</p> <p>Syntax: <code>assert expr (, expr)? ;</code></p> <p>The assert statement must have a <code>boolean</code> expression followed by an optional <code>string</code> message that is printed in the error trace.</p> AssertAssert with Error MessageAssert with Formatted Error Message <pre><code>assert (requestId &gt; 1) &amp;&amp; (requestId in allRequestsSet);\n</code></pre> <p>Assert that the <code>requestId</code> is always greater than <code>1</code> and is in the set of all requests.</p> <pre><code>assert x &gt;= 0, \"Expected x to be always positive\";\n</code></pre> <p>The assert statement can have a <code>string</code> message which is printed in the error trace.</p> <pre><code>assert (requestId in allRequestsSet),\nformat (\"requestId {0} is not in the requests set = {1}\", requestId, allRequestsSet);\n</code></pre> <p>Assert that the <code>requestId</code> is in the set of all requests. You can also provide a formatted string error message to add details to the error message generated.</p>"},{"location":"manual/statements/#print","title":"Print","text":"<p>Print statements can be used for writing or printing log messages into the error traces (especially for debugging purposes).</p> <p>Syntax: <code>print expr ;</code></p> <p>The print statement must have an expression of type <code>string</code>.</p> Print Simple MessagePrint Formatted String Message <pre><code>print \"Hello World!\";\n</code></pre> <p>Print \"Hello World!\" in the execution trace log.</p> <pre><code>x = \"You\";\nprint format(\"Hello World to {0}!!\", x);\n</code></pre> <p>Print \"Hello World to You!!\" in the execution trace log.</p>"},{"location":"manual/statements/#while","title":"While","text":"<p>While statement in P is just like while loops in other popular programming languages like C, C# or Java.</p> <p>Syntax: <code>while ( expr )  statement</code></p> <p><code>expr</code> is the conditional <code>boolean</code> expression and <code>statement</code> could be any P statement.</p> While LoopWhile loop iterating over collection <pre><code>i = 0;\nwhile (i &lt; 10)\n{\n    ...\n    i = i + 1;\n}\n</code></pre> <pre><code>i = 0;\nwhile (i &lt; sizeof(s))\n{\n    ...\n    print s[i];\n    i = i + 1;\n}\n</code></pre>"},{"location":"manual/statements/#foreach","title":"Foreach","text":"<p><code>foreach</code> statement can be used to iterate over a collection (<code>sequence</code> or <code>set</code>) in P.</p> <p>Syntax: <code>foreach (iden in expr) statement</code></p> <p><code>iden</code> is the name of the variable that store the element from the collection during iterations. <code>expr</code> represents the collection over which we want to iterate and must be of type <code>seq</code> or <code>set</code>. Type of <code>iden</code> must be same as the elements type in the collection.</p> <p>Note that variable <code>iden</code> must already be declared, and in each iteration, an element is assigned to this variable at the start of the iteration (no ordering guarantees). Also, one can mutate the collection represented by <code>expr</code> when iterating over it as the foreach statement enumerates over a clone of the collection (more details in the example below).</p> Foreach (set)Foreach (mutating collection)Foreach (Iterating over map) <pre><code>var iter, sum: int;\nvar ints: set[int];\n\n\n// iterate over a set of integers\nforeach(iter in ints)\n{\n    sum = sum + iter;\n}\n</code></pre> <p><pre><code>var iter, sum: int;\nvar ints: set[int];\n\n// iterate over a set of integers\nforeach(iter in ints)\n{\n    ints -= (iter);\n}\n\nassert sizeof(ints) == 0;\n</code></pre> One can mutate the collection represented by <code>expr</code> when iterating over it as the foreach statement enumerates over a clone of the collection (more details in the example below).</p> <p><pre><code>var key: int;\nvar intsM: map[int, int];\n\n// iterate over a set of integers\nforeach(key in keys(intsM))\n{\n    intsM[key] = intsM[key] + delta;\n}\n</code></pre> One can iterate over the map using <code>keys</code> and <code>values</code> functions.</p> <p>You can find more examples for the foreach statement in the file</p>"},{"location":"manual/statements/#if-then-else","title":"If Then Else","text":"<p>IfThenElse statement in P is just like conditional if statements in other popular programming languages like C, C# or Java.</p> <p>Syntax: <code>if ( expr ) statement (else statement)?</code></p> <p><code>expr</code> is the conditional <code>boolean</code> expression and <code>statement</code> could be any P statement. The <code>else</code> block is optional.</p> If StatementIf Else Statement <pre><code>if(x &gt; 10) {\n    ...\n    x = x + 20;\n}\n</code></pre> <pre><code>if(x &gt; 10)\n{\n    x = 0;\n}\nelse\n{\n    x = x + 1;\n}\n</code></pre>"},{"location":"manual/statements/#break-and-continue","title":"Break and Continue","text":"<p><code>break</code> and <code>continue</code> statements in P are just like in other popular programming languages like C, C# or Java to break out of the while loop or to continue to the next iteration of the loop respectively.</p> BreakContinue <pre><code>while(true) {\n    ...\n    if(x == 10)\n        break;\n    ...\n    x = x + 1;\n}\n</code></pre> <pre><code>while(true) {\n    ...\n    if(x == 10) // skip the loop when x is 10\n        continue;\n    ...\n}\n</code></pre>"},{"location":"manual/statements/#return","title":"Return","text":"<p><code>return</code> statement in P can be used to return (or return a value) from any function.</p> ReturnReturn Value <pre><code>fun IncrementX() {\n    if(x &gt; MAX_INT)\n        return;\n    x = x + 1;\n}\n</code></pre> <pre><code>fun Max(x: int, y: int) : int{\nif(x &gt; y)\n    return x;\nelse\n    return y;\n}\n</code></pre>"},{"location":"manual/statements/#assignment","title":"Assignment","text":"<p>Value Semantics</p> <p>Recollect that P has value semantics or copy-by-value semantics and does not support any notion of references.</p> <p>Syntax: <code>lvalue = rvalue ;</code></p> <p>Note that because of value semantics assignment in P copies the value of the <code>rvalue</code> into <code>lvalue</code>. <code>lvalue</code> could be any variable, a tuple field access, or an element in a collection as described in the Grammar above. <code>rvalue</code> could be any expression that evaluates to the same type as <code>lvalue</code>.</p> Assignment is copying!Assignments .. <pre><code>var a: seq[string];\nvar b: seq[string];\nb += (0, \"b\");\na = b; // copy value\na += (1, \"a\");\nprint a; // will print [\"b\", \"a\"]\nprint b; // will print [\"b\"]\n</code></pre> <pre><code>a = 10; s[i] = 20; tup1.a = \"x\";\ntup2.0 = 10; t = foo();\n</code></pre>"},{"location":"manual/statements/#insert","title":"Insert","text":"<p>Insert statement is used to insert or add an element into a collection.</p> <p>Syntax: <code>lvalue += ( expr, rvalue ) ;</code> or <code>lvalue += ( rvalue ) ;</code></p> <p><code>lvalue</code> is a value of any collection type in P.</p> Insert into a SequenceInsert into a map or update mapInsert or add into a set <pre><code>var sq : seq[T];\nvar x: T, i : int;\n\n// add x into the sequence sq at index i\nsq += (i, x);\n</code></pre> <p>Index for a sequence</p> <p>The value of index <code>i</code> above should be between <code>0 &lt;= i &lt;= sizeof(sq)</code>. <code>i = 0</code> inserts x at the start of <code>sq</code> and <code>i = sizeof(sq)</code> appends x at the end of <code>sq</code></p> <pre><code>var mp : map[K,V];\nvar x: K, y: V;\n\n// adds (x, y) into the map\nmp += (x, y);\n// adds (x, y) into the map, if key x already exists then updates its value to y.\nmp[x] = y;\n</code></pre> <pre><code>var st : set[T];\nvar x: T;\n\n// adds x into the set st\nst += (x);\n</code></pre>"},{"location":"manual/statements/#remove","title":"Remove","text":"<p>Remove statement is used to remove an element from a collection.</p> <p>Syntax: <code>lvalue -= rvalue ;</code></p> Remove from a SequenceRemove from a mapRemove from a set <pre><code>var sq : seq[T];\nvar i : int;\n\n// remove element at index i in the sequence sq\nsq -= (i);\n</code></pre> <p>Index for a sequence</p> <p>The value of index <code>i</code> above should be between <code>0 &lt;= i &lt;= sizeof(sq) - 1</code>.</p> <pre><code>var mp : map[K,V];\nvar x: K;\n\n// Removes the element (x, _) from the map i.e., removes the element with key x from mp\nmp -= (x);\n</code></pre> <pre><code>var st : set[T];\nvar x: T;\n\n// removes x from the set st\nst -= (x);\n</code></pre>"},{"location":"manual/statements/#new","title":"New","text":"<p>New statement is used to create an instance of a machine in P.</p> <p>Syntax: <code>new iden (rvalue?) ;</code></p> Create a machine <p><pre><code>new Client((id = 1, server = this));\n</code></pre> Creates a dynamic instance of a Client machine and passes the constructor parameter <code>(id = 1, server = this)</code> which is delivered as a payload to the entry function of the start state of the created Client machine.</p>"},{"location":"manual/statements/#function-call","title":"Function Call","text":"<p>Function calls in P are similar to any other imperative programming languages.</p> <p>Note that the parameters passed to the functions and the return values are pass-by-value!</p> <p>Syntax: <code>iden ( rvalue? ) ;</code></p> Function call <pre><code>Foo(); Bar(10, \"haha\");\n</code></pre>"},{"location":"manual/statements/#raise","title":"Raise","text":"<p>The statement <code>raise e, v;</code> terminates the evaluation of the function raising an event <code>e</code> with payload <code>v</code>. The control of the state machine jumps to end of the entry function (popping the function stack if raise is trigger inside a nested function), and the state machine immediately handles the raised event. One can think of raise of an event as throwing an exception which terminates the execution of the function stack and must be immediately handled by the event-handlers defined in that state.</p> <p>Syntax: <code>raise expr (, rvalue)?</code></p> Raise EventNon deterministically triggering event handlers internally <pre><code>state HandleRequest {\n    entry (req: tRequest)\n    {\n        // ohh, this is a Add request and I have a event handler for it\n        if(req.type == \"Add\")\n            raise eAddOperation, req.Transaction; // terminates function\n        .....\n        .....\n        assert req.type != \"Add\"; // valid\n    }\n\n    on eAddOperation do (trans: tTransaction) { ... }\n}\n</code></pre> <pre><code>    state DoAddOrRemove {\n        entry\n        {\n            /* I am uncertain, at this point I may want to trigger\n            a Add or Substract event-handler without sending an event\n            to self which will be enqueued and then dequeued in FIFO order\n            I want to immediately execute this handlers before anything else */\n            if($)\n                raise eAddOperation, transaction; // terminates function\n            else\n                raise eRemoveOperation, transaction; // terminates function\n\n            assert false; // valid, as this is unreachable\n        }\n\n        on eAddOperation do (trans: tTransaction) { ... }\n        on eRemoveOperation do (trans: tTransaction) { ... }\n    }\n</code></pre>"},{"location":"manual/statements/#send","title":"Send","text":"<p>Send statement is one of the most important statements in P as it is used to send messages to other state machines . Send takes as argument a triple <code>send t, e, v</code>, where <code>t</code> is a reference to the target state machine, <code>e</code> is the event sent and <code>v</code> is the associated payload.</p> <p>Syntax: <code>send expr, expr (, rvalue)? ;</code></p> <p>Sends in P are asynchronous and non-blocking. Statement <code>send t, e, v</code> enqueues the event <code>e</code> with payload <code>v</code> into the target machine <code>t</code>'s message buffer.</p> Send event with payloadSend event <pre><code>send server, eRequest, (source = this, reqId = 0);\n</code></pre> <pre><code>send server, ePing;\n</code></pre>"},{"location":"manual/statements/#announce","title":"Announce","text":"<p>Announce is used to publish messages to specification monitors in P. When writing specifications there are instances when we would like to send additional information to monitors that is not captured in the events exchanged between state machines. Recollect that spec monitors in P follow a publish-subscribe model of communication. Each monitor <code>observes</code> a set of events and whenever a machine sends an event that is in the <code>observes</code> set of a monitor then it is synchronously delivered to the monitor. Announce can be used to publish an event to all the monitors that are observing that event. The Two phase commit example provides an use case for announce.</p> <p>Syntax: <code>annouce expr (, rvalue)? ;</code></p> Announce event <p><pre><code>spec CheckConvergedState observes eStateUpdate, eSystemConverged\n{ ... }\n</code></pre> Consider a specification monitor that continuously observes <code>eStateUpdate</code> event to keep track of the system state and then asserts the required property when the system converges. We can use an announce statement to inform the monitor when the system has converged and we should to assert the global specification. <pre><code>announce eSystemConverged, payload;\n</code></pre></p> <p>Note</p> <p>Announce only delivers events to specification monitors (not state machines) and hence has no side effect on the system behavior. Announce is used for passing information to the monitors during system execution which the monitors can use to assert global specifications about the system.</p>"},{"location":"manual/statements/#goto","title":"Goto","text":"<p>Goto statement can be used to jump to a particular state. On executing a goto, the state machine exits the current state (terminating the execution of the current function) and enters the target state. The optional payload accompanying the goto statement becomes the input parameter to the entry function of the target state.</p> <p>Syntax: <code>goto iden (, rvalue)? ;</code></p> GotoGoto with payload <pre><code>state ServicePendingRequests {\n    entry {\n        if(sizeof(pendingRequests) == 0)\n            goto Done;\n\n        // process requests\n        ....\n    }\n}\n\nstate Done { ... }\n</code></pre> <pre><code>state ServiceRequests {\n    entry (req: tRequest) {\n        // process request with some complicated logic\n        ...\n        lastReqId = req.Id;\n        goto WaitForRequests, lastReqId;\n    }\n}\n\nstate WaitForRequests {\n    entry (lastReqId: int) { ... }\n}\n</code></pre>"},{"location":"manual/statements/#receive","title":"Receive","text":"<p>Receive statements in P are used to perform blocking await/receive for a set of events inside a function.</p> <p>Syntax: <pre><code>receive { recvCase+ }\n/* case block inside a receive statement */\nrecvCase : case eventList : anonFunction\n</code></pre></p> <p>Each <code>receive</code> statement can block or wait on a set of events, all other events are automatically deferred by the state machine. On receiving an event that the <code>receive</code> is blocking on (case blocks), the state machine unblocks, executes the corresponding case-handler and resumes executing the next statement after receive.</p> Receive: await single eventReceive: await multiple events <p><pre><code>fun AcquireLock(lock: machine)\n{\n    send lock, eAcquireLock;\n    receive {\n        case eLockGranted: (result: tResponse) { /* case handler */ }\n    }\n    print \"Lock Acquired!\"\n}\n</code></pre> Note that when executing the AcquireLock function the state machine blocks at the receive statement, it automatically defers all the events except the <code>eLockGranted</code> event. On receiving the <code>eLockGranted</code>, the case-handler is executed and then the print statement.</p> <p><pre><code>fun WaitForTime(timer: Timer, time: int)\n{\n    var success: bool;\n    send timer, eStartTimer, time;\n    receive {\n        case eTimeOut: { success = true; }\n        case eStartTimerFailed: { success = false; }\n    }\n    if (success) print \"Successfully waited!\"\n}\n</code></pre> Note that when executing the WaitForTime function the state machine blocks at the receive statement, it automatically defers all the events except the <code>eTimeOut</code> and <code>eStartTimerFailed</code> events.</p>"},{"location":"manual/testcases/","title":"P Test cases","text":"<p>P test cases define different finite scenarios under which we would like to check the correctness of our system. Each test case is automatically discharged by the P Checker.</p> P Test Cases Grammar <pre><code>testcase\n| test iden [main=iden] : modExpr ;                                           # TestDecl\n| test param (paramList) iden [main=iden] : modExpr ;                         # ParamTestDecl\n| test param (paramList) assume (expr) iden [main=iden] : modExpr ;           # AssumeTestDecl\n| test param (paramList) (num wise) iden [main=iden] : modExpr;               # TWiseTestDecl\n;\n\nparamList\n| iden in [valueList]                                                         # SingleParam\n| iden in [valueList], paramList                                              # MultiParam\n;\n\nvalueList\n| value                                                                       # SingleValue\n| value, valueList                                                            # MultiValue\n;\n\nvalue\n| num                                                                         # NumberValue\n| bool                                                                        # BoolValue\n;\n</code></pre> <p><code>modExpr</code> represent the P module defined using the module expressions described in P Module System</p>"},{"location":"manual/testcases/#basic-test-case","title":"Basic Test Case","text":"<p>A basic test case checks the correctness of a module under a specific scenario.</p> <p>Syntax: <code>test tName [main=mName] : module_under_test ;</code></p> <ul> <li><code>tName</code> is the name of the test case</li> <li><code>mName</code> is the name of the main machine where execution starts</li> <li><code>module_under_test</code> is the module to be tested</li> </ul> Basic Test <pre><code>test tcSingleClient [main=TestWithSingleClient]:\n  assert BankBalanceIsAlwaysCorrect in\n  (union Client, Bank, { TestWithSingleClient });\n</code></pre>"},{"location":"manual/testcases/#parameterized-test-cases","title":"Parameterized Test Cases","text":"<p>Parameterized tests allow systematic exploration of different system configurations. Before using parameters in test cases, they must be declared as global variables with their types.</p> <p>Parameter Declaration Syntax: <code>param name : type ;</code></p> <p>For example: <pre><code>param nClients : int;   // For numeric parameters\nparam b1 : bool;        // For boolean parameters\nparam g1 : int;         // For another numeric parameter\n</code></pre></p> Basic Parameter TestMultiple ParametersWith AssumptionN-wise Testing <pre><code>test param (nClients in [2, 3, 4]) tcTest [main=TestWithConfig]:\n  assert BankBalanceIsAlwaysCorrect in\n  (union Client, Bank, { TestWithConfig });\n</code></pre> <pre><code>test param (nClients in [2, 3, 4], g1 in [1, 2], g2 in [4, 5]) tcTest [main=TestWithConfig]:\n  assert BankBalanceIsAlwaysCorrect in\n  (union Client, Bank, { TestWithConfig });\n</code></pre> <pre><code>test param (nClients in [2, 3, 4], g1 in [1, 2], g2 in [4, 5]) \n  assume (nClients + g1 &lt; g2) tcTest [main=TestWithConfig]:\n  assert BankBalanceIsAlwaysCorrect in\n  (union Client, Bank, { TestWithConfig });\n</code></pre> <pre><code>test param (nClients in [2, 3, 4], g1 in [1, 2], g2 in [4, 5], b1 in [true, false])\n  (2 wise) tcTest [main=TestWithConfig]:\n  assert BankBalanceIsAlwaysCorrect in\n  (union Client, Bank, { TestWithConfig });\n</code></pre> <p>Properties Checked</p> <p>For each test case, the P checker asserts: 1. No <code>unhandled event</code> exceptions 2. All local assertions hold 3. No deadlocks 4. All specification monitors properties hold</p> <p>Tutorial Examples</p> <p>For complete examples of parameterized testing in action, see:</p> <ul> <li>Client Server: Basic example showing parameter declarations and usage</li> <li>Two Phase Commit: Shows pairwise testing of system configurations with assumptions</li> <li>Failure Detector: Demonstrates testing different system sizes and monitoring loads</li> <li>Espresso Machine: Illustrates testing various user interaction scenarios</li> </ul>"},{"location":"old/advanced/debuggingerror/","title":"Debuggingerror","text":"<p>As described in the using P compiler and checker section, running the following command for the ClientServer example finds an error.</p> <pre><code>pmc &lt;Path&gt;/ClientServer.dll \\\n    -m PImplementation.tcSingleClientAbstractServer.Execute \\\n    -i 100\n</code></pre> Expected Output <pre><code>pmc &lt;Path&gt;/ClientServer.dll -m PImplementation.tcSingleClientAbstractServer.Execute -i 100\n\n. Testing &lt;Path&gt;/ClientServer.dll\n... Method PImplementation.tcSingleClientAbstractServer.Execute\nStarting TestingProcessScheduler in process 72578\n... Created '1' testing task.\n... Task 0 is using 'random' strategy (seed:574049731).\n..... Iteration #1\n... Task 0 found a bug.\n... Emitting task 0 traces:\n..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.txt\n..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.schedule\n... Elapsed 0.1971223 sec.\n... Testing statistics:\n..... Found 1 bug.\n... Scheduling statistics:\n..... Explored 1 schedule: 1 fair and 0 unfair.\n..... Found 100.00% buggy schedules.\n..... Number of scheduling points in fair terminating schedules: 132 (min), 132 (avg), 132 (max).\n... Elapsed 0.3081316 sec.\n. Done\n</code></pre> <p>The P checker on finding a bug generates two artifacts (highlighted in the expected output above): (1) a textual trace file (e.g., <code>ClientServer_0_0.txt</code>) that has the readable error trace representing the sequence of steps from the intial state to the error state. (2) a schedule file (e.g., <code>ClientServer_0_0.schedule</code>) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging.</p>"},{"location":"old/advanced/debuggingerror/#error-trace","title":"Error Trace","text":"<p>The <code>*.txt</code> file contains a textual error trace representing the sequence of steps (i.e, messages sent, messages received, machines created) from the initial state to the final error state. In the end of the error trace is the final error message, for example, in the case of ClientServer example above, you must see the following in the end of the error trace.</p> <pre><code>&lt;ErrorLog&gt; Assertion Failed: Bank must accept the with draw request for 1,\n  bank balance is 11!\n</code></pre> <p>In most cases, you can ignore the stack trace and information below the <code>ErrorLog</code>.</p>"},{"location":"old/advanced/debuggingerror/#error-schedule-single-stepping-through-error-trace","title":"Error Schedule (single stepping through error trace)","text":"<p>In certain cases, the trace log is not enough for debugging the issue and we would like to single step through the error state and look at the internal state of the state machines that is not captured in the trace log. We present the step-by-step guide to show how we can use the <code>.schedule</code> file to single step through the C# representation of the P program.</p>"},{"location":"old/advanced/debuggingerror/#step-0-install-rider-or-visual-studio","title":"[Step 0]: Install Rider (or Visual Studio)","text":"<p>Before starting, we recommend that you have Rider installed on your machine, we will use Rider's C# debugger.</p>"},{"location":"old/advanced/debuggingerror/#step-1-update-the-testcs-file","title":"[Step 1]: Update the <code>Test.cs</code> file","text":"<p>On compiling any P project, the compiler generates two files a <code>Test.cs</code> file and a C# project <code>*.csproj</code> file. For debugging the error trace, you must open the generated <code>csproj</code> file (its generally, <code>&lt;ProjectName&gt;.csproj</code>) using Rider and then edit the <code>Test.cs</code> file as follows:</p> <pre><code>public class _TestRegression {\n  public static void Main(string[] args)\n  {\n    Configuration configuration = Configuration.Create();\n    configuration.WithVerbosityEnabled(true);\n    // update the path to the schedule file.\n    string schedule = File.ReadAllText(\"absolute path to *.schedule file\");\n    configuration.WithReplayStrategy(schedule);\n    TestingEngine engine = TestingEngine.Create(configuration, (Action&lt;IActorRuntime&gt;)PImplementation.&lt;Name of the test case&gt;.Execute);\n    engine.Run();\n    string bug = engine.TestReport.BugReports.FirstOrDefault();\n        if (bug != null)\n    {\n        Console.WriteLine(bug);\n    }\n\n  }\n}\n</code></pre> <ul> <li> <p>Update the path of .schedule file: Edit the <code>Test.cs</code> file and update the line 7 above with the absolute path to the <code>.schedule</code> file that represents the error schedule you want to debug.</p> </li> <li> <p>Update the test case name: Update the test case name on line 9 above. In our case, for the clientserver example it would become <code>PImplementation.tcSingleClientAbstractServer.Execute</code>.</p> </li> </ul>"},{"location":"old/advanced/debuggingerror/#step-2-add-breakpoints-to-start-debugging","title":"[Step 2]: Add breakpoints to start debugging","text":"<p>You must next add the necessary break points in the Generated C# code. If you want to stop the execution at a particular P function/handler, locate that function in the generated code and add a break point. Now, you can start debugging using Rider just like you would debug anyother C# or Java program.</p> <p>For example, you can add a breakpoint at line 904 in the generated code ClientServer.cs in PGenerated folder to hit the assertion that failed. <pre><code>String.Format(\"Bank must accept the with draw request for {0}, bank balance is {1}!\",TMP_tmp38,TMP_tmp40);\n</code></pre></p>"},{"location":"old/advanced/debuggingerror/#replaying-the-error-schedule","title":"Replaying the Error Schedule","text":"<p>One can also replay the error schedule using commandline and enabling verbose feature to dump out the error trace on the commandline.</p> <pre><code>pmc &lt;path to dll&gt;.dll --schedule &lt;buggy&gt;.schedule -m &lt;testcaseName&gt; -v\n</code></pre> <p>For example,</p> <pre><code>pmc ClientServer.dll --schedule ClientServer_0_0.schedule -m PImplementation.tcSingleClientAbstractServer.Execute -v\n</code></pre>"},{"location":"old/getstarted/install/","title":"Installing P","text":"<p>P is built to be cross-platform and can be used on MacOS, Linux, and Windows. We provide a step-by-step guide for installing P along with its required dependencies.</p> <p>After each step, please use the troubleshooting check to ensure that each installation step succeeded.</p>"},{"location":"old/getstarted/install/#step-1-install-net-core-sdk","title":"[Step 1] Install .Net Core SDK","text":"<p>The P compiler and checker are implemented in C# and hence the tool chain requires <code>dotnet</code>. P currently uses the specific version of .Net SDK 3.1. To install .Net Core 3.1 SDK use:</p> MacOSUbuntuAmazon Linux <p>Installing .Net SDK on MacOS using Homebrew (details) <pre><code>brew tap isen-ng/dotnet-sdk-versions\nbrew install --cask dotnet-sdk3-1-400\n</code></pre> Dont have Homebrew?  Install directly using the installer.</p> <p>Installing .Net SDK on Ubuntu (details)</p> <pre><code>wget https://packages.microsoft.com/config/ubuntu/21.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\nrm packages-microsoft-prod.deb\n</code></pre> <pre><code>sudo apt-get update; \\\nsudo apt-get install -y apt-transport-https &amp;&amp; \\\nsudo apt-get update &amp;&amp; \\\nsudo apt-get install -y dotnet-sdk-3.1\n</code></pre> <p>Installing .Net SDK on Amazon Linux (details)</p> <pre><code>```\nsudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm\n```\n\n```\nsudo yum install dotnet-sdk-3.1\n```\n</code></pre> Windows <p>Installing .Net SDK on Windows using the installer (details)</p> Troubleshoot: Confirm that dotnet is correctly installed on your machine. <p><code>dotnet --list-sdks</code></p> <pre><code>You must see an SDK with `3.1.*` dotnet version installed.\nIf you get `dotnet` command not found error, mostly likely, you need to add the path to dotnet in your `PATH`.\n</code></pre>"},{"location":"old/getstarted/install/#step-2-install-java-runtime","title":"[Step 2] Install Java Runtime","text":"<p>P compiler uses ANTLR parser and hence requires <code>java</code>. If you already have Java installed , ignore this step. To install Java use:</p> MacOSUbuntuAmazon LinuxWindows <p>Installing Java on MacOS using Homebrew (details) <pre><code>brew install java\n</code></pre> Dont have Homebrew? Directly use installer.</p> <p>Installing Java on Ubuntu (details)</p> <pre><code>sudo apt install default-jre\n</code></pre> <p>Installing Java 11 on Amazon Linux (you can use any version of java &gt;= 9)</p> <pre><code>sudo yum install java-11-amazon-corretto-devel\n</code></pre> <p>Installing Java on Windows (details)</p> Troubleshoot: Confirm that java is correctly installed on your machine. <p><code>java -version</code></p> <pre><code>If you get `java` command not found error, mostly likely, you need to add the path to `java` in your `PATH`.\n</code></pre>"},{"location":"old/getstarted/install/#step-3-install-p-compiler","title":"[Step 3] Install P Compiler","text":"<p>Install the P compiler as a <code>dotnet tool</code> using the following command:</p> <pre><code>dotnet tool install --global P\n</code></pre> Troubleshoot: Confirm that <code>pc</code> is correctly installed on your machine <p>After installation, run <code>which pc</code> and it should show: <pre><code>which pc\n/Users/&lt;user&gt;/.dotnet/tools/pc\n</code></pre> If not, add <code>$HOME/.dotnet/tools</code> to <code>$PATH</code> in your <code>.bash_profile</code> (or equivalent) and try again after restarting the shell. If you are getting the error that the <code>pc</code> command is not found, it is most likely that <code>$HOME/.dotnet/tools</code> is not in your <code>PATH</code>.</p> Updating P Compiler <p>You can update the version of <code>P</code> compiler by running the following command:</p> <pre><code>`dotnet tool update --global P`\n</code></pre>"},{"location":"old/getstarted/install/#step-4-install-p-checker","title":"[Step 4] Install P Checker","text":"<p>The current P checker depends on Coyote (previously P#)</p> <p>Install the <code>Coyote</code> version <code>1.0.5</code> using the following command:</p> <pre><code>dotnet tool install --global Microsoft.Coyote.CLI --version 1.0.5\n</code></pre> Troubleshoot: Confirm that <code>coyote</code> is correctly installed on your machine <p>After installation, run <code>which coyote</code> and it should show: <pre><code>which coyote\ncoyote is /Users/&lt;user&gt;/.dotnet/tools/coyote\n</code></pre> If not, add <code>$HOME/.dotnet/tools</code> to <code>$PATH</code> in your <code>.bash_profile</code> (or equivalent) and try again after restarting the shell. If you are getting an error that <code>coyote</code> command not found, its most likely that <code>$HOME/.dotnet/tools</code> is not in your <code>PATH</code>.</p> <p>We highly recommend that you create the following alias as we use it in the rest of tutorials and getting started guide:</p> On MacOS or LinuxOn Windows <p>Add following alias to the bash profile (<code>~/.bash_profile</code> or the equivalent on your system) so that you can invoke the P checker (<code>pmc</code>) directly. <pre><code>alias pmc='coyote test'\n</code></pre></p> <p>We recommend that you add the following to the <code>Microsoft.PowerShell_profile</code> normally found in <code>D:\\Users\\&lt;username&gt;\\Documents\\WindowsPowerShell</code></p> <pre><code>function pmc { coyote test $args }\n</code></pre> <ul> <li> <p>For debugging generated C# code, we recommend using Rider for Mac/Linux or Visual Studio 2019 for Windows.</p> </li> <li> <p>For debugging generated Java code, we recommend using IntelliJ IDEA</p> </li> </ul>"},{"location":"old/getstarted/install/#using-p","title":"Using P","text":"<p>Great ! You are all set to compile and test your first P program !</p>"},{"location":"old/getstarted/usingP/","title":"Using P Compiler and Checker","text":"<p>Before moving forward, we assume that you have successfully installed the P Compiler and Checker.</p> <p>We introduce the P language syntax and semantics in details in the Tutorials and Language Manual. In this section, we provide an overview of the steps involved in compiling and testing a P program using the client server example in Tutorials.</p> Get the Client Server Example Locally <p>We will use the ClientServer example from Tutorial folder in P repository to describe the process of compiling and testing a P program. Please clone the P repo and navigate to the ClientServer example in Tutorial.</p> <p>Clone P Repo locally: <pre><code>git clone https://github.com/p-org/P.git\n</code></pre> Navigate to the ClientServer examples folder: <pre><code>cd &lt;P cloned folder&gt;/Tutorial/1_ClientServer\n</code></pre></p>"},{"location":"old/getstarted/usingP/#compiling-a-p-program","title":"Compiling a P program","text":"<p>There are two ways of compiling a P program:</p> <ol> <li>Using a P project file (<code>*.pproj</code>) to provides all the required inputs to the compiler or</li> <li>Passing all the P files (<code>*.p</code>) along with other options (e.g., <code>-generate</code>) as commandline arguments to the compiler.</li> </ol> <p>Recommendation</p> <p>We recommend using the P project files to compile a P program.</p> P Compiler commandline options: <p>The P compiler provides the following commandline options:</p> <pre><code>------------------------------------------\nRecommended usage:\n\n&gt;&gt; pc -proj:&lt;.pproj file&gt;\n\n------------------------------------------\nOptional usage:\n\n&gt;&gt; pc file1.p [file2.p ...][options]\n\noptions:\n    -t:[target project name]   -- project name (as well as the generated file) if not supplied, use file1\n    -outputDir:[path]          -- where to write the generated files\n    -aspectOutputDir:[path]    -- where to write the generated aspectj files if not supplied, use outputDir\n    -generate:[C,CSharp,RVM]   -- select a target language to generate\n        C       : generate C code\n        CSharp  : generate C# code\n        RVM     : generate Monitor code\n    -h, -help, --help          -- display this help message\n------------------------------------------\n</code></pre> Compile using the P ProjectCompile P files directly <p>Compiling the ClientServer project using the P Project file:</p> <pre><code>pc -proj:ClientServer.pproj\n</code></pre> Expected Output <pre><code>$ pc -proj:ClientServer.pproj\n----------------------------------------\n==== Loading project file: ClientServer.pproj\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p\n....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p\n....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p\n....... includes p file: /Tutorial/1_ClientServer/PTst/Testscript.p\n----------------------------------------\n----------------------------------------\nParsing ..\nType checking ...\nCode generation ....\nGenerated ClientServer.cs\n----------------------------------------\nCompiling ClientServer.csproj ..\n\nMicrosoft (R) Build Engine version 16.10.2+857e5a733 for .NET\nCopyright (C) Microsoft Corporation. All rights reserved.\n\nDetermining projects to restore...\nAll projects are up-to-date for restore.\nClientServer -&gt; P/Tutorial/1_ClientServer/POutput/netcoreapp3.1/ClientServer.dll\n\nBuild succeeded.\n    0 Warning(s)\n    0 Error(s)\n----------------------------------------\n</code></pre> P Project File Details <p>The P compiler does not support advanced project management features like separate compilation and dependency analysis (coming soon). The current project file interface is a simple mechanism to provide all the required inputs to the compiler in an XML format (ClientServer.pproj). <pre><code>&lt;!-- P Project file for the Client Server example --&gt;\n&lt;Project&gt;\n&lt;ProjectName&gt;ClientServer&lt;/ProjectName&gt;\n&lt;InputFiles&gt;\n    &lt;PFile&gt;./PSrc/&lt;/PFile&gt;\n    &lt;PFile&gt;./PSpec/&lt;/PFile&gt;\n    &lt;PFile&gt;./PTst/&lt;/PFile&gt;\n&lt;/InputFiles&gt;\n&lt;OutputDir&gt;./PGenerated/&lt;/OutputDir&gt;\n&lt;/Project&gt;\n</code></pre> The <code>&lt;InputFiles&gt;</code> block provides all the P files that must be compiled together for this project. In <code>&lt;PFile&gt;</code> one can either specify the path to a P file or to a folder and the P compiler includes all the <code>*.p</code> files in the folder during compilation. The <code>&lt;ProjectName&gt;</code> block provides the name for the project which is used as the output file name for the generated code. The <code>&lt;OutputDir&gt;</code> block provides the output directory for the generated code. Finally, the <code>&lt;IncludeProject&gt;</code> block provides a path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects (transitively including all P files in dependent projects) and compiles them together. This feature provides a way to split the P models for a large system into sub projects that can share models.</p> <p>Compiling the ClientServer program by passing all the required inputs as commandline arguments:</p> <pre><code>pc PSpec/*.p PSrc/*.p PTst/*.p \\\n-generate:csharp -outputDir:PGenerated -target:ClientServer\n</code></pre> Expected Output <pre><code>----------------------------------------\n....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p\n....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p\n....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p\n----------------------------------------\n----------------------------------------\nParsing ..\nType checking ...\nCode generation ....\nGenerated ClientServer.cs\n----------------------------------------\nCompiling ClientServer.csproj ..\n\nMicrosoft (R) Build Engine version 16.10.2+857e5a733 for .NET\nCopyright (C) Microsoft Corporation. All rights reserved.\n\nDetermining projects to restore...\nRestored P/Tutorial/1_ClientServer/PGenerated/ClientServer.csproj (in 602 ms).\nClientServer -&gt; P/Tutorial/1_ClientServer/PGenerated/POutput/netcoreapp3.1/ClientServer.dll\n\nBuild succeeded.\n    0 Warning(s)\n    0 Error(s)\n</code></pre>"},{"location":"old/getstarted/usingP/#testing-a-p-program","title":"Testing a P program","text":"<p>Compiling the ClientServer program generates a <code>ClientServer.dll</code>, this <code>dll</code> is the C# representation of the P program. The P Checker takes as input this <code>dll</code> and systematically explores behaviors of the program for the specified test case.</p> <p>The path to the <code>dll</code> is present in the generated compilation output, check for line: <code>ClientServer -&gt; &lt;Path&gt;/ClientServer.dll</code></p> <p>You can get the list of test cases defined in the P program by passing the generated <code>dll</code> to the P Checker:</p> <pre><code>pmc &lt;Path&gt;/ClientServer.dll\n</code></pre> <p>Expected Output:</p> <p><pre><code>pmc &lt;Path&gt;/ClientServer.dll\n\nProvide /method or -m flag to qualify the test method name you wish to use.\nPossible options are::\nPImplementation.tcSingleClient.Execute\nPImplementation.tcMultipleClients.Execute\nPImplementation.tcSingleClientAbstractServer.Execute\n</code></pre> There are three test cases defined in the ClientServer P project and you can specify which test case to run by using the <code>-m</code> or <code>/method</code> parameter along with the <code>-i</code> parameter to specify how many different schedules to explore when running this test case (by default the checker explores a single schedule). For complex systems, running for 100,000 schedules typically finds most of the easy to find bugs before running the checker on a distributed cluster to explore billions of schedules and rule out deep bugs in the system.</p> <p>So to run the <code>tcSingleClient</code> test case for 100 schedules, we can use the following command:</p> <pre><code>pmc &lt;Path&gt;/ClientServer.dll \\\n    -m PImplementation.tcSingleClient.Execute \\\n    -i 100\n</code></pre> Expected Output <pre><code>. Testing &lt;Path&gt;/ClientServer.dll\n... Method PImplementation.tcSingleClient.Execute\nStarting TestingProcessScheduler in process 72009\n... Created '1' testing task.\n... Task 0 is using 'random' strategy (seed:3365663330).\n..... Iteration #1\n..... Iteration #2\n..... Iteration #3\n..... Iteration #4\n..... Iteration #5\n..... Iteration #6\n..... Iteration #7\n..... Iteration #8\n..... Iteration #9\n..... Iteration #10\n..... Iteration #20\n..... Iteration #30\n..... Iteration #40\n..... Iteration #50\n..... Iteration #60\n..... Iteration #70\n..... Iteration #80\n..... Iteration #90\n..... Iteration #100\n... Testing statistics:\n..... Found 0 bugs.\n... Scheduling statistics:\n..... Explored 100 schedules: 100 fair and 0 unfair.\n..... Number of scheduling points in fair terminating schedules: 11 (min), 147 (avg), 680 (max).\n... Elapsed 0.8209742 sec.\n. Done\n</code></pre> <p>There is a known bug in the ClientServer example (explained in the Tutorials) which is caught by the <code>tcSingleClientAbstractServer</code> test case. Run command: <pre><code>pmc &lt;Path&gt;/ClientServer.dll \\\n    -m PImplementation.tcSingleClientAbstractServer.Execute \\\n    -i 100\n</code></pre></p> Expected Output <pre><code>pmc &lt;Path&gt;/ClientServer.dll -m PImplementation.tcSingleClientAbstractServer.Execute -i 100\n\n. Testing &lt;Path&gt;/ClientServer.dll\n... Method PImplementation.tcSingleClientAbstractServer.Execute\nStarting TestingProcessScheduler in process 72578\n... Created '1' testing task.\n... Task 0 is using 'random' strategy (seed:574049731).\n..... Iteration #1\n... Task 0 found a bug.\n... Emitting task 0 traces:\n..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.txt\n..... Writing /POutput/netcoreapp3.1/Output/ClientServer.dll/CoyoteOutput/ClientServer_0_0.schedule\n... Elapsed 0.1971223 sec.\n... Testing statistics:\n..... Found 1 bug.\n... Scheduling statistics:\n..... Explored 1 schedule: 1 fair and 0 unfair.\n..... Found 100.00% buggy schedules.\n..... Number of scheduling points in fair terminating schedules: 132 (min), 132 (avg), 132 (max).\n... Elapsed 0.3081316 sec.\n. Done\n</code></pre> <p>The P checker on finding a bug generates two artifacts (highlighted in the expected output above): (1) a textual trace file (e.g., <code>ClientServer_0_0.txt</code>) that has the readable error trace representing the sequence of steps from the intial state to the error state; (2) a schedule file (e.g., <code>ClientServer_0_0.schedule</code>) that can be used to replay the error trace and single step through the P program with the generated error trace for debugging (more details about debugging P error traces: here).</p>"},{"location":"tutorial/clientserver/","title":"Client Server","text":"How to use this example <p>We assume that you have cloned the P repository locally. <pre><code>git clone https://github.com/p-org/P.git\n</code></pre></p> <p>The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program.</p> <p>To know more about P language primitives used in the example, please look them up in the language manual.</p> <p>System: We consider a client-server application where clients interact with a bank to withdraw money from their accounts.</p> <p></p> <p>The bank consists of two components: (1) a bank server that services withdraw requests from the client; and (2) a backend database which is used to store the account balance information for each client. Multiple clients can concurrently send withdraw requests to the bank. On receiving a withdraw request, the bank server reads the current bank balance for the client and if the withdraw request is allowed then performs the withdrawal, updates the account balance, and responds back to the client with the new account balance.</p> <p>Correctness Specification: The bank must maintain the invariant that each account must have at least 10 dollars as its balance. If a withdraw request takes the account balance below 10 then the withdraw request must be rejected by the bank. The correctness property that we would like to check is that in the presence of concurrent client withdraw requests the bank always responds with the correct bank balance for each client and a withdraw request always succeeds if there is enough balance in the account (that is, at least 10).</p>"},{"location":"tutorial/clientserver/#p-project","title":"P Project","text":"<p>The 1_ClientServer folder contains the source code for the ClientServer project. Please feel free to read details about the recommended P program structure and P project file.</p>"},{"location":"tutorial/clientserver/#models","title":"Models","text":"<p>The P models (PSrc) for the ClientServer example consist of four files:</p> <ul> <li>Client.p: Implements the Client state machine.</li> </ul> [Expand]: Let's walk through Client.p <ul> <li>(L19 - L22)  \u2192 Events <code>eWithDrawReq</code> and <code>eWithDrawResp</code> are used to communicate between the <code>Client</code> and the <code>Server</code> machines (manual: event declaration).</li> <li>(L3 - L17) \u2192 Declares the payload types for the <code>eWithDrawReq</code> and <code>eWithDrawResp</code> events (manual: user defined type).</li> <li>(L25 - L95)  \u2192 Declares the <code>Client</code> state machine (manual: P state machine).<ul> <li>The <code>Client</code> machine has a set of local variables used to store the local-state of the state machine (L27 - L31). <code>Init</code> state is the start state of the machine where the machine starts executions on being created. The entry function of the <code>Init</code> state initializes the local variables based on the parameters received on creation and jumps to the <code>WithdrawMoney</code> state.</li> <li>In the <code>WithdrawMoney</code> state, the state machine checks if there is enough money in the account. If the balance is greater than 10 then it issues a random withdraw request to the bank by sending the <code>eWithDrawReq</code> event (L55) otherwise it jumps to the <code>NoMoneyToWithDraw</code> state. After sending a withdraw request, the machine waits for the <code>eWithDrawResp</code> event (L59). On receiving the <code>eWithDrawResp</code> event, the machine executes the corresponding event handler that confirms if the bank response is as expected and also if there is still money in the account then jumps back to the WithdrawMoney state. Note that each time we (re-)enter a state (through a transition or goto statement), its entry function is executed.</li> </ul> </li> </ul> <ul> <li>Server.p: Implements the BankServer and the backend Database state machines.</li> </ul> [Expand]: Let's walk through Server.p <ul> <li>(L1 - L7) \u2192 Declares the events used to communicate between the bank server and the backend database.</li> <li>(L9 - L48) \u2192 Declares the <code>BankServer</code> machine. The BankServer machine uses a database machine as a service to store the bank balance for all its clients. On receiving an eWithDrawReq (withdraw requests) from a client, it reads the current balance for the account, if there is enough money in the account then it updates the new balance in the database after withdrawal and sends a response back to the client.</li> <li>(L50 - L74) \u2192 Declares the <code>Database</code> machine. The Database machine acts as a helper service for the Bank server and stores the bank balance for each account. There are two API's or functions to interact with the Database: ReadBankBalance and UpdateBankBalance. These functions are implemented as global functions in P (L76 - L92).</li> </ul> <ul> <li>AbstractBankServer.p: Implements the AbstractBankServer state machine that provides a simplified abstraction that unifies the BankServer and Database machines. We will demonstrate how one can replace the complex bank service (consisting of two interacting components, the BankServer and the Database) by its abstraction when checking the client application.</li> </ul> [Expand]: Let's walk through AbstractBankServer.p <ul> <li>(L12 - L37) \u2192 Declares an abstraction of the BankServer machine. The <code>AbstractBankServer</code> provides an implementation of the Bank where the interaction between the BankServer and Database is abstracted away. We use the <code>AbstractBankServer</code> machine to demonstrate how one can replace a complex component in P with an abstraction that hides a lot of its internal complexity. For the client, it still exposes the same interface or behavior. Hence, when checking the correctness of the client it does not matter whether we pair it with the BankServer or the AbstractBankServer.</li> </ul> <p>Key Takeaway</p> <p>To mitigate the state space explosion problem, when modeling and checking complex systems consisting of several components, we would like to check the correctness of each component in isolation. When doing this kind of a compositional reasoning, we replace the environment of the component with its abstraction. The abstraction basically exposes the same interface as the environment but removes its internal complexity, simplifying the overall problem of checking the correctness of the component under test. There is a large body of literature on doing compositional reasoning of distributed systems. You can start with the Modular P paper. How to automatically replace a machine with its abstraction is described below.</p> <ul> <li>ClientServerModules.p: Declares the P modules corresponding to each component in the system.</li> </ul> [Expand]: Let's walk through ClientServerModules.p <ul> <li>(L1 - L5) \u2192 Declares the <code>Client</code> and <code>Bank</code> modules. A module in P is a collection of state machines that together implement that module or component. A system model in P is then a composition or union of modules. The <code>Client</code> module consists of a single machine <code>Client</code> and the <code>Bank</code> module is implemented by machines <code>BankServer</code> and <code>Database</code> together (manual: P module system).</li> <li>(L7 - L8) \u2192 The <code>AbstractBank</code> module uses the <code>binding</code> feature in P modules to bind the <code>BankServer</code> machine to the <code>AbstractBankServer</code> machine. Basically, what this implies is that whenever <code>AbstractBank</code> module is used the creation of the <code>BankServer</code> machine will result in creation of <code>AbstractBankServer</code>, replacing the implementation with its abstraction (manual: primitive modules).</li> </ul>"},{"location":"tutorial/clientserver/#specifications","title":"Specifications","text":"<p>The P Specifications (PSpec) for the ClientServer example are implemented in the BankBalanceCorrect.p file. We define two specifications:</p> <ul> <li>BankBalanceIsAlwaysCorrect (safety property): The BankBalanceIsAlwaysCorrect specification checks the global invariant that the account-balance communicated to the client by the bank is always correct and the bank never removes more money from the account than that withdrawn by the client! Also, if the bank denies a withdraw request then it is only because the withdrawal would reduce the account balance to below 10.</li> <li>GuaranteedWithDrawProgress (liveness property): The GuaranteedWithDrawProgress specification checks the liveness (or progress) property that all withdraw requests submitted by the client are eventually responded.</li> </ul> <p>Stating that BankBalanceIsAlwaysCorrect checks that \"if the bank denies a withdraw request then the request would reduce the balance to below 10 (&lt; 10)\" is equivalent to state that \"if there is enough money in the account - at least 10 (&gt;= 10), then the request must not error\". Hence, the two properties BankBalanceIsAlwaysCorrect and GuaranteedWithDrawProgress together ensure that every withdraw request if allowed will eventually succeed and the bank cannot block correct withdrawal requests.</p> [Expand]: Let's walk through BankBalanceCorrect.p <ul> <li>(L20) \u2192 Event <code>eSpec_BankBalanceIsAlwaysCorrect_Init</code> is used to inform the monitors about the initial state of the Bank. The event is announced by the TestDrivers when setting up the system (here).</li> <li>(L36 - L86) \u2192 Declares the <code>BankBalanceIsAlwaysCorrect</code> safety spec machine that observes the events <code>eWithDrawReq</code>,  <code>eWithDrawResp</code>, and <code>eSpec_BankBalanceIsAlwaysCorrect_Init</code> to assert the required global invariant.</li> <li>(L92 - L115) \u2192 Declares the <code>GuaranteedWithDrawProgress</code> liveness spec machine that observes the events <code>eWithDrawReq</code> and <code>eWithDrawResp</code> to assert the required liveness property that every request is eventually responded by the Bank.</li> <li>To understand the semantics of the P spec machines, please read manual: p monitors.</li> </ul>"},{"location":"tutorial/clientserver/#test-scenarios","title":"Test Scenarios","text":"<p>The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker.</p> <p>The test scenarios folder for ClientServer (PTst) consists of two files TestDriver.p and TestScript.p.</p> [Expand]: Let's walk through TestDriver.p <ul> <li>(L49 - L72) \u2192 Function <code>SetupClientServerSystem</code> takes as input the number of clients to be created and configures the ClientServer system by creating the <code>Client</code> and <code>BankServer</code> machines. The <code>CreateRandomInitialAccounts</code> function uses the <code>choose</code> primitive to randomly initialize the accounts map. The function also  <code>announce</code> the event <code>eSpec_BankBalanceIsAlwaysCorrect_Init</code> to initialize the monitors with initial balance for all accounts (manual: annouce statement).</li> <li>(L3 - L22) \u2192 Machines <code>TestWithSingleClient</code> and <code>TestWithMultipleClients</code> are simple test driver machines that configure the system to be checked by the P checker for different scenarios. In this case, test the ClientServer system by first randomly initializing the accounts map and then checking it with either one <code>Client</code> or with multiple <code>Client</code>s (between 2 and 4)).</li> </ul> [Expand]: Let's walk through TestScript.p <p>P allows programmers to write different test cases. Each test case is checked separately and can use a different test driver. Using different test drivers triggers different behaviors in the system under test, as it implies different system configurations and input generators. To better understand the P test cases, please look at manual: P test cases.</p> <ul> <li>(L4 - L16) \u2192 Declares three test cases each checking a different scenario and system. The system under test is the <code>union</code> of the modules representing each component in the system (manual: P module system). The <code>assert</code> module constructor is used to attach monitors or specifications to be checked on the modules (manual: assert).</li> <li>In the <code>tcAbstractServer</code> test case, instead of composing with the Bank module, we use the AbstractBank module. Hence, in the composed system, whenever the creation of a BankServer machine is invoked the binding will instead create an AbstractBankServer machine.</li> </ul>"},{"location":"tutorial/clientserver/#parameterized-tests","title":"Parameterized Tests","text":"<p>The ClientServer tutorial demonstrates P's parameterized testing capabilities that allow systematic exploration of different system configurations. These tests enable checking the system with varying numbers of clients to validate scalability and concurrent access patterns.</p> [Expand]: Let's walk through parameterized TestDrivers.p <ul> <li>(L24) \u2192 Parameter declaration <code>param nClients: int;</code> defines a configurable parameter for the number of clients to create in the test scenarios.</li> <li>(L26 - L32) \u2192 <code>TestWithConfig</code> machine creates a configurable number of clients based on the <code>nClients</code> parameter, enabling systematic testing of different client loads against the bank server.</li> </ul> [Expand]: Let's walk through parameterized TestScripts.p <ul> <li>(L18 - L21) \u2192 Parameterized test case <code>tcParameterizedMultipleClients</code> with <code>param (nClients in [2, 3, 4])</code> demonstrates how to systematically test the bank system with different numbers of concurrent clients (2, 3, and 4 clients), generating 3 distinct test scenarios.</li> <li>This parameterized approach allows verification of the bank's correctness properties under different concurrency levels, ensuring that the <code>BankBalanceIsAlwaysCorrect</code> and <code>GuaranteedWithDrawProgress</code> specifications hold regardless of client count.</li> <li>The test cases generated are: <code>tcParameterizedMultipleClients___nClients_2</code>, <code>tcParameterizedMultipleClients___nClients_3</code>, and <code>tcParameterizedMultipleClients___nClients_4</code>, each testing the system with the corresponding number of clients.</li> </ul>"},{"location":"tutorial/clientserver/#compiling-clientserver","title":"Compiling ClientServer","text":"<p>Navigate to the 1_ClientServer folder and run the following command to compile the ClientServer project:</p> <pre><code>p compile\n</code></pre> Expected Output <pre><code>$ p compile\n\n.. Searching for a P project file *.pproj locally in the current folder\n.. Found P project file: P/Tutorial/1_ClientServer/ClientServer.pproj\n----------------------------------------\n==== Loading project file: P/Tutorial/1_ClientServer/ClientServer.pproj\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Server.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/Client.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/AbstractBankServer.p\n....... includes p file: P/Tutorial/1_ClientServer/PSrc/ClientServerModules.p\n....... includes p file: P/Tutorial/1_ClientServer/PSpec/BankBalanceCorrect.p\n....... includes p file: P/Tutorial/1_ClientServer/PTst/TestDriver.p\n....... includes p file: P/Tutorial/1_ClientServer/PTst/Testscript.p\n----------------------------------------\nParsing ...\nType checking ...\nCode generation ...\nGenerated ClientServer.cs.\n----------------------------------------\nCompiling ClientServer...\nMSBuild version 17.3.1+2badb37d1 for .NET\nDetermining projects to restore...\nRestored P/Tutorial/1_ClientServer/PGenerated/CSharp/ClientServer.csproj (in 102 ms).\nClientServer -&gt; P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n\nBuild succeeded.\n0 Warning(s)\n0 Error(s)\n\nTime Elapsed 00:00:02.25\n\n\n----------------------------------------\n~~ [PTool]: Thanks for using P! ~~\n</code></pre>"},{"location":"tutorial/clientserver/#checking-clientserver","title":"Checking ClientServer","text":"<p>You can get the list of test cases defined in the ClientServer project by running the P Checker:</p> <pre><code>p check\n</code></pre> Expected Output <pre><code>$ p check\n\n.. Searching for a P compiled file locally in the current folder\n.. Found a P compiled file: P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\n.. Checking P/Tutorial/1_ClientServer/PGenerated/CSharp/net6.0/ClientServer.dll\nError: We found '6' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc).\nPossible options are:\ntcSingleClient\ntcMultipleClients\ntcAbstractServer\ntcParameterizedMultipleClients___nClients_2\ntcParameterizedMultipleClients___nClients_3\ntcParameterizedMultipleClients___nClients_4\n\n~~ [PTool]: Thanks for using P! ~~\n</code></pre> <p>There are six test cases defined in the ClientServer project, and you can specify which test case to run by using the <code>-tc</code> parameter along with the <code>-s</code> parameter for the number of schedules to explore.</p> <p>Check the <code>tcSingleClient</code> test case for 1000 schedules:</p> <pre><code>p check -tc tcSingleClient -s 1000\n</code></pre> <p>Check the <code>tcMultipleClients</code> test case for 1000 schedules:</p> <pre><code>p check -tc tcMultipleClients -s 1000\n</code></pre> <p>Check the parameterized generated <code>tcParameterizedMultipleClients</code> test cases for 1000 schedules each: <pre><code>p check -tc tcParameterizedMultipleClients -s 1000\n</code></pre></p> <p>Check the <code>tcAbstractServer</code> test case for 1000 schedules:</p> <pre><code>p check -tc tcAbstractServer -s 1000\n</code></pre> <p>Error</p> <p><code>tcAbstractServer</code> triggers an error in the AbstractBankServer state machine. Please use the guide to explore how to debug an error trace generated by the P Checker.</p>"},{"location":"tutorial/clientserver/#exercise-problem","title":"Exercise Problem","text":"<ul> <li>[Problem 1] Fix the bug in AbstractBankServer state machine and run the P Checker again on the test case to ensure that there are no more bugs in the models.</li> <li>[Problem 2] Extend the ClientServer example with support for depositing money into the bank. This would require implementing events <code>eDepositReq</code> and <code>eDepositResp</code> which are used to interact between the client and server machine. The Client machine should be updated to deposit money into the account when the balance is low, the BankServer machine implementation would have to be updated to support depositing money into the bank account and finally safety and liveness specifications needs to be updated take disposit events into account. After implementing the deposit feature, run the test-cases again to check if the system still satisfies the desired specifications.</li> </ul> <p>What did we learn through this example?</p> <p>We explored writing P state machines, safety and liveness specifications as P monitors, writing multiple model checking scenarios to check the correctness of a P program, and finally, replacing complex components in P with their abstractions using P's module system.</p>"},{"location":"tutorial/common/","title":"Timer, Failure, and Shared Memory","text":"<p>We also describe how to model system's interaction with an OS Timer Timer, and how to model injecting node failures in the system Failure Injector. These models are used in the Two Phase Commit, Espresso Machine, and Failure Detector models.</p> <p>P is a purely messaging passing based programming language and hence does not support primitives for modeling shared memory based concurrency. But one can always model shared memory concurrency using message passing. We have used this style of modeling when checking the correctness of single node file systems. Please check out shared memory project on how to model shared memory concurrency using P.</p>"},{"location":"tutorial/espressomachine/","title":"Espresso Machine","text":"How to use this example <p>We assume that you have cloned the P repository locally. <pre><code>git clone https://github.com/p-org/P.git\n</code></pre></p> <p>The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program in IntelliJ.</p> <p>To know more about the P language primitives used in the example, please look them up in the language manual.</p> <p>We have reached the middle of our tutorials , it's time to take a break and have an espresso coffee! </p> <p>P has been used in the past to implement device drivers and robotics systems (see case studies and publications). One of the many challenges in implementing such systems is that they are reactive and hence, must handle arbitrary sequences of events (inputs) appropriately depending on their current mode of operation.</p> <p>System: We consider a fun example of modeling an espresso coffee machine and see how we can use P state machines to model a reactive system that must respond correctly to various user inputs. The user interacts with the coffee machine through its control panel. So the Espresso machine basically consists of two parts: the front-end control panel and the backend coffee maker that actually makes the coffee.</p> <p></p> <p>The control panel presents an interface to the user to perform operations like <code>reset</code> machine, turn <code>steamer</code> on and off, request an <code>espresso</code>, and clear the <code>grounds</code> by opening the container. The control panel interprets these inputs from the user and sends appropriate commands to the coffee maker.</p> <p>Correctness Specifications: By default, the P checker tests whether any event that is received in a state has a handler defined for it, otherwise, it would result in an unhandled event exception. If the P checker fails to find a bug then it implies that the system model can handle any sequence of events generated by the given environment which in our example's context implies that the coffee machine control panel can appropriately handle any sequence of inputs (button presses) by the user. We would also like to check that the coffee machine moves through a desired sequence of states, i.e., <code>WarmUp -&gt; Ready -&gt; GrindBeans -&gt; MakeCoffee -&gt; Ready</code>.</p>"},{"location":"tutorial/espressomachine/#p-project","title":"P Project","text":"<p>The 3_EspressoMachine folder contains the source code for the EspressoMachine project. Please feel free to read details about the recommended P program structure and P project file.</p>"},{"location":"tutorial/espressomachine/#models","title":"Models","text":"<p>The P models (PSrc) for the EspressoMachine example consist of three files:</p> <ul> <li>CoffeeMakerControlPanel.p: Implements the CoffeeMakerControlPanel state machine. Basically, the control panel starts in the initial state and kicks off by warming up the coffee maker. After warming is successful, it moves to the ready state where it can either make coffee or start the steamer. When asked to make coffee, it first grinds the beans and then brews coffee. In any of these states, if there is an error due to. e.g, no water or no beans, the control panel informs the user of the error and moves to the error state waiting for the user to reset the machine.</li> </ul> [Expand]: Let's walk through CoffeeMakerControlPanel.p <ul> <li>(L2 - L19)  \u2192 Declare events that are used to communicate between the <code>User</code> and the <code>ControlPanel</code> machines (manual: event declaration). These are events that represent the operations performed by the user, e.g., resetting the machine, pressing the steamer button on and off, etc.</li> <li>(L34 - L231) \u2192 Declares the <code>CoffeeMakerControlPanel</code> state machine. The interesting points that we would like to highlight are: (1) the state machine transitions from one mode (or state) to another based on the events received from the user and the <code>CoffeeMaker</code> machine; (2) in all the states, the state machine appropriately handles different events that can be received, including ignoring or deferring them if they are stale events.</li> </ul> <ul> <li>CoffeeMaker.p: Implements the CoffeeMaker state machine.</li> </ul> [Expand]: Let's walk through CoffeeMaker.p <ul> <li>(L4 - L29) \u2192 Declares the events used to communicate between the control panel and the backend coffee maker.</li> <li>(L31 - L78) \u2192 Declares the <code>EspressoCoffeeMaker</code> machine. EspressoCoffeeMaker receives requests from the control panel of the coffee machine and based on its state e.g., whether heater is working, or it has beans and water, the coffee maker responds nondeterministically back to the controller if the operation succeeded or errored.</li> </ul> <ul> <li>EspressoMachineModules.p: Declares the P module corresponding to EspressoMachine.</li> </ul>"},{"location":"tutorial/espressomachine/#specifications","title":"Specifications","text":"<p>The P Specification (PSpec) for the EspressoMachine example is implemented in Safety.p. We define a safety specification <code>EspressoMachineModesOfOperation</code> that observes the internal state of the EspressoMachine through the events that are announced as the system moves through different states and asserts that it always moves through the desired sequence of states. Steady operation: <code>WarmUp -&gt; Ready -&gt; GrindBeans -&gt; MakeCoffee -&gt; Ready</code>. If an error occurs in any of the states above then the EspressoMachine stays in the error state until it is reset and after which it returns to the <code>Warmup</code> state.</p> [Expand]: Let's walk through Safety.p <ul> <li>(L1 - L7) \u2192 Events used to inform the monitor about the state of the EspressoMachine system. The events are announced as the system moves from one state to another (manual: announce statement).</li> <li>The <code>EspressoMachineModesOfOperation</code> spec machine observes these events and ensures that the system moves through the states defined by the monitor. Note that if the system allows (has execution as) a sequence of events that are not accepted by the monitor (i.e., the monitor throws an unhandled event exception) then the system does not satisfy the desired specification. Hence, this monitor can be thought of accepting only those behaviors of the system that follow the sequence of states modelled by the spec machine. For example, if the system moves from Ready to CoffeeMaking state directly without Grinding then the monitor will raise an ALARM!</li> <li>To understand the semantics of the P spec machines, please read manual: p monitors.</li> </ul>"},{"location":"tutorial/espressomachine/#test-scenarios","title":"Test Scenarios","text":"<p>The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker.</p> <p>The test scenarios folder for EspressoMachine (PTst) consists of three files: TestDriver.p and TestScript.p are just like other previous examples. The User.p declares two machines: (1) a <code>SaneUser</code> machine that uses the EspressoMachine with care, pressing the buttons in the right order, and cleaning up the grounds after the coffee is made; and (2) a <code>CrazyUser</code> machine who has never used an espresso machine before, gets too excited, and starts pushing random buttons on the control panel. Additionally, (3) a <code>SteamerTestUser</code> machine that is specifically designed to test steamer functionality, focusing on steamer operations and subsequent espresso making to validate the machine's handling of steamer-related features.</p>"},{"location":"tutorial/espressomachine/#generated-parameterized-tests","title":"Generated Parameterized Tests","text":"<p>The EspressoMachine tutorial includes comprehensive examples of parameterized testing that demonstrate P's advanced testing capabilities. These tests allow systematic exploration of different system configurations and user behaviors.</p> [Expand]: Let's walk through TestDrivers.p <ul> <li>(L22 - L27) \u2192 Parameter declarations for comprehensive testing scenarios including <code>nOps</code> (number of operations), <code>nUsers</code> (number of users), <code>waterLevel</code> and <code>beanLevel</code> (resource constraints), and boolean flags for <code>enableSteamer</code> and <code>cleaningMode</code>.</li> <li>(L40 - L60) \u2192 <code>TestWithMultipleUsers</code> machine creates multiple users, each with their own coffee machine to avoid contention. This demonstrates testing concurrent scenarios while maintaining realistic one-user-per-machine constraints.</li> <li>(L63 - L77) \u2192 <code>TestWithResourceConstraints</code> machine demonstrates resource-aware testing by conditionally creating users based on available water and bean levels.</li> <li>(L80 - L96) \u2192 <code>TestWithMixedConfiguration</code> machine shows feature flag testing, creating different user types based on machine configuration parameters like cleaning mode and steamer availability.</li> </ul> [Expand]: Let's walk through TestScripts.p <ul> <li>(L10 - L11) \u2192 Basic parameter test <code>tcCrazyUserParamOps</code> demonstrates single-parameter variation testing with <code>nOps in [4, 5, 6]</code>, generating 3 test cases with different operation counts.</li> <li>(L16 - L17) \u2192 Multi-parameter test <code>tcMultiUserOperations</code> shows Cartesian product testing with <code>(nUsers in [1, 2, 3], nOps in [3, 5, 7])</code>, generating 9 test combinations (3\u00d73) to test different user loads and operation counts.</li> <li>(L20 - L21) \u2192 Resource constraint testing <code>tcResourceConstraints</code> demonstrates testing with different water and bean levels to validate system behavior under various resource conditions.</li> <li>(L26 - L27) \u2192 Boolean parameter test <code>tcBooleanConfigs</code> tests all combinations of feature flags <code>enableSteamer</code> and <code>cleaningMode</code> to ensure proper feature interaction behavior.</li> </ul>"},{"location":"tutorial/espressomachine/#compiling-espressomachine","title":"Compiling EspressoMachine","text":"<p>Run the following command to compile the  project:</p> <pre><code>p compile\n</code></pre> Expected Output <pre><code>$ p compile\n\n.. Searching for a P project file *.pproj locally in the current folder\n.. Found P project file: P/Tutorial/3_EspressoMachine/EspressoMachine.pproj\n----------------------------------------\n==== Loading project file: P/Tutorial/3_EspressoMachine/EspressoMachine.pproj\n....... includes p file: P/Tutorial/3_EspressoMachine/PSrc/CoffeeMaker.p\n....... includes p file: P/Tutorial/3_EspressoMachine/PSrc/CoffeeMakerControlPanel.p\n....... includes p file: P/Tutorial/3_EspressoMachine/PSrc/EspressoMachineModules.p\n....... includes p file: P/Tutorial/3_EspressoMachine/PSpec/Safety.p\n....... includes p file: P/Tutorial/3_EspressoMachine/PTst/Users.p\n....... includes p file: P/Tutorial/3_EspressoMachine/PTst/TestDrivers.p\n....... includes p file: P/Tutorial/3_EspressoMachine/PTst/TestScripts.p\n----------------------------------------\nParsing ...\nType checking ...\nCode generation ...\nGenerated EspressoMachine.cs.\n----------------------------------------\nCompiling EspressoMachine...\nMSBuild version 17.3.1+2badb37d1 for .NET\nDetermining projects to restore...\nRestored P/Tutorial/3_EspressoMachine/PGenerated/CSharp/EspressoMachine.csproj (in 102 ms).\nEspressoMachine -&gt; P/Tutorial/3_EspressoMachine/PGenerated/CSharp/net6.0/EspressoMachine.dll\n\nBuild succeeded.\n0 Warning(s)\n0 Error(s)\n\nTime Elapsed 00:00:04.57\n\n\n----------------------------------------\n~~ [PTool]: Thanks for using P! ~~\n</code></pre>"},{"location":"tutorial/espressomachine/#checking-espressomachine","title":"Checking EspressoMachine","text":"<p>You can get the list of test cases defined in the EspressoMachine project by running the P Checker:</p> <pre><code>p check\n</code></pre> Expected Output <pre><code>$ p check\n\n.. Searching for a P compiled file locally in the current folder\n.. Found a P compiled file: P/Tutorial/3_EspressoMachine/PGenerated/CSharp/net6.0/EspressoMachine.dll\n.. Checking P/Tutorial/3_EspressoMachine/PGenerated/CSharp/net6.0/EspressoMachine.dll\nError: We found '30' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc).\nPossible options are:\ntcSaneUserUsingCoffeeMachine\ntcCrazyUserUsingCoffeeMachine\ntcCrazyUserParamOps___nOps_4\ntcCrazyUserParamOps___nOps_5\ntcCrazyUserParamOps___nOps_6\ntcMultiUserOperations___nUsers_1__nOps_3\ntcMultiUserOperations___nUsers_2__nOps_3\ntcMultiUserOperations___nUsers_3__nOps_3\ntcMultiUserOperations___nUsers_1__nOps_5\ntcMultiUserOperations___nUsers_2__nOps_5\ntcMultiUserOperations___nUsers_3__nOps_5\ntcMultiUserOperations___nUsers_1__nOps_7\ntcMultiUserOperations___nUsers_2__nOps_7\ntcMultiUserOperations___nUsers_3__nOps_7\ntcResourceConstraints___waterLevel_0__beanLevel_0\ntcResourceConstraints___waterLevel_25__beanLevel_0\ntcResourceConstraints___waterLevel_50__beanLevel_0\ntcResourceConstraints___waterLevel_100__beanLevel_0\ntcResourceConstraints___waterLevel_0__beanLevel_25\ntcResourceConstraints___waterLevel_25__beanLevel_25\ntcResourceConstraints___waterLevel_50__beanLevel_25\ntcResourceConstraints___waterLevel_100__beanLevel_25\ntcResourceConstraints___waterLevel_0__beanLevel_50\ntcResourceConstraints___waterLevel_25__beanLevel_50\ntcResourceConstraints___waterLevel_50__beanLevel_50\ntcResourceConstraints___waterLevel_100__beanLevel_50\ntcBooleanConfigs___enableSteamer_true__cleaningMode_true\ntcBooleanConfigs___enableSteamer_false__cleaningMode_true\ntcBooleanConfigs___enableSteamer_true__cleaningMode_false\ntcBooleanConfigs___enableSteamer_false__cleaningMode_false\n\n~~ [PTool]: Thanks for using P! ~~\n</code></pre> <p>Above shows the test cases defined in the EspressoMachine project and you can specify which test case to run by using the <code>-tc</code> parameter along with the <code>-s</code> parameter for the number of schedules to explore.</p> <p>Check the <code>tcSaneUserUsingCoffeeMachine</code> test case for 10,000 schedules:</p> <pre><code>p check -tc tcSaneUserUsingCoffeeMachine -s 10000\n</code></pre> <p>Check the <code>tcCrazyUserUsingCoffeeMachine</code> test case for 10,000 schedules:</p> <pre><code>p check -tc tcCrazyUserUsingCoffeeMachine -s 10000\n</code></pre>"},{"location":"tutorial/espressomachine/#exercise-problem","title":"Exercise Problem","text":"<ul> <li>[Problem 1] Note that the current safety specification <code>EspressoMachineModesOfOperation</code> does not capture the case where the CoffeeMaker can move to CoffeeMakerDoorOpened state. Extend the spec to cover those modes of operations as well.</li> </ul> <p>Thinking! ... </p> <p>Can you think of other cases where you would like to check that your system evolves through a certain sequence of states? Or that it allows only those executions which follow a pattern? Can these be specified as P monitors? If not, what are the challenges? A typical example of such cases is when for files in a storage system the sequence of operations that must succeed need to have a pattern of the form: open \u2192 read* \u2192 close; and similarly, for lock services, lockAcquire \u2192 readSuccess \u2192 lockReleased. More interestingly, you can also check things like: AuthenticationSuccess(x) \u2192 ReadSuccess(x), and never see a case of AuthenticationFailure(x) \u2192 ReadSuccess(x) in your executions! What do you think? Post your comments in the github discussions.</p> <p>What did we learn through this example?</p> <p>This was a fun example to demonstrate how to model a reactive system using P state machines. We saw how using P monitors allows us to check that the system moves through the correct modes of operation and that the executions only allow certain patterns.</p>"},{"location":"tutorial/failuredetector/","title":"Failure Detector","text":"<p>Energized with the Coffee , let's get back to modeling distributed systems. After the two phase commit protocol, the next protocol that we will jump to is a simple broadcast-based failure detector!</p> <p>By this point in the tutorial, we have gotten familiar with the P language and most of its features. So, working through this example should be super fast!</p> How to use this example <p>We assume that you have cloned the P repository locally. <pre><code>git clone https://github.com/p-org/P.git\n</code></pre></p> <p>The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program in IntelliJ.</p> <p>To know more about P language primitives used in the example, please look them up in the language manual.</p> <p>System: We consider a simple failure detector that basically broadcasts ping messages to all the nodes in the system and uses a timer to wait for pong responses from all nodes. If a node does not respond with a pong message after multiple attempts (either because of network failure or node failure), the failure detector marks the node as down and notifies the clients about the nodes that are potentially down. We use this example to show how to model network message loss in P and discuss how to model other types of network behaviours.</p> <p></p> <p>Correctness Specification: We would like to check - using a liveness specification - that if the failure injector shuts down a particular node then the failure detector always eventually detects the node failure and notifies the client.</p>"},{"location":"tutorial/failuredetector/#p-project","title":"P Project","text":"<p>The 4_FailureDetector folder contains the source code for the FailureDetector project. Please feel free to read details about the recommended P program structure and P project file.</p>"},{"location":"tutorial/failuredetector/#models","title":"Models","text":"<p>The P models (PSrc) for the FailureDetector example consist of four files:</p> <ul> <li>FailureDetector.p: Implements the <code>FailureDetector</code> machine.</li> </ul> [Expand]: Let's walk through FailureDetector.p <ul> <li>(L1 - L4)  \u2192 Event <code>ePing</code> and <code>ePong</code> are used to communicate between the <code>FailureDetector</code> and the <code>Node</code> state machines (manual: event declaration).</li> <li>(L6) \u2192 Event <code>eNotifyNodesDown</code> is used by the FailureDetector to inform the clients about the nodes that are potentially down.</li> <li>(L14 - L129)  \u2192 Declares the <code>FailureDetector</code> state machine (manual: P state machine). The key points to note in the <code>FailureDetector</code> machine are the usage of the Timer machine to model the usage of OS timer, the usage of ReliableBroadCast, and the usage of UnReliableBroadCast defined in NetworkFunctions.p.</li> </ul> <ul> <li>Node.p: Implements the <code>Node</code> machine.</li> </ul> [Expand]: Let's walk through Node.p <ul> <li>(L4 - L14) \u2192 Declares the <code>Node</code> state machine. The <code>Node</code> machine responds with a <code>ePong</code> message on receiving a <code>ePing</code> message from the <code>FailureDetector</code>. On receiving a <code>eShutDown</code> message from the <code>FailureInjector</code>, the machine halts itself.</li> </ul> <ul> <li>Client.p: Declares the <code>Client</code> machine.</li> </ul> [Expand]: Let's walk through  Client.p <p>The <code>Client</code> machine is a dummy machine that gets a set of alive nodes when the system starts and maintains the set of currently alive nodes by removing the nodes that are marked as down by the <code>FailureDetector</code>.</p> <ul> <li>FailureDetectorModules.p: Declares the <code>FailureDetector</code> module.</li> </ul> [Expand]: Let's walk through FailureDetectorModules.p <p>Declares the <code>FailureDetector</code> module which is the union of the module consisting of the <code>FailureDetector</code>, <code>Node</code>, and <code>Client</code> machines and the <code>Timer</code> module.</p>"},{"location":"tutorial/failuredetector/#specifications","title":"Specifications","text":"<p>The P Specification (PSpec) for the FailureDetector is implemented in ReliableFailureDetector.p. We define a simple <code>ReliableFailureDetector</code> liveness specification to assert that all nodes that have been shutdown by the failure injector will eventually be detected by the failure detector as failed nodes.</p> [Expand]: Let's walk through ReliableFailureDetector.p <ul> <li>(L6 - L57) \u2192 Declares the <code>ReliableFailureDetector</code> liveness monitor. <code>ReliableFailureDetector</code> spec machine basically maintains two sets <code>nodesDownDetected</code> (nodes that are detected as down by the detector) and <code>nodesShutdownAndNotDetected</code> (nodes that are shutdown by the failure injector but not yet detected). <code>ReliableFailureDetector</code> monitor observes the <code>eNotifyNodesDown</code> and <code>eShutDown</code> events to update these maps and move between the <code>hot</code> state (unstable state) and non-hot states. The system is in a hot state if there are nodes that are shutdown but not yet detected by the failure detector. The system violates a liveness specification if any of its execution paths terminates in a hot state.</li> <li>To understand the semantics of the P spec machines and the details about liveness monitors, please read the manual: p monitors.</li> </ul>"},{"location":"tutorial/failuredetector/#test-scenarios","title":"Test Scenarios","text":"<p>The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker.</p> <p>The test scenarios folder for FailureDetector (PTst) consists of two files TestDriver.p and TestScript.p.</p> [Expand]: Let's walk through TestDriver.p <p>This file consists of a single test driver machine that sets up the system under test given the number of nodes and clients in the system. The <code>SetupSystemWithFailureInjector</code> function creates the clients, nodes, failure injector and the failure detector machines.</p> [Expand]: Let's walk through TestScript.p <p>The test script contains two test cases:</p> <ol> <li> <p>Basic test case (TestFailureDetector) that asserts the <code>ReliableFailureDetector</code> specification on a system composed of the <code>FailureDetector</code>, <code>FailureInjector</code>, and test-driver <code>TestMultipleClients</code>.</p> </li> <li> <p>Parameterized test case (tcTest_BalancedLoad) that systematically explores different system configurations:     <pre><code>test param (numNodes in [3, 4, 5], numClients in [2, 3, 4]) tcTest_BalancedLoad:\n  assume (numClients &lt;= numNodes);  // Only test valid configurations\n  assert ReliableFailureDetector in\n  union { TestWithConfig }, FailureDetector, FailureInjector;\n</code></pre>     This test:</p> <ul> <li>Uses parameters declared in TestDriver.p: <code>param numNodes: int; param numClients: int;</code></li> <li>Tests different system sizes (3-5 nodes) and monitoring loads (2-4 clients)</li> <li>Uses <code>assume</code> to ensure clients don't outnumber nodes for better monitoring distribution</li> <li>Tests each valid configuration with the <code>ReliableFailureDetector</code> specification</li> </ul> </li> </ol>"},{"location":"tutorial/failuredetector/#compiling-failuredetector","title":"Compiling FailureDetector","text":"<p>Run the following command to compile the FailureDetector project:</p> <pre><code>p compile\n</code></pre> Expected Output <pre><code>$ p compile\n\n.. Searching for a P project file *.pproj locally in the current folder\n.. Found P project file: P/Tutorial/4_FailureDetector/FailureDetector.pproj\n----------------------------------------\n==== Loading project file: P/Tutorial/4_FailureDetector/FailureDetector.pproj\n....... includes p file: P/Tutorial/4_FailureDetector/PSrc/FailureDetectorModules.p\n....... includes p file: P/Tutorial/4_FailureDetector/PSrc/Client.p\n....... includes p file: P/Tutorial/4_FailureDetector/PSrc/FailureDetector.p\n....... includes p file: P/Tutorial/4_FailureDetector/PSrc/Node.p\n....... includes p file: P/Tutorial/4_FailureDetector/PSpec/ReliableFailureDetector.p\n....... includes p file: P/Tutorial/4_FailureDetector/PTst/TestDriver.p\n....... includes p file: P/Tutorial/4_FailureDetector/PTst/TestScript.p\n==== Loading project file: P/Tutorial/Common/Timer/Timer.pproj\n....... includes p file: P/Tutorial/Common/Timer/PSrc/Timer.p\n....... includes p file: P/Tutorial/Common/Timer/PSrc/TimerModules.p\n==== Loading project file: P/Tutorial/Common/FailureInjector/FailureInjector.pproj\n....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/NetworkFunctions.p\n....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/FailureInjector.p\n----------------------------------------\nParsing ...\nType checking ...\nCode generation ...\nGenerated FailureDetector.cs.\n----------------------------------------\nCompiling FailureDetector...\nMSBuild version 17.3.1+2badb37d1 for .NET\nDetermining projects to restore...\nRestored P/Tutorial/4_FailureDetector/PGenerated/CSharp/FailureDetector.csproj (in 93 ms).\nFailureDetector -&gt; P/Tutorial/4_FailureDetector/PGenerated/CSharp/net6.0/FailureDetector.dll\n\nBuild succeeded.\n0 Warning(s)\n0 Error(s)\n\nTime Elapsed 00:00:04.42\n\n\n----------------------------------------\n~~ [PTool]: Thanks for using P! ~~\n</code></pre>"},{"location":"tutorial/failuredetector/#checking-failuredetector","title":"Checking FailureDetector","text":"<p>You can get the list of test cases defined in the FailureDetector project by running the P Checker:</p> <pre><code>p check\n</code></pre> Expected Output <pre><code>$ p check\n\n.. Searching for a P compiled file locally in folder ./PGenerated/\n.. Found a P compiled file: ./PGenerated/PChecker/net8.0/FailureDetector.dll\n.. Checking ./PGenerated/PChecker/net8.0/FailureDetector.dll\nError: We found '9' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc).\nPossible options are: \ntcTest_FailureDetector\ntcTest_BalancedLoad___numNodes_3__numClients_2\ntcTest_BalancedLoad___numNodes_4__numClients_2\ntcTest_BalancedLoad___numNodes_5__numClients_2\ntcTest_BalancedLoad___numNodes_3__numClients_3\ntcTest_BalancedLoad___numNodes_4__numClients_3\ntcTest_BalancedLoad___numNodes_5__numClients_3\ntcTest_BalancedLoad___numNodes_4__numClients_4\ntcTest_BalancedLoad___numNodes_5__numClients_4\n\n~~ [PTool]: Thanks for using P! ~~\n</code></pre> <p>Above shows the test cases defined in the FailureDetector project and you can specify which test case to run by using the <code>-tc</code> parameter along with the <code>-s</code> parameter for the number of schedules to explore.</p> <p>Check the <code>tcTest_FailureDetector</code> test case for 10,000 schedules:</p> <pre><code>p check -tc tcTest_FailureDetector -s 10000\n</code></pre>"},{"location":"tutorial/failuredetector/#discussion-modeling-message-reordering","title":"Discussion: Modeling Message Reordering","text":"<p>(to be added soon)</p>"},{"location":"tutorial/failuredetector/#exercise-problem","title":"Exercise Problem","text":"<p>What did we learn through this example?</p> <p>In this example, we saw how to use data nondeterminism to model message loss and unreliable sends. We also discussed how to model other types of network nondeterminism.</p>"},{"location":"tutorial/paxos/","title":"Paxos","text":"<p>How can we finish our tutorials on modeling distributed systems without giving tribute to the Paxos protocol  (and our inspiration Leslie Lamport). Let's end the tutorial with a simplified single decree paxos.</p> <p>In this example, we present a simplified model of the single decree paxos. We say simplified because general paxos is resilient against arbitrary network (lossy, duplicate, re-order, and delay), in our case we only model message loss and delay, and check correctness of paxos in the presence of such a network. This is a fun exercise, we encourage you to play around and create variants of paxos!</p> <p>Summary</p> <p>In this example, we present a simplified model of the single decree paxos. (Todo: add details about the properties checked)</p>"},{"location":"tutorial/twophasecommit/","title":"Two Phase Commit","text":"How to use this example <p>We assume that you have cloned the P repository locally. <pre><code>git clone https://github.com/p-org/P.git\n</code></pre></p> <p>The recommended way to work through this example is to open the P/Tutorial folder in IntelliJ side-by-side a browser using which you can simultaneously read the description for each example and browse the P program in IntelliJ.</p> <p>To know more about the P language primitives used in this example, please look them up in the language manual.</p> <p>Now that we understand the basic features of the P language, let's look at the modeling and analysis of a distributed system !</p> <p>System: We use a simplified version of the classic two phase commit protocol to model a transaction commit service. The two phase commit protocol uses a coordinator to gain consensus for any transaction spanning across multiple participants. A transaction in our case is simply a <code>write</code> operation for a key-value data store where the data store is replicated across multiple participants. More concretely, a <code>write</code> transaction must be committed by the coordinator only if it's accepted by all the participant replicas, and must be aborted if any one of the participant replicas rejects the <code>write</code> request.</p> <p></p> <p>A two phase commit protocol consists of two phases  (figure above). On receiving a write transaction, the coordinator starts the first phase in which it sends a <code>prepare</code> request to all the participants and waits for a <code>prepare success</code> or <code>prepare failure</code> response. On receiving prepare responses from all the participants, the coordinator moves to the second phase where it sends a <code>commit</code> or <code>abort</code> message to the participants and also responds back to the client.</p> <p>Assumptions: Our transaction commit system is ridiculously simplified. To list a few: (1) our system does allow multiple concurrent clients to issue transactions in parallel, but the coordinator serializes these transactions and services them one-by-one; (2) our system is not fault-tolerant to node failures, failure of either the coordinator or any of the participants will block the progress forever. Also, we rely on P's reliable send semantics to model the behavior of the underlying network, hence, our system models assume reliable delivery of messages.</p> <p>Correctness Specification: We would like our transaction commit service to provide atomicity guarantees for each transaction. That is, if the service responds to the client that a transaction was committed then that transaction must have been committed by each of its participants; and, if a transaction is aborted then at least one of the participants must have rejected it. We would also like to check that under the assumptions above (no node failures and reliable network), each transaction request is eventually responded by the transaction commit service.</p>"},{"location":"tutorial/twophasecommit/#p-project","title":"P Project","text":"<p>The 2_TwoPhaseCommit folder contains the source code for the TwoPhaseCommit project. Please feel free to read details about the recommended P program structure and P project file.</p>"},{"location":"tutorial/twophasecommit/#models","title":"Models","text":"<p>The P models (PSrc) for the TwoPhaseCommit example consists of three files:</p> <ul> <li>Coordinator.p: Implements the Coordinator state machine.</li> </ul> [Expand]: Let's walk through Coordinator.p <ul> <li>(L25 - L33) \u2192 Declares the <code>write</code> and <code>read</code> transaction events used to communicate between the coordinator and the client machines (manual: event declaration).</li> <li>(L35 - L43) \u2192 Declares the <code>prepare</code>, <code>commit</code>, and <code>abort</code> events used to communicate between the coordinator and the participants in the system.</li> <li>(L3 - L16) \u2192 Declares the payload types associated with these events (manual: user defined type).</li> <li>(L65 - L177) \u2192 Declares the <code>Coordinator</code> state machine. The Coordinator machine receives write and read transactions from the clients. The coordinator machine services these transactions one by one in the order in which they were received. On receiving a write transaction, the coordinator sends a prepare request to all the participants and waits for prepare responses from all the participants. Based on the responses, the coordinator either commits or aborts the transaction. If the coordinator fails to receive agreement from the participants in time, then it times out and aborts the transaction. On receiving a read transaction, the coordinator randomly selects a participant and forwards the read request to that participant.</li> </ul> <ul> <li>Participant.p: Implements the Participant state machine.</li> </ul> [Expand]: Let's walk through Participant.p <ul> <li>Unlike the <code>Coordinator</code> state machine that has multiple states, the <code>Participant</code> state machine is fairly simple. Each participant waits for requests from the <code>Coordinator</code> and sends the response back based on whether the request can be accepted or has to be rejected.</li> <li>On receiving an <code>eShutDown</code> event, the participant executes a <code>raise halt</code> to destroy itself. To know more about the special <code>halt</code> event, please check the manual: halt event.</li> <li>Each participant maintains a local key-value store which is updated based on the transactions committed by the coordinator. On receiving a prepare request from the coordinator, the participant chooses to either accept or reject the transaction based on the associated transaction id.</li> </ul> <ul> <li>TwoPhaseCommitModules.p: Declares the P module corresponding to the two phase commit system.</li> </ul>"},{"location":"tutorial/twophasecommit/#timer-and-failure-injector","title":"Timer and Failure Injector","text":"<p>Our two phase commit project depends on two other components:</p> <ul> <li> <p>OS Timer: The coordinator machine uses a timer to wait for prepare responses from all participants. The <code>OS timer</code> is modeled in P using the <code>Timer</code> machine declared in the <code>Timer project</code>. The Timer model demonstrates how when reasoning about the correctness of a system, we need to also model its interaction with any nondeterministic environment or service (in this case, an OS timer).</p> </li> <li> <p>Failure Injector: P allows programmers to explicitly model different types of failures in the system. The <code>FailureInjector</code> project demonstrates how to model node failures in P using the <code>halt</code> event. The <code>FailureInjector</code> machine nondeterministically picks a node and sends a <code>eShutDown</code> event. On receiving an <code>eShutDown</code> event, the corresponding node must <code>halt</code> to destroy itself. To know more about the special <code>halt</code> event, please check the manual: halt event.</p> </li> </ul>"},{"location":"tutorial/twophasecommit/#specifications","title":"Specifications","text":"<p>The P Specifications (PSpec) for the TwoPhaseCommit example are implemented in the Atomicity.p file. We define two specifications:</p> <ul> <li> <p>Atomicity (safety property): if a transaction is committed by the coordinator then it was agreed on by all participants, and if the transaction is aborted then at least one participant must have rejected the transaction.</p> </li> <li> <p>Progress (liveness property): every received transaction must be eventually responded (in the absence of node failures).</p> </li> </ul> <p>Weaker Property</p> <p>Note that we have asserted a weaker property than what is required for Atomicity. Ideally, we would like to check that if a transaction is committed by the coordinator then it was committed-locally by all participants, and if the transaction is aborted then at least one participant must have rejected the transaction and all the participants aborted the transaction. We leave implementing this stronger property as an exercise problem, which you can revisit after finishing the other problems in the tutorials.</p>"},{"location":"tutorial/twophasecommit/#test-scenarios","title":"Test Scenarios","text":"<p>The test scenarios folder in P has two parts: TestDrivers and TestScripts. TestDrivers are collections of state machines that implement the test harnesses (or environment state machines) for different test scenarios. TestScripts are collections of test cases that are automatically run by the P checker.</p> <p>The test scenarios folder for TwoPhaseCommit (PTst) consists of three files TestDriver.p, TestScript.p and Client.p.</p> [Expand]: Let's walk through TestDriver.p <ul> <li>(L9 - L42) \u2192 Function <code>SetUpTwoPhaseCommitSystem</code> takes as input <code>t2PCConfig</code> that specifies the number of clients, participants, etc. to be created and sets up the system by creating the machines. The function also initializes the spec monitors by informing them about the number of participants in the system before the system starts executing here.</li> <li>(L3 - L22) \u2192 Machines <code>SingleClientNoFailure</code>, <code>MultipleClientsNoFailure</code> and <code>MultipleClientsWithFailure</code> are simple test driver machines that configure the system to be checked by the P checker for different scenarios.</li> <li>The <code>TestWithConfig</code> machine enables parameterized testing with four configurable parameters:     <pre><code>param pNumClients: int;         // Number of clients in the system\nparam pNumParticipants: int;    // Number of participants\nparam pNumTransPerClient: int;   // Transactions per client\nparam pFailParticipants: int;   // Number of participants that can failt\n</code></pre>     This allows systematic exploration of different system configurations and failure scenarios.</li> </ul> [Expand]: Let's walk through TestScript.p <p>P allows programmers to write different test cases. Each test case is checked separately and can use a different test driver. Using different test drivers triggers different behaviors in the system under test, as it implies different system configurations and input generators. To better understand the P test cases, please look at manual: P test cases.</p> <p>The test script contains two types of test cases:</p> <ol> <li> <p>Basic test cases that use fixed configurations:</p> <ul> <li><code>tcSingleClientNoFailure</code>: Tests with 1 client, 3 participants, no failures</li> <li><code>tcMultipleClientsNoFailure</code>: Tests with 2 clients, 3 participants, no failures</li> <li><code>tcMultipleClientsWithFailure</code>: Tests with 2 clients, 3 participants, 1 failure</li> </ul> </li> <li> <p>Parameterized test case that systematically explores different configurations:     <pre><code>test param (pNumClients in [2, 3], pNumParticipants in [3, 4, 5], \n        pNumTransPerClient in [1, 2], pFailParticipants in [0, 1])\nassume (pNumParticipants &gt; pNumClients &amp;&amp; pFailParticipants &lt; pNumParticipants/2)\n(2 wise) tcPairwiseTest [main=TestWithConfig]:\nassert AtomicityInvariant, Progress in\n(union TwoPhaseCommit, TwoPCClient, FailureInjector, { TestWithConfig });\n</code></pre>     This test:</p> <ul> <li>Uses pairwise testing to efficiently cover parameter combinations</li> <li>Ensures valid configurations through assumptions:</li> <li>More participants than clients for proper distribution</li> <li>Less than half participants can fail for system stability</li> <li>Tests both atomicity and progress properties</li> </ul> </li> </ol> [Expand]: Let's walk through Client.p <p>The <code>Client</code> machine implements the client of the two-phase-commit transaction service. Each client issues N non-deterministic write-transactions, if the transaction succeeds then it performs a read-transaction on the same key and asserts that the value read is same as what was written by the write transaction.</p> <ul> <li>(L60) \u2192 Declares a foreign function in P. Foreign functions are functions that are declared in P but implemented in the external foreign language. Please read the example in P foreign interface to know more about this functionality. In this example, the <code>ChooseRandomTransaction</code> function could have been very easily written in P itself but it's implemented as foreign function just to demonstrate that P supports this functionality.</li> </ul>"},{"location":"tutorial/twophasecommit/#compiling-twophasecommit","title":"Compiling TwoPhaseCommit","text":"<p>Navigate to the 2_TwoPhaseCommit folder and run the following command to compile the TwoPhaseCommit project:</p> <pre><code>p compile\n</code></pre> Expected Output <pre><code>$ p compile\n\n.. Searching for a P project file *.pproj locally in the current folder\n.. Found P project file: P/Tutorial/2_TwoPhaseCommit/TwoPhaseCommit.pproj\n----------------------------------------\n==== Loading project file: P/Tutorial/2_TwoPhaseCommit/TwoPhaseCommit.pproj\n....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSrc/Coordinator.p\n....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSrc/Participant.p\n....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSrc/TwoPhaseCommitModules.p\n....... includes p file: P/Tutorial/2_TwoPhaseCommit/PSpec/Atomicity.p\n....... includes p file: P/Tutorial/2_TwoPhaseCommit/PTst/TestDriver.p\n....... includes p file: P/Tutorial/2_TwoPhaseCommit/PTst/Client.p\n....... includes p file: P/Tutorial/2_TwoPhaseCommit/PTst/TestScripts.p\n....... includes foreign file: P/Tutorial/2_TwoPhaseCommit/PForeign/ForeignCode.cs\n==== Loading project file: P/Tutorial/Common/Timer/Timer.pproj\n....... includes p file: P/Tutorial/Common/Timer/PSrc/Timer.p\n....... includes p file: P/Tutorial/Common/Timer/PSrc/TimerModules.p\n==== Loading project file: P/Tutorial/Common/FailureInjector/FailureInjector.pproj\n....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/NetworkFunctions.p\n....... includes p file: P/Tutorial/Common/FailureInjector/PSrc/FailureInjector.p\n----------------------------------------\nParsing ...\nType checking ...\nCode generation ...\nGenerated TwoPhaseCommit.cs.\n----------------------------------------\nCompiling TwoPhaseCommit...\nMSBuild version 17.3.1+2badb37d1 for .NET\nDetermining projects to restore...\nRestored P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/TwoPhaseCommit.csproj (in 92 ms).\nTwoPhaseCommit -&gt; P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/net6.0/TwoPhaseCommit.dll\n\nBuild succeeded.\n0 Warning(s)\n0 Error(s)\n\nTime Elapsed 00:00:04.65\n\n\n----------------------------------------\n~~ [PTool]: Thanks for using P! ~~\n</code></pre>"},{"location":"tutorial/twophasecommit/#checking-twophasecommit","title":"Checking TwoPhaseCommit","text":"<p>You can get the list of test cases defined in the TwoPhaseCommit project by running the P Checker:</p> <pre><code>p check\n</code></pre> Expected Output <pre><code>$ p check\n\n.. Searching for a P compiled file locally in the current folder\n.. Found a P compiled file: P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/net6.0/TwoPhaseCommit.dll\n.. Checking P/Tutorial/2_TwoPhaseCommit/PGenerated/CSharp/net6.0/TwoPhaseCommit.dll\nError: We found '10' test cases. Please provide a more precise name of the test case you wish to check using (--testcase | -tc).\nPossible options are:\ntcSingleClientNoFailure\ntcMultipleClientsNoFailure\ntcMultipleClientsWithFailure\ntcParametricTests___pNumClients_2__pNumParticipants_3__pNumTransPerClient_1__pFailParticipants_0\ntcParametricTests___pNumClients_3__pNumParticipants_4__pNumTransPerClient_2__pFailParticipants_0\ntcParametricTests___pNumClients_3__pNumParticipants_5__pNumTransPerClient_1__pFailParticipants_1\ntcParametricTests___pNumClients_2__pNumParticipants_4__pNumTransPerClient_2__pFailParticipants_1\ntcParametricTests___pNumClients_2__pNumParticipants_5__pNumTransPerClient_2__pFailParticipants_0\ntcParametricTests___pNumClients_2__pNumParticipants_4__pNumTransPerClient_1__pFailParticipants_0\ntcParametricTests___pNumClients_2__pNumParticipants_3__pNumTransPerClient_2__pFailParticipants_0\n\n~~ [PTool]: Thanks for using P! ~~\n</code></pre> <p>There are three test cases defined in the TwoPhaseCommit project and you can specify which test case to run by using the <code>-tc</code> parameter along with the <code>-s</code> parameter for the number of schedules to explore.</p> <p>Check the <code>tcSingleClientNoFailure</code> test case for 10,000 schedules:</p> <pre><code>p check -tc tcSingleClientNoFailure -s 10000\n</code></pre> <p>Check the <code>tcMultipleClientsNoFailure</code> test case for 10,000 schedules:</p> <pre><code>p check -tc tcMultipleClientsNoFailure -s 10000\n</code></pre> <p>Error</p> <p><code>tcMultipleClientsNoFailure</code> triggers a very subtle concurrency bug in the assumption made by the client of the two phase commit protocol.</p> <p><code>&lt;ErrorLog&gt; Assertion Failed: PTst/Client.p:42:13 Record read is not same as what was written by the client:: read - X, written - Y</code></p> <p>Please use the guide to explore how to debug an error trace generated by P Checker.</p> <p>Hint</p> <p>If you dive deeper in the log, you would notice that the error happens when two clients write to the same key. There is a race between the two clients issuing a write and read transaction on the same key with different values. The fix for this problem is to update the assertion on the client side to: if the value that is read when confirming the transaction is not the same as the value that was written then it must have been overridden by a transaction with id greater than its transaction id. This is true because Participants accept transaction to the same key in the monotonically increasing transaction ids.</p> <p>Check the <code>tcMultipleClientsWithFailure</code> test case for 10,000 schedules:</p> <pre><code>p check -tc tcMultipleClientsWithFailure -s 10000\n</code></pre> <p>Error</p> <p><code>tcMultipleClientsWithFailure</code> demonstrates the known case where in the presence of node failures the two phase commit protocol does not guarantee progress.</p> <p><code>&lt;ErrorLog&gt; Deadlock detected. Client(7) is waiting to receive an event, but no other controlled tasks are enabled.</code></p> <p>Please use the guide to explore how to debug an error trace generated by P Checker.</p> <p>If you comment out the part of the Client state machine code that performs the read transaction then you would see that the Progress liveness monitor starts complaining.</p> <p>Check the parameterized generated <code>tcParametricTests</code> test cases for 1000 schedules each: <pre><code>p check -tc tcParametricTests -s 1000\n</code></pre></p>"},{"location":"tutorial/twophasecommit/#exercise-problem","title":"Exercise Problem","text":"<ul> <li> <p>[Problem 1] Based on the hint above, try and fix the concurrency bug in the <code>Client</code> state machine and run the test cases again!</p> </li> <li> <p>[Problem 2] A really interesting exploratory problem would be to try and combine the two phase commit protocol with the failure detector system to overcome the progress issue faced by the two phase commit protocol in the presence of node failures. Can you really do that? Let's have a discussion and build a variant of the protocol to tolerate failures?</p> </li> </ul> <p>What did we learn through this example?</p> <p>We dived deeper into: (1) modeling non-determinism in distributed systems, in particular, time-outs; (2) writing complex safety properties like atomicity of transactions in P; and finally, (3) modeling node failures in P using a failure injector state machine. We will also show how P allows invoking foreign code from the P programs. More details in P foreign interface.</p>"}]}